# **JVM内存区域**

除了direct buffer，其他内存区域都属于JVM的运行时数据区域

# **1. Java内存区域**

`Java内存区域`和`JMM内存模型`是不同的两个东西：

- **内存区域是指Jvm运行时将数据分区域存储，强调对内存的划分** 
- JMM定义了JVM在计算机内存的工作方式，与并发编程更相关

## 操作系统底层线程模型：

- 1:1模型

    使用内核线程实现，内核线程是直接由内核Kernel支持的线程，程序一般不会直接使用内核线程，而是用内核线程的一种轻量级线程接口（LWP）
    
    轻量级线程也就是**意义上的java多线程**，每个轻量级线程对应一个内核线程支持，俗称1:1

    内核线程保证了系统对线程的**可见性**，如果一个LWP线程阻塞了，也不会影响到同一进程上的另一LWP线程，进程不会因此阻塞

    缺点：每次切换都要从用户态->内核态->用户态

- n：1模型

    用户线程完全建立在用户空间的线程库上，可以简单理解为绑定在一个内核线程上，这种线程不需要切换内核态

    缺点：若一个用户态线程阻塞，整个进程阻塞。即线程操作由用户解决，阻塞处理十分困难，十分复杂

- m：n模型

## Java的线程调度模型：抢占式调度

    每个线程都由系统分配执行时间，线程切换不依赖线程自己决定，若希望系统分配更多时间，则通过设置线程优先级来使得某些线程能在同一时间段内获得更多的操作时间

    总共有十个优先级Thread.MIN_PRIORITY至Thread.MAX_PRIORITY

![](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL3N6X21tYml6X3BuZy9rcmpsNlFiaWE2V2tldld1dlFpYmxYaWJyZm5aWmRPWWxBQzJxRGM4MmNnOFQ0eGNRaWNlZ1ptWXJIZVF3aWM3V3ZZRDd2bTBDRkxnWGliSWVkQ1V2dTZnQkxLQS82NDA?x-oss-process=image/format,png)

![vm内存区域](https://images2015.cnblogs.com/blog/584866/201704/584866-20170426175411428-34722603.png)

![执行引擎-线程私有(PC、虚拟机栈、本地方法栈)](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL3N6X21tYml6X3BuZy9rcmpsNlFiaWE2V2tldld1dlFpYmxYaWJyZm5aWmRPWWxBQ0xuSDc5cDEwVWV5UFN3TjFqS24wUWNsSFo4MUpLTENkS2lhaWFhbVhlUWFtUXIwbG43UDNub09RLzY0MA?x-oss-process=image/format,png)

## **1.1 程序计数器（线程私有）**

是当前线程所执行的**字节码的行号指示器**，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令

它是**程序控制流的指示器，分支（if, switch/循环(iterator)/异常处理(try-catch)/线程恢复(yield,wait)等操作**等基础操作都需要计数器完成

由于程序在多线程下切换，在任何一个确定的时刻，一个处理器都只会执行一条线程中的指令，为了线程切换后能恢复到正确的执行位置，**线程都需要有一个独立的计数器，各个线程之间的计数器互不影响**

如果线程正在执行一个Java方法，这个计数器记录的是**正在执行的虚拟机字节码指令的地址**

## **1.2 java虚拟机栈（线程私有）**

### **栈帧**

- **局部变量表**

    堆栈分析中，栈分析中最多情况下的内容

    局部变量表存放了编译器可知的：
    - Java虚拟机基本数据类型（boolean/int/float/long/double）
    - 对象引用
    - returnAddress

    数据类型在局部变量中会以局部变量槽Slot来表示，double和long一般占用两个变量槽，这样在编译期通过后，局部变量表的大小是完全确定的，在方法运行期间也不会再改变局部变量表大小
    
    变量槽不固定具体比特大小，具体大小由对应虚拟机实现。

- **操作栈**

    JVM的执行引擎是基于栈的操作引擎，其中的栈指的就是操作栈

- 动态连接

    每个栈帧包含一个在常量池对该方法的引用，支持方法调用过程的动态链接

- 方法出口

    相当于弹出当前栈帧，退出的方式有三种：
    1. 返回值压入上层调用的栈帧（在某个方法调用另一个方法）
    2. 异常信息抛给能处理的栈帧（捕获异常或继续向外抛出异常）
    3. PC计数器指向方法调用后的下一条指令（继续往下执行）

Java虚拟机栈生命周期：与线程相同

描述的是Java方法执行时的数据结构：每个方法在执行时都会创建一个栈帧（Stack Frame）

只有位于栈顶的栈帧才是有效的，也称为当前栈帧，其对应的方法也称为当前方法，在执行引擎时，所有指令只对栈顶执行

**每个Java方法从调用到执行完毕，即对应一个栈帧从虚拟机栈中入栈到出栈的过程**

    在活动过程中，只有处于栈顶的栈帧才是有效的，成为当前栈帧，正在执行的方法称为当前方法，所有指令都只对当前栈帧做操作

    该模块区域可以认为是CPU高速缓存/寄存器（操作数栈）所使用的工作内存（局部变量表），但是不可能一概而论去与JMM进行对应
    
    因为JMM是为了解决共享数据（简单认为是堆里的对象实例部分数据）读写一致性问题的模型

    以上模型，JVM规范定义的线程对内存间的交互操作对应JMM：
    
    1. Read读取，作用于主存的变量，从主内存（堆）上读取数据，传输到工作内存中
    2. Load加载，作用于工作内存的变量（局部变量表），加载线程的工作内存中的值到工作内存的变量副本中（操作数栈）
    3. Use使用，作用于工作内存中的变量，把工作内存中的一个变量的值传递给执行引擎
    3. 内核级线程对应LWP，基于栈（操作数栈）执行得到结果
    4. Assign赋值，作用于工作内存的变量，将工作内存变量副本的值冲刷回工作内存
    5. Store存储，作用于工作内存的变量，将工作内存的值传输到主内存中
    6. Write写入，作用于主内存的变量，将Store得到的值刷回主内存（读写不一致也就是在此时出现）

    主存 -> 堆
    工作内存 -> 局部变量表
    工作内存的变量副本 -> 操作栈

## **1.3 本地方法栈**

与Vm Stack类似，用于Native方法调用

**栈深度溢出StackOverflowError， 栈扩展溢出OutOfMemoryError**

**HotSpot的栈容量无法动态扩展，在申请成功时就就已经确定，所以不会出现OOM，但如果是在申请时就失败，也会出现OOM**

    延伸i++和++i的并发问题，以JMM和VM内存区域诠释：
    
    1. i++，先从主存中（堆）中获取i的数值，加载到工作内存（虚拟机栈的局部变量表）中，当线程操作时，会读取i的值压入操作栈，然后再对局部变量表的i值+1，这样在操作栈取出使用的就是自增前的值

    2. ++i反之

    并发问题：
        这个操作其实分为3步，不是一个原子操作：i从内存中取出压入栈，内存i值自增1，将操作栈（寄存器）取出使用。
        
        其中第二步，会将工作内存的值刷回到主存中，如果没有同步操作，则会出现并发问题

        即使是对i使用了volatile，也无法确保其安全性。因为就算每次工作内存都能获取最新的值，但是在往回写入主存时，仍没解决并发执行导致值覆盖的情况。

## **1.4 Java堆**

Jvm管理内存最大的一块区域，常出现内存泄漏的地方，所有线程共享，对应JMM的主存

**唯一目的：存放对象实例，所有的对象实例以及数组都应当在堆上分配**

是垃圾收集器管理的内存区域，由于现代垃圾收集器大部分是基于分代收集理论，所以堆中常出现：

**新生代，老年代。永久代（已去除），Eden空间，From Survior空间，To Survior空间**

- **新生代（1/3）：Eden(8/10)/From Survior(1/10)/To Survior(1/10)**

- **老年代（2/3）**

**从分配内存的角度看**，所有线程共享的Java堆中可以划分出多个线程私有的分配缓冲区（TLAB），以提升对象分配时的效率

堆内存物理上可以不连续，但是要在逻辑上连续

### 1.4.1 TLAB

是为了解决线程分配时的竞争问题，这一切都与new和指针碰撞有关

#### 指针碰撞

假设JVM堆的内存区域都是规整的，堆内存被一个指针一分为二，一边为已使用区域，一边为未使用区域，当需要创建新对象时，指针会往右移动一个size的距离，并填上新的对象
    
多个线程在分配内存时，会根据指针位置在未使用区域分配内存，这也就会出现A线程在分配内存，指针未修改完毕的同时，有B线程也同时去分配内存，出现竞争问题

**vm通过CAS加失败重试的方式解决竞争问题，但是如果对象回收过于频繁会导致性能低效，所以为每个线程分配一个线程私有堆区域，每个线程都在TLAB上分配内存。只有当缓存区不够时，才通过CAS的方式去其他区域分配**

## **1.5 方法区**

方法区与Java堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的**类型信息，常量，静态变量，JIT编译后的代码缓存**数据

难点在于JDK8之前与之后的实现：
    
> JDK8之前使用永久代实现，JDK8之后使用元空间（本地内存）实现

- 字符串常量池转移到堆中（可通过设置-Xmx和-Xms参数，创建静态字符串查看是否出现OOM）
- 静态/运行时常量池转移到元空间中
- PermSize和MaxPermSize参数移除

### 1.5.1 JDK8之前的方法区

JDK8之前，这个区域更多称为永久代，虽然两者并不等价，因为仅仅是因为HotSpot选择把GC的分代设计扩展至方法区（用永久代来实现方法区），省去专门为方法区编写内存管理代码的工作量。而且该区域的可以选择不实现垃圾收集，所以垃圾收集行为在该区域较少出现，当方法区无法满足内存需要时，将抛出OOM

这种设计导致了Java应用更容易遇到OOM的问题
- 字符串存在永久代里，容易出现性能问题和瓶颈
- 类及方法信息很难确定大小，因此对于永久代的大小指定非常困难，太小容易OOM，太大容易导致老年代溢出
- 永久代为GC带来不必要的复杂度，并且回收率低

### 1.5.2 JDK8方法区

HotSpot与JRocket二合为一，使用本地内存（元空间）来实现方法区

在JDK7中，将字符串常量池/静态变量移出

JDK8完全废弃永久代，把JDK7中永久代的剩余内容（主要是类型信息）全部移到本地内存（元空间）中

![JDK8废除永久代](https://images2015.cnblogs.com/blog/584866/201704/584866-20170426154633834-741444326.jpg)

永久代（方法区的实现） : PermGen -----> 替换为Metaspace(本地内存 / 元空间)

### 1.5.3 元空间

元空间是JDK8在虚拟机中对方法区的实现

元空间与永久代的最大不同是，**元空间并不在虚拟机中，而是使用本地内存**

通过设置 -XX:MetaspaceSize = ... -XX:MaxMetaspaceSize = ...，可以设置元空间的大小

### 1.5.4 常量池

常量池有以下三种：

- 静态常量池（转移到元空间中）

    即*.class文件的常量池，在编译时加载

    这种常量池主要用于存放两大类常量：**字面量、符号引用量**（类和接口的全限定名、字段名称和限定符、方法名称和限定符）

- 运行时常量池（转移到元空间中）

    方法区的一部分，用于在类加载后存放常量池表和静态常量池的两大类常量

    相较于静态常量池，强调**具备动态性**，这也使得java不要求常量必须在编译期时才能产生，用得最多的就是string.intern()方法

    即在类加载时，**静态常量池的内容会存入到运行时常量池中**

- 字符串常量池（转移到堆中）

作用：

避免频繁的创建和销毁对象而影响性能，对象信息共享

1. 节省内存空间，相同的常量都会被合并（字符串常量）

2. 比如字符串使用==比equals更快的原因，对于两个引用常量，直接判断内存地址相等，也相当于判断实际值是否相等

## **`1.6 直接内存`**

`直接内存`：direct buffer，又称为`c heap内存`、`native堆`，它并不属于VM运行时数据区的内存区域，也不是虚拟机规范中定义的内存区域，是**在堆外的一份内存区域**

交互：进程的I/O操作中内核空间与用户空间的数据交互，都**必须经过这块内存区域**，即采用`c heap通过系统调用与kernel进行交互`

分配：一般通过native函数库（malloc()）在这里进行分配

> 当分配的内存块足够大时，会**使用mmap()将用户区域与kernel读缓冲区的进行物理地址映射**，这样就无需将数据在用户空间和内核空间中来回拷贝，**用户区域本质上是虚拟内存空间**

回收：直接内存区域只受`Full GC`的影响，一般也不会轻易触发垃圾回收（即使直接内存已满）

> 1. 为什么不是VM heap与kernel缓冲区进行交互？而要使用direct buffer？

- 底层通过write、read、sendfile等系统调用时，需要传入用户空间的buffer的起始地址和buffer count作为参数，并且**要求这些地址参数在传输过程中不能有变化**

    所以，如果使用heap堆内存中的buffer将会**频繁收到YGC的影响**，因为除了CMS算法外的其他GC算法都会进行**compact操作移动存活对象以整理内存碎片**，而使用c heap相对来说地址稳定

- 系统调用要求buffer空间应是`连续的`，但JVM规范没有要求堆内存中的byte[]必须是连续的内存空间，而c heap中我们通过mmap分配的`虚拟地址空间`是**可以连续的**

> 2. 那为什么不通过`pin住GC`的方式来使用堆内存？

`pin（钉）住GC`：指的是对`单个对象`/`多个对象`层面的object pinning，这种机制可以暂时禁用对这些对象的GC

由于hotspot处于某些决定而**没有实现单个对象的pin**，只能通过pin住整个GC来阻止GC，所以使用这种方式的话会**极大影响GC的效率**，使用起来也极其不顺手

tip：HotSpot VM对JNI的Critical系API就是通过pin住整个GC的方式实现的

> 3. Java堆中数据是如何与kernel缓冲区进行交互的？

- **在没有mmap()技术之前：**

    > 第一个拷贝的原因具体见上述问题，使用**类似memcpy()的实现进行拷贝，整个拷贝过程中暂时不允许发送GC**

    1. 将堆中byte[]数据的内容拷贝到direct buffer中，数据从：用户进程堆内 -> 用户进程堆外

    2. 将direct buffer的内容拷贝到kernel buffer中，数据从：用户进程堆外 -> kernel读缓冲区

- **使用mmap()技术：**

    将堆中byte[]数据的内容拷贝到direct buffer中即可（用户进程堆内 -> kernel读缓冲区，因为堆外已经与kernel通过mmap()进行物理映射）

- **使用mmap() + direct buffer**

    直接在进程中使用`DirectByteBuffer对象`，该对象处于堆中，实质是对直接内存某个内存区域的引用

    好处：对数据的操作相当于直接操作direct buffer，又因为有mmap()映射，**相当于直接操作kernel内核**，**去除了两次拷贝**

### **JDK.NIO**

基于以上的特性，JDK在NIO引入了基于通道（Channel）与缓冲区（Buffer）的I/O方式，对上述思想进行实现：通过使用Native函数库直接分配堆外内存，返回一个存储在Java堆里面的`DirectByteBuffer对象`作为这块内存的引用进行操作

用户使用DirectByteBuffer对象进行写入时，相当于直接操作有mmap()映射的direct buffer，相当于直接到达了kernel层

好处：避免了一次无意义的**Java堆和Native堆**数据拷贝，和一次**用户空间和内核空间**的必要内存拷贝，共计`两次`拷贝

风险：若忽略掉直接内存大小的限制，可能会导致各内存区域总和大于物理内存限制，导致OOM

# **2. 对象**

## **2.1 对象的创建**

### 2.1.1 静态常量池（运行时常量池）

遇到一个new指令时，会先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查该符号引用是否已经加载、解析和初始化过。如果没有，则进行类加载

类的大小在加载后就已经确认

### 2.1.2 堆分配

分配方式根据堆的内存分布情况：

- **绝对规整**，即指针左边是已使用，右边为未使用区域，则直接分配内存并将指针右移一个size的距离，称为**指针碰撞**
- **分散交错**，已使用和未使用的内存交错，则需要虚拟机维护一个列表，记录可用内存块，并根据内存块剩余大小与对象的大小对比，进行分配，称为**空闲列表**

而堆的内存分布情况，也根据垃圾收集器的收集策略有不同的情况，若使用CMS这种基于清除算法的收集器时，则理论上只能使用**较为复杂的空闲列表**进行分配内存；若使用带有空间压缩整理能力过程的收集器时，则**简单可以使用指针碰撞**

### 2.1.3 TLAB和CAS解决分配竞争问题

虚拟机使用CAS配上失败重试的方式保证操作原子性，使用TLAB线程私有堆，各个线程可以只在私有堆上分配，减少竞争

若TLAB缓冲区已经用完了，分配新的缓存区时才需要同步锁定

### 2.1.4 分配零值

内存分配后，将内存空间都初始化零值，若是使用TLAB则提前到分配时进行

### 2.1.5 对象设置

对象属于哪个类的实例，对象的HashCode（延后到真正调用到Object::hashCode方法时再计算），对象的GC分代年龄信息，类的元数据，**存放到对象的对象头中**

根据虚拟机的运行状态，如是否使用偏向锁时等，对象头会有不同的设置方式

执行对象设置后，才真正得执行类文件的init指令，即程序层面上的对象初始化

### **2.2 对象内存布局**

![对象结构布局](https://img-blog.csdnimg.cn/20190115141050902.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1NDRE5fQ1A=,size_16,color_FFFFFF,t_70)

对象在堆内存中的存储布局可以划分为三个部分：**对象头/实例数据/对齐填充**

### **2.2.1 对象头**

对象头包含两类信息：
- Mark Word（HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等）
- 类型指针
- 数组长度

### **Mark Word**

**在 64 位系统下用 8 字节表示；32 位系统为 4 字节**

![标记字64位比特位图](https://img-blog.csdnimg.cn/20190111092408622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdWR1bl9jb29s,size_16,color_FFFFFF,t_70)

有着动态定义的数据结构，根据对象的状态复用自己的存储空间

根据lock标志位值的不同，Mark Word表示的含义也不同

![](https://img-blog.csdnimg.cn/20190115142040348.png)

- lock

    该值代表着对象不同的状态

- biased_lock

    正常与偏向锁的不同在于biased_lock值，值为0时为正常，1时为偏向锁

- age

    4位java对象年龄（最高值=15，这也是-XX:MaxTenuringThreshold选项最大值位15的原因），在GC中，如果对象在Survivor区复制一次，则年龄+1，当对象到达设定的阈值时，将会晋升到老年代

- identity hashcode

    哈希值，31位，采用延迟加载技术，调用方法System.identifyHashCode()进行计算，并将结果写到对象头中
    
    当对象加锁后，Mark Word将不再记载哈希码，**该值将转移到管程Monitor中**

- thread id

    偏向喜爱线程的id

- epoch

    偏向锁的时间戳

- ptr_to_lock_record

    指向轻量级锁记录的指针

- ptr_to_heavyweight_monitor

    指向重量级锁（碰撞）锁记录的指针，指向监视器Monitor
    
### **类型指针**

对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例

    JVM通过这个指针确定对象是哪个类的实例。该指针的位长度为JVM的一个字大小，即32位的JVM为32位，64位的JVM为64位

    如果应用的对象过多，使用64位的指针将浪费大量内存，统计而言，64位的JVM将会比32位的JVM多耗费50%的内存。为了节约内存可以使用选项+UseCompressedOops开启指针压缩，其中，oop即ordinary object pointer普通对象指针。开启该选项后，下列指针将压缩至32位：
    1. 每个Class的属性指针（即静态变量）
    
    2. 每个对象的属性指针（即对象变量）
    
    3. 普通对象数组的每个元素指针
    
    当然，也不是所有的指针都会压缩，一些特殊类型的指针JVM不会优化，比如指向PermGen的Class对象指针(JDK8中指向元空间的Class对象指针)、本地变量、堆栈元素、入参、返回值和NULL指针等

若 JVM 开启 Klass 指针压缩选项（ -XX:+UseCompressedClassPointers，JVM 默认开启此选项 ），**则用 4 字节表示**；若不开启指针压缩（ -XX:-UseCompressedOops ）**则用 8 字节表示**;

### **数组长度**
如果对象是个数组，则会有该可选空间记录数组的长度， **4 字节的内容**用于表示存储数组的长度信息

因为VM可以通过对象的元数据信息确定对象的大小，但是如果数组的长度是不确定的，将无法通过元数据中的信息推断出数组的大小？


### **2.2.2 实例数据**

对象真正存储的有效信息，存储顺序会受到虚拟机的分配策略参数和字段在Java源码定义顺序的影响

HotSpot默认的分配顺序为：long/doubles，ints，short，byte/boolean，oops（相同宽度的字段总是被分配到一起存放）

不同的策略会使得字段的排列顺序不同

![Java类型长度基础](http://5b0988e595225.cdn.sohucs.com/images/20190409/31aef87e152549198bbec9e5ab9faea0.png)

### **2.2.3 对齐填充**

VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍（任何对象的大小都必须是8的整数倍）

对象头已经设计为8的倍数，如果实例数据没有满足的话，则通过对齐填充满足

## **2.3 对象的访问定位**

通过栈上的Reference数据来操作堆上的具体对象，vm实现了通过引用访问堆对象的方法：
- 句柄

    **划分出一块内存来作为句柄池**，reference对象存储的就是对象的句柄地址，句柄中又包含了对象实例数据与类型数据**各自具体的地址信息**

    类型数据（方法区的运行时常量池，存放着类的符号引用）

    实例数据（堆中的实例池）

- 直接指针（HotSpot的**主要**对象访问方式）

    必须考虑如何存放实例数据（相当于少了一次间接访问的开销），使用直接指针的话，reference存放的就是对象的内存地址

句柄的优点：修改对象时，只需要修改句柄的地址值，无需修改reference

直接指针优点：节省了一次句柄指针定位真实对象的开销，对于频繁访问对象的Java而言有优势

## **2.4 OOM**

### **2.4.1 计数器**
计数器不会OOM，是Java虚拟机规范中唯一没有规定OOM的内存区域

### **2.4.2 虚拟机栈**

    -Xoss：设置本地方法栈大小（无卵用）
    -Xss：设置虚拟机栈大小

1）如果线程请求的栈深度大于虚拟机允许的深度，将抛出StackOverFlow异常
2）如果虚拟机栈内存允许动态扩展，当扩展栈容量申请内存失败时，则抛出OOM

HotSpot，一般栈不支持动态扩展，所以在能申请到内存空间后，不会出现OOM问题。如果是通过不断建立线程导致的OOM，也与虚拟机栈空间是否足够没有直接联系（甚至每个线程的栈容量更大，更容易出现本机内存不够的问题）

**思路：在不能减少线程数和增加内存的情况下，可以通过减少最大堆容量和减少栈容量来换取更多的线程**

**无论是虚拟机栈太小，或是栈帧过大（局部变量表巨大），出现新的栈帧内存无法分配时，抛出的都是StackOverFlow**，即请求栈深度大于虚拟机允许的深度（深度由虚拟机栈大小决定），常见：递归次数过多，无限调用循环

> stackoverflow问题也证明了hotspot的虚拟机栈无法动态扩展

### **2.4.3 堆**

堆用于存储对象实例，只要不断创建对象，并保证**GC Roots到对象之间有可达路径**来避免垃圾回收机制清除这些对象，那么会出现堆OOM

    -Xms：堆的最小值
    -Xmx：堆的最大值
    设置成一样大的话，可以避免堆自动扩展
    -XX:+HeapDumpOnOutOfMemoryError: 可以在出现内存溢出异常时Dump出当前的内存堆转储快照

分析到底是出现了**内存泄漏**还是**内存溢出**

内存泄漏：根据泄漏对象的类型信息以及它到GC Roots引用链的信息，可以定位到这些对象创建的位置

内存溢出：检查Xmx和Xms参数是否有调整必要，再从代码上检查是否某些对象**生命周期过长，持有状态时间过长，存储结构不合理**

### **2.4.4 方法区和运行时常量池溢出**

JDK8去除永久代实现，改用元空间

字符串常量池被转移到了堆中，若堆内存不够，会出现堆OOM

```java
/**
* "java"字符串是在sun.misc.Version类加载的时候进入字符串常量池的
* 在jdk7之前会得到两个false
*  因为intern会将出现的字符串记录到永久代的字符串常量池中，那引用肯定与StringBuilder创建在堆中的字符串引用不同了
*
* 在jdk8之后会得到一个true和一个false
*  因为字符串常量池已经转移到堆中了：
*  相比jdk7，会直接先在常量池查找是否有该实例引用，若无则将堆中该对象实例记录到字符串常量池中，并返回该实例引用（jdk7是一定返回一个方法区（永久代内存区域）的引用，与堆无关）
*/
public class Intern {
    public static void main(String[] args) {
        String str1 = new StringBuilder().append("虚拟").append("机").toString();
        System.out.println(str1.intern() == str1);

        String str2 = new StringBuilder().append("ja").append("va").toString();
        // str2是新对象，不是字面量，在堆中会新生成一个对象
        // "java"字符串在之前就出现过一次，并保存到常量池中，str2新对象引用肯定与它不相同了
        System.out.println(str2.intern() == str2);
    }
}
```

方法区的其他区域职责还有：存放类型的相关信息，如类名/类访问修饰符/常量池/字段描述/方法描述

一个类要被垃圾收集器回收，要达到的条件是比较苛刻的