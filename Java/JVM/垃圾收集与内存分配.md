### **垃圾收集与内存分配**

- 哪些内存需要回收？
- 什么时候回收？
- 怎么回收？

虚拟机栈/计数器/本地方法栈，生命周期与线程重合，这几个区域的内存**分配**（在类结构确定下来，即编译期，便已知栈帧大小）和**回收**（线程死亡）都具备确定性

堆和方法区具有动态性质，无法确定大小，一个接口的多个实现类所需要的内存大小可能不同，执行的方法需要的内存也不一样

#### **1. 对象”死亡“**

指的是对象不可能再被任何途径使用（GC Roots无法到达）

#### **1.1 引用计数法**

在对象中占用额外的内存空间，添加一个引用计数器，每当一个地方引用它，则计数器+1；当引用失效时，计数器-1；

**任何时刻计数器为零的对象就是不可能再被使用的**

- 优点：

    判定效率极高，原理简单

- 问题：

    需要额外考虑很多例外情况，配合大量的额外处理，很难解决**对象之间的相互引用问题**

#### **1.2 可达性分析（重点）**

#### **1.2.1 可达性分析原理**

通过一系列称为GC Roots的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”

如果某个对象到GC Roots间没有任何引用链相连，或者用图论而言，**GcRoots到这个节点不可达时**，则证明该对象不可能再被使用

    tracing GC的本质是通过找出所有活对象来把其余空间认定为“无用”，而不是找出所有死掉的对象并回收它们占用的空间

#### **GC Roots**

GC Roots，或者说tracing GC的根节点，就是**一组必须活跃的引用**（必须要能完整枚举出所有GC Roots，否则就可能漏扫描活跃的对象，导致活跃对象错误回收）

固定可作为GC Roots的对象包括以下几种：
- 在**虚拟机栈（多个局部变量表）引用的对象**，譬如各个线程被调用的方法堆栈中使用到的参数，局部变量，临时变量等

    **所有Java线程活跃栈帧里指向GC堆里的对象的引用，即当前所有正在被调用的方法的引用类型的参数/局部变量/临时值**

- 在**方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量**
- 在**方法区中常量引用的对象，譬如字符串常量池的引用**
- 在本地方法栈中JNI（Native方法）引用的对象
- Java虚拟机内部的引用，如基本数据类型对于的Class对象，一些常驻的异常对象，**系统类加载器**
- **所有被同步锁持有的对象**
- 反映Java虚拟机内部情况的JMXBean/JVMTI中注册的回调、本地代码缓存等

除了这些固定的GC Roots集合以外，根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还可以有其他对象临时性地加入，共同构成完整的GC Roots集合：

    基于分代式GC的部分收集做法，在执行部分收集时，从GC堆非收集部分指向收集部分的引用（即非收集部分对象有收集部分对象的引用），则该引用也必须作为GC Roots的一部分

**不同代的所使用的GC Roots是不同的，年轻代和年老代的GC Roots都从一个基础的GC Roots里演化而来，如年轻代的GC Roots就是基础GC Roots里指向年轻代的那部分引用（子集）加上跨代引用**

#### **1.2.2 分析回收**

即使**在可达性分析中被判定为不可达对象，也不会立即回收**，要真正宣告一个对象的死亡并回收，至少要经历两次标记过程：

1）**进行可达性分析后，发现没有GC Roots与之相连，会被第一次标记**，标记后执行一次筛选

2）在F-Queue中第二次小规模标记，由vm自动建立的Finalizer去执行队列中对象的finalize()方法

在第一次标记过程后，会立即进行一次筛选，假如对象**没有覆盖finalize()方法**，或者**finalize()方法已经被虚拟机调用**过，那么vm会将这两种情况都视为没有必要执行finalize

在上述筛选后，如果认定**有必要执行finalize()方法**，则对象会被放置于**F-Queue队列**中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer去**异步**（同步如果失败，则阻塞住产生巨大的危险）执行finalize()方法

如果对象在第一次标记后的筛选，认为没有必要执行finalize方法，则直接回收；有必要执行则加入到F-Queue队列中

在F-Queue，对对象进行第二次标记，**如果被重新引用到引用链上，那么就被移除“即将回收”集合，对象存活；反之，将被回收**

**=》证明：finalize()方法只会被vm自动执行一次**

    可达性分析，无GC Roots可达 -》 第一次标记

    第一次标记 =》筛选，有必要执行 =》进入F-Queue中等待VMFinalizer
                     没必要执行 =》直接回收

    第二次标记 =》调用finalize()方法 =》重新引用赋值，进入GC Roots引用链，复活
                                  =》死亡

    因为finalize()方法只会被vm自动执行一次
    复活 =》 不可达分析又满足 =》第一次标记 =》必定没必要执行 =》直接回收


#### **1.3 引用**

- 强引用 Strongly Reference

    最传统的“引用”定义，包括：**引用赋值**，只要强引用关系仍存在，则不会被回收

- 软引用 Soft Reference

    还有用，但非必须的对象。被软引用关联着的对象，**在系统将要发生内存溢出前，会将这些对象列入回收范围内进行第二次回收**，如果回收后还没有足够的内存，才会抛出OOM

- 弱引用 Weak Reference

    非必须对象，**只能生存到下一次垃圾收集**发生为止（无论内存是否足够）

- 虚引用 Phantom Reference

    “虚灵引用”/“幻影引用”，该引用的唯一目的只是为了能在这个对象被回收时收到一个系统通知

**以上引用强度依次逐渐减弱**

#### GC对象移动, 如何修改指针（引用地址更改）

Questions.md, Q1

指针：forwardig

#### **1.4 回收方法区**

方法区的垃圾收集性价比很低，在新生代中常规收集就能够回收70%和99%的内存空间，方法区**远远不足**

主要回收两个部分：
- 废弃常量

    以字符串为例，在方法区中常量池上，有一个字符串“java”， 但当前系统上没有字符串对象的引用常量池上的“java”，且vm上也没有其他地方引用这个常量，则会被清除出常量池

- 不再使用的类型

    - 该类的所有实例已被回收
    - 加载该类的类加载器已经被回收
    - 该类对于的java.class.Class对象没有在任何地方被引用

满足上述条件，则VM被允许回收，而不是像GC堆一样，没有了引用就必然会回收

关于是否要对类型进行回收，提供了-Xniclassgc等参数进行控制

#### **2. 垃圾收集算法**

重点介绍**分代收集理论**和几种算法思想及其发展过程

Java的垃圾收集算法，是基于追踪式垃圾收集，来判定对象消亡。而通过分代收集，在不同类型的GC收集器上，本质上是：

1. 缩短**同步GC**的每次GC的时间（假设每次都是Full-Gc，耗时将过长，应用将处于长时间的不可用）

2. 提高**并发安全的GC**的内存分配率，**尽快回收出越多空间**，应用内存分配速率（allocation rate）可以得到巨大的提升（并发安全GC不存在同步GC的停止问题）

        同步GC为什么要stop the world：
        防止标记出现并发问题，不会出现一边分析，根节点的对象引用关系还在不断的变化的情况，也不会出现清除过程中的并发问题

        假设我们刚标记完图中最右边的那个对象，暂且记为A，结果此时在程序当中又new了一个新对象B，且A对象可以到达B对象。但是由于此时A对象已经标记结束，B对象此时的标记位依然是0，因为它错过了标记阶段。因此当接下来轮到清除阶段的时候，新对象B将会被苦逼的清除掉。如此一来，不难想象结果，GC线程将会导致程序无法正常工作。

         上面的结果当然令人无法接受，我们刚new了一个对象，结果经过一次GC，忽然变成null了，这还怎么玩？

        异步GC会STW吗？

        CMS在标记过程中也是Stop the world

        并发GC为什么也使用分代理论：
        
        应用一边在分配，GC一边在收集，如果GC收集的速度能跟得上应用分配的速度，那就一切都很完美；一旦GC开始跟不上了，垃圾就会渐渐堆积起来，最终到可用空间彻底耗尽的时候，应用的分配请求就只能暂时等一等了，等GC追赶上来
        
        所以，对于一个并发GC来说，这也更需要使用分代收集，尽快回收出越多空间，就能够应付越高的应用内存分配速率，从而更好地保持GC以完美的并发模式工作
        
从如何**判定对象消亡的角度**，垃圾收集算法可划分为：

- 引用技术式垃圾收集

    Reference Counting GC，**直接垃圾收集**

- 追踪式垃圾收集（HotSpot Jvm）

    Tracing GC，也是上述的GC Roots根节点向下引用链搜索

    Tracing GC的本质是通过找出所有活对象来把其余空间认定为“无用”，而不是找出所有死掉的对象并回收它们占用的空间，也称为**间接对象收集**

#### **2.1 分代收集理论**

    两个分代的三大基本假设：
    1）弱分代假说 (weak generational hypothesis)：大部分对象的生命期很短，而没有die young的对象则很可能会存活很长时间（朝生夕灭）

    2）强分代假说 (strong generational hypothesis)：熬过越多次垃圾收集过程的对象就越难以消亡

    3）跨代引用假说 (intergenerational reference hypothesis)：跨代引用相对于同代引用来说仅占极少数

虚拟机给每个对象定义了一个对象年龄计数器
- 如果对象在Eden出生经过第一次MinorGC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1
- 对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当他的年龄增加到一定程度（默认15）时，就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过设置参数-XX:MaxTenuringThreshold
- 动态年龄判定下，不一定要达到15才能进入老年代，只要在Survivor中相同年龄的对象超过一半的话，那么年龄大于这一半对象年龄的，都会直接进入老年代


F大：

基于以上的假设，频繁收集young gen，则大部分垃圾都能在新生代中被收集掉，由于**young gen的大小配置通常只占整个GC堆的很小部分**，而且较高死亡率，这也让它很**适合使用copying算法进行收集**，这样不但降低单次GC的时间长度，还可以提高GC的工作效率

周志明：

收集器应该将GC堆划分出不同的区域，将回收对象依据其年龄（熬过垃圾收集过程的次数，也就是上述的GC计数器值）分配到不同的区域之中存储

    第一假说理解（young gen来由）：

    因为大部分新创建的对象都是朝生夕灭的，意味着如果只对新创建的对象进行回收的话，回收率高，能回收到大量的空间
    
    每次新生代GC时，可以只关注：
    如何保留少量的存活对象（Survior，再逐步晋升到老年代），而不是去标记哪些大量将要被回收的对象（因为这些对象被标记后，大概率都会被回收）

    第二代假说理解（old gen来由）：

    剩下的就是难以消亡的对象，把它们集中在一块，vm就能以较低的频率回收这个区域

这样就同时兼顾了垃圾收集的时间开销和内存空间的有效利用

在GC堆的不同分代下，GC可以每次**只回收某一个或某些部分的区域**，即部分收集：
- Partial GC
    - Minor GC/Young GC：目标只是新生代的垃圾收集
    - Major GC/Old GC：目标只是老年代的收集（CMS收集器）
    - Mixed GC: 收集整个新生代以及部分老年代（G1收集器）
- Full GC

针对以上不同的区域，来**安排与之存储对象消亡特征匹配的**，具有针对性的垃圾收集算法：
- 标记-复制算法
- 标记-清除算法
- 标记-整理算法

#### 问题：对象并不少孤立的，对象之间存在跨代引用

    第三假说的理解：

    存在互相引用关系的对象，是应该倾向于同时生成或同时消亡的

    新生代对象刚分配，对应引用的对象可能也是同期一起生成的，它们将会一直处于同个分代中

    新生代对象刚分配，就跨代引用，由于引用的老年代对象难以消亡，该引用会使得新生代对象在收集时难以消亡，新生代对象进而也很容易晋升到老年代中

基于上述问题，GC没有必要去扫描整个老年代，也不必专门去记录每个对象是否存在以及存在哪些跨代引用，只要在新生代上建立一个全局数据结构（**记忆集**），并采用**剪枝**的方式进行遍历

**有了GC Roots为什么还需要跨代引用？**

年轻代的GC Roots就是**基础GC Roots指向年轻代的那部分引用（一个子集）和跨代引用**，换言之基础GC Roots包含了整个堆

    剪枝有效的原理就是跨代引用其实很少，如果遍历所有指向Old的root，大部分情况其实是：GC Roots -> Old ->Old->Old->Old，因此指向Old就不继续遍历了

#### 记忆集

该结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用

在对象改变引用关系/赋值引用时，会修改记忆集的数据（增加一些运行时的开销）

此后的Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描

**疑问：如果存在的跨代引用的分配足够分散，包括了整个老年代的空间，是否就相当于扫描整个老年代？**

#### **2.2 标记清除算法（mark-and-sweep）**

**专注延迟（单次GC的STW时间最短，但因内存碎片会提升GC的频率）**

过程：
- 标记

    标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象；反之，标记活的对象，统一回收所有未被标记的对象也是可以的

    标记过程就是**对象是否属于垃圾的判定**过程

- 清除

内存将被耗尽时，GC线程会被触发，stop the world，再根据**GC Roots标记出所有存活的对象**，并清除掉没有标记到的对象

清除并**没有立即置空**，而是将垃圾对象地址保存在空闲的地址列表里，下次有新对象需要加载时，先判断垃圾对应的内存位置是否足够存放，如果够则存放

问题：

1. 效率不稳定，如果堆中包含大量对象，其中大部分是需要回收的，那将进行大量标记（量够大的情况下，GC Roots可能也会比较多，标记过程遍历会更耗时）和清除（对堆进行遍历，没有标记的对象清除）的动作

2. 内存碎片化问题，产生大量不连续的内存碎片，碎片太多会导致在接下来分配大内存对象时，再次触发垃圾收集行为（单次GC时间较短，但单位时间内GC次数增加）

3. 与写时复制不兼容：
- fork子进程，在执行exec()或数据有变动前：子进程代码段和数据段等都是对父进程的一个**引用**，即父进程与子进程都有虚拟空间，但是物理空间是同一个
- 标记过程相当于修改了对象的对象头标志位，触发了数据变动，会导致子进程的数据段进行内存复制，造成无必要的复制

#### **2.3 复制算法（年轻代的copying算法）**

特别注意：

**没有标记过程，一次遍历，直接搞定，这也是他效率高的原因**

**Parallel Scavenge深度优先，ParNew广度优先**

1. “半区复制”

    每次只使用其中的一块，在内存用完时，将使用中的内存块的存活对象**按顺序复制**到另一块内存中，并将之前使用的内存块直接清除即可

    执行效率大大提升：因为回收的时是以内存块回收的，不需要再去一个个遍历未标记的对象

2. Appel式回收

    朝生夕灭的更量化诠释：新生代中98%的对象熬不过第一轮收集，因此可以按照：一块较大的Eden空间和两个较小的Survivor空间来进行分配（8:1:1）

    每次分配内存时，只使用Eden和其中的一块Survivor空间，然后直接清除掉Eden和使用过的那块Survivor空间

    “逃生门设计”：当Survivor空间不足以容纳一次Minor GC后存活的对象，则依赖其他内存区域（老年代）进行分配担保

    **疑问：为什么是8:1:1**

    因为**98%**的对象熬不过第一轮收集，为了保险默认实际使用了90%（8 + 1）

优点：内存空间连续，清除效率大大提升

缺点：浪费了一部分内存空间；在存活率高的地方，将产出大量的内存复制开销，所以是适合新生代的一种收集算法

    执行流程：

    在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的
    
    紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向
    
    年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”
    
    不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。

#### 问题：为什么young GC多使用copying算法 《=》为什么young代的比例为1/3 《=》 为什么有Eden，From Survivor，To Survivor，比例为8:1:1？

Questions.md: Q2

#### **2.4 标记-整理(Mark-Compact)算法**

**关注吞吐量（单位时间STW时间最短）**

标记过程与标记-清除算法一致

让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存

与标记-清除算法本质差异在于，整理算法是一种移动式算法，后者是一种非移动式的回收算法

    吞吐量：赋值器与收集器的效率之和
    吞吐量 = 程序运行时间 / （程序运行时间 + GC运行时间）

内存分配是程序最为频繁的操作，若内存碎片情况严重，则会导致内存分配效率低下，这一部分增加的耗时，相比执行频率较低的收集器对对象进行移动要高的多。即虽然单次GC运行时间变长（延迟增加），但程序运行时间能变长，即单位时间内STW的时间变短


# 参考：
- [深入理解JVM虚拟机-第三章]()
- [gc为什么要分代](https://www.zhihu.com/question/53613423/answer/135743258)
- [如何区分老年代和年轻代的GC Roots](https://zhihu.com/question/389362829/answer/1173010848)
- [JVM内存管理算法精解（标记-清除)](https://www.cnblogs.com/zuoxiaolong/p/jvm4.html)
- [JVM GC完成对象地址移动后，如何修正指针？](https://www.zhihu.com/question/57732697?sort=created)
- [copy GC 和 mark & compaction GC的算法异同](https://www.cnblogs.com/chuliang/p/8689418.html)