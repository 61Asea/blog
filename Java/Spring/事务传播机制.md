# Spring：事务传播机制

Spring事务拦截器源码里，可以发现在事务获取操作时，会判断当前线程是否存在事务：

```java
// AbstractPlatformTransactionManager.class
@Override
public final TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException {
    // 获取事务
    Object transaction = doGetTransaction();

    boolean debugEnabled = logger.isDebugEnabled();
    if (definition == null) {
        definition = new DefaultTransactionDefinition();
    }

    // 判断当前线程是否有存在事务
    if (isExistingTransaction(transaction)) {
        // 存在事务，则根据当前的事务传播机制进行处理
        return handleExistingTransaction(definition, transaction, debugEnabled);
    }

    // 当前线程没有事务
    if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) {
        // 需要抛错的事务传播机制，特指MANDATORY
    } else if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED || definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW || definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {
        // 需要新创建事务的传播机制
    }
    // ...
}
```

具体的判断，由ConnectionHolder中的`transactionActive`字段决定，当有方法对当前线程连接创建事务时，都会设置该标识符为true，以此**代表当前线程已存在事务**：

```java
// DataSourceTransactionManager.class
@Override
protected boolean isExistingTransaction(Object transaction) {
    DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;
    // 返回holder的transactionActive字段
    return (txObject.hasConnectionHolder() && txObject.getConnectionHolder().isTransactionActive());
}

// holder关于transactionActive字段的写，该方法后续详细讲
@Override
protected void doBegin(Object transaction, TransactionDefinition denifition) {
    DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;
    Connection con = null;
    try {
        // ...

        // 一开始创建的ConnectionHolder，关于该字段都是false
        txObject.getConnectionHolder().setTransactionActive(true);
    }
}
```

上述是否有事务的判断的产生，是因为后续需要根据**不同事务传播级别**对`事务方法`之间进行操作

事务传播：多个事务方法**互相调用**时，决定事务如何在这些方法间传播

> 假设方法A是一个事务的方法，方法A执行过程中调用了方法B，那么方法B有无事务、B对事务的要求，都会对方法A的事务执行形成影响；同理方法B的事务也会收到A的影响，而这两个方法所定义的事务传播类型决定了这种影响具体是什么

共有**7种**传播类型，含义分别如下：

| 传播类型 | 含义 |
| ---- | ---- |
| **REQUIRED** | 如果当前存在事务，则加入到当前事务；否则，新建一个事务 |
| **REQUIRES_NEW** | 如果当前存在事务，则前事务会被挂起，**并且一定创建一个新事务** |
| **NESTED** | 如果当前存在事务，则创建一个当前事务的子事务（嵌套事务）；否则，新建一个事务 |
| MANDATORY | 如果当前存在事务，则加入；否则，抛出异常 |
| SUPPORTS | 如果当前存在事务，则加入；否则，则以**非事务**方式执行 |
| NOT_SUPPORTED | 如果当前存在事务，则挂起当前事务，并且一定以**非事务**方式执行 |
| NEVER | 以非事务的方式执行，如果当前存在事务，则抛错 |

> 以下例子统一以testMain()作为程序入口

# **REQUIRED**

> PROPAGATION_REQUIRED类型是Spring的默认事务传播类型

定义：如果当前存在事务，则加入；否则，新建一个事务

- 正常情况

    ```java
    @Transactional(propagation = Propagation.REQUIRED)
    public void testMain() {
        // 1. 当前没有事务，新建一个事务
        A("a1");
        testB();
    }

    @Transactional(propagation = Propagation.REQUIRED)
    public void testB() {
        // 2. 当前线程存在事务，加入该事务
        B("b1");
        // 3. 出现问题，回滚当前线程事务
        throw Exception;
        B("b2");
    }
    ```

    结果：a1，b1，b2都没有插入到数据库中

- 主入口没有事务

    ```java
    public void testMain() {
        // 1. 与事务无关，直接插入a1到数据库
        A("a1");
        testB();
    }

    @Transactional(propagation = Propagation.REQUIRED)
    public void testB() {
        // 2. 当前线程不存在事务，新建事务
        B("b1");
        // 3. 出现问题，回滚当前线程事务
        throw Exception;
        B("b2");
    }
    ```

    结果：a1插入到数据库，b1、b2没有插入

- 被调用函数B没有事务

    ```java
    @Transactional(propagation = Propagation.REQUIRED)
    public void testMain() {
        // 1. 新创建事务
        A("a1");
        testB();
    }

    public void testB() {
        // 2. 属于testMain的事务方法范畴，不会立即插入数据库
        B("b1");
        // 3. 出现问题，回滚当前线程事务
        throw Exception;
        B("b2");
    }
    ```

    结果：a1、b1、b2都没有插入到数据库


# **REQUIRES_NEW**

定义：当前线程存在事务，则挂起该事务，并且一定会新创建一个事务

两个相互调用的事务方法是**独立的**，REQUIRES_NEW会启动一个新的、不依赖于环境的内部事务，这个事务将完全被commited或rolled back，而不依赖于外部事务

- 被调用方设置为REQUIRES_NEW并出错，入口方吞并异常正常运行

    ```java
    @Transactional(propagation = Propagation.REQUIRED)
    public void testMain() {
        // 1. 线程不存在事务，新创建一个
        A("a1");
        try {
            // 4. 错误往上抛，但是在代码层面上吞掉异常
            testB();
        } catch (Exception ex) {
            // do nothing...
        }
    }

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void testB() {
        // 2. 当前线程存在事务，挂起前一个事务，并为testB事务方法创建一个新事务
        B("b1");
        // 3. 出现问题，回滚新的事务
        throw Exception;
        B("b2");
    }
    ```

    结果：a1插入数据库，b1、b2没有插入数据库

- 被调用方设置REQUIRES_NEW，入口方出错

    ```java
    @Transactional(propagation = Propagation.REQUIRES)
    public void testMain() {
        // 1. 线程不存在事务，新创建一个
        A("a1");
        // 3. testB的事务执行成功并提交，数据库插入了b1和b2
        testB();
        // 4. testMain问题，回滚testMain的事务
        throw Exception;
    }

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void testB() {
        // 2. 当前线程存在事务，挂起前一个事务，并为testB事务方法创建一个新事务
        B("b1");
        B("b2");
    }
    ```

    结果：b1、b2插入数据库，a1插入失败

这两个方法并非同一个事务，这是以上结果的成因，所以可以看到testB的事务独立于testMain，但假如它们在代码里确实就有一致性需求，这可能就会导致问题

# **NESTED**

定义：当前线程存在事务，则创建一个该事务的嵌套子事务；否则，则新创建一个事务

NESTED往往拿来与REQUIRES_NEW做对比，后者是已存在事务的子事务，它是外部事务的一部分，只有外部事务结束后它才会提交

嵌套事务最有价值的地方，就在于它可以通过`save-point`回滚到某一个快照点，所以不会产生脏数据（相当于方法从未被执行过），起到`分支执行`的效果

- 被调用方设置为NESTED，入口方出错（与REQUIRES_NEW做横向对比）

    ```java
        @Transactional(propagation = Propagation.REQUIRED)
        public void testMain() {
            // 1. 线程不存在事务，新创建一个
            A("a1");
            // 3. testB事务执行成功，但仍未提交
            testB();
            // 4. testMain出现问题，回滚testMain的事务，包括其嵌套子事务
            throw Exception;
        }

        @Transactional(propagation = Propagation.NESTED)
        public void testB() {
            // 2. 当前线程存在事务，并为testB事务方法创建一个testMain事务的嵌套子事务
            B("b1");
            B("b2");
        }
    ```

    结果：a1、b1、b2都不会被插入到数据库中

    > 如果是REQUIRES_NEW类型，则b1、b2会插入到数据库中，在大部分场景下这都不是合理情况

- 被调用方设置为REQUIRES_NEW并出错，入口方吞并异常正常运行（NESTED的最大用途）

     ```java
        @Transactional(propagation = Propagation.REQUIRED)
        public void testMain() {
            // 1. 线程不存在事务，新创建一个
            A("a1");
            try {
                testB();
            } catch (Exception ex) {
                // 4. 恢复到testB创建的save-point
                testC();
            }
        }

        @Transactional(propagation = Propagation.NESTED)
        public void testB() {
            // 2. 当前线程存在事务，并为testB事务方法创建一个testMain事务的嵌套子事务，并创建一个保存点
            B("b1");
            // 3. testB出现异常，子事务回滚
            throw Exception;
            B("b2");
        }
        
        @Transactional(propagation = Propagation.NESTED)
        public void testC() {
            // 2. 当前线程存在事务，并为testB事务方法创建一个testMain事务的嵌套子事务
            C("c1");
            C("c2");
        }
    ```

    结果：a1、c1、c2都插入到数据库，b1、b2没有插入到数据库中

# **NEVER**

定义：以非事务的方式执行，假如当前线程有事务，则抛出异常

```java
@Transactional(propagation = Propagation.REQUIRED)
public void testMain() {
    // 1. 线程不存在事务，新创建一个
    A("a1");
    testB();
    // 3. testMain检测到testB()抛出异常，发生回滚
}

@Transactional(propagation = Propagation.NEVER)
public void testB() {
    // 2. 当前线程存在事务，直接抛出异常
    B("b1");
    B("b2");
}
```

结果：a1、b1、b2都不会存入到数据库中

# **MANDATORY**

定义：如果当前存在事务，则加入；否则，抛出异常

```java
@Transactional(propagation = PROpagation.NEVER)
public void testMain() {
    // 1. 以非事务的方式执行
    A("a1");
    testB();
    // testB出现异常，后续内容无法执行
}

@Transactional(propagation = Propagation.MANDATORY)
public void testB() {
    // 2. 当前线程不存在事务，直接抛出异常
    B("b1");
    B("b2");
}
```

结果：a1插入到数据库，b1、b2都没有插入到数据库中

# **SUPPORTS**

定义：如果当前存在事务，则加入；否则，以非事务的方式执行

```java
@Transactional(propagation = PROpagation.NEVER)
public void testMain() {
    // 1. 以非事务的方式执行
    A("a1");
    testB();
    // testB出现异常，后续内容无法执行
}

@Transactional(propagation = Propagation.MANDATORY)
public void testB() {
    // 2. 当前线程不存在事务，以非事务的方式执行
    B("b1");
    throw Exception;
    B("b2");
}
```

结果：a1、b1插入到数据库，b2没有插入到数据库

# **NOT_SUPPORTED**

定义：始终以非事务的方式执行，如果当前存在事务，则将当前事务挂起

```java
@Transactional()
public void testMain() {
    // 1. 当前线程没有事务，新建一个事务
    A("a1");
    testB();
    // testB出现异常，testMain方法事务回滚
}

@Transactional(propagation = Propagation.NOT_SUPPORTED)
public void testB() {
    // 2. 当前线程存在事务，挂起该事务，本事务方法以非事务方式执行
    B("b1");
    throw Exception;
    B("b2");
}
```

结果：b1插入到数据库，a1、b2都没有插入到数据库

# 重点参考
- [解惑 spring 嵌套事务](https://www.iteye.com/topic/35907)：讲解了事务传播机制what和why，并着重介绍REQUIRED_NEW和NESTED的区别
- [带你读懂Spring 事务——事务的传播机制](https://zhuanlan.zhihu.com/p/148504094)：相当易懂的七大隔离级别讲解，具备简单的代码demo