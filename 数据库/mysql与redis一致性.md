# **Redis和Mysql的双写一致性**

本质问题：缓存写和数据库写，这两个动作不是原子操作，并发操作无法保证顺序，就会涉及到**数据一致性**问题

解决思路：`Cache Aside Pattern`

> 四种相关模式：Cache aside、Read through、Write through和Write behind caching

结论：

1. 读操作，判断缓存是否存在，不存在则读取数据库中的信息并更新缓存；存在的话直接读取缓存信息进行返回

2. 写操作，先**删除缓存**，再更新db（cache aside是先写db再删cache）

    > 为什么使用删除缓存，而不是更新缓存：系统如果处于写多读少的情况下，更新缓存的方式会导致大量的数据修改，但是隔很长时间才进行一次读取，频繁的更新造成系统的吞吐下降；通过将加载数据到缓存的操作延迟到读操作（需要控制好互斥），是一种惰性思维（被动更新）的体现，可以更好地减少操作的次数开销，用到缓存时才去算缓存

# **两种不一致情况**

不管是先写db再删cache，还是先删cache再写db，都有可能出现数据不一致的情况

1. 考虑`操作失败问题`（关键看第二步操作是否失败）

    - 先写db成功，然后删除cache失败：则缓存没有被删除掉，直至用户下次写操作成功前，双边处于`不一致`状态

    - 先删cache，然后写db失败：因为缓存不存在，会去数据库重新查询，而因为db写操作是失败的，所以双边处于`一致`状态

2. 考虑`操作过程中的并发问题`

    - 先写db，在删除cache过程前并发查询：
        
        - cache一开始就不为空：读线程发现缓存不为空，直接返回；而下一次的读操作会读到不同的值，这保证了`最终一致性`

        - cache一开始就为空：读线程发现缓存为空，准备去数据库取数据，在写完db并删除缓存随后，将脏数据加载到缓存中，双边处于`不一致`状态

    - 先删除cache，在写db前并发查询：读线程发现缓存为空，去数据库中读取数据加载到缓存，此时缓存将变为脏数据，双边处于`不一致`状态

# **解决方案**

**1. 具备重试保障的延迟双删方案（推荐）**

具体步骤：
1. 先删除cache
2. 再写db
3. 线程休眠合适的间隔时间后，**再次删除cache**

![双写一致的延迟双删](https://asea-cch.life/upload/2021/08/%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E7%9A%84%E5%BB%B6%E8%BF%9F%E5%8F%8C%E5%88%A0-49352ef9b61449caad2dd91f6335803e.jpeg)

延迟双删可以解决以下两种场景导致的db和redis不一致问题：

1. 先写db后写删除失败
2. 先删cache，写db前并发查询的问题

理论思路：最差情况下，在**延迟时间内**数据存在不一致问题，随后被修正

实现思路：在写db前后都进行redis.del(key)操作，并设置合理的超时时间


**2.** 使用JVM内部队列，阻塞写db期间的读操作

> [关于《JVM内部队列》的疑惑](https://github.com/doocs/advanced-java/issues/107)：就是使用JDK的阻塞队列等方式，保证请求的串行执行，即生产-消费模式

**3.** 基于binlog同步机制的异步更新缓存方案

理论思路：依旧是解决不一致问题，并期望降低方案代码对业务的入侵性

实现思路：Mysql binlog增量订阅消费 + 消息队列 + 增量数据更新到redis，即binlog的主从复制

![双写一致binlog降低业务入侵](https://asea-cch.life/upload/2021/08/%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4binlog%E9%99%8D%E4%BD%8E%E4%B8%9A%E5%8A%A1%E5%85%A5%E4%BE%B5-49866a924ede482bab29616ddf088f63.jpeg)

# 参考
- [缓存与数据库双写一致性问题](https://blog.csdn.net/qq_33135813/article/details/91352093)

# 重点参考
- [经典面试题：如何保证缓存与数据库的双写一致性？](https://zhuanlan.zhihu.com/p/66462064)
- [Redis双写一致、穿击、穿透、雪崩、污染](https://zhuanlan.zhihu.com/p/384826352)