# Mysql（三）：锁机制

这篇文章也不仅仅是对于Mysql而言，它同样也涵盖了大部分数据库的锁机制

    合理地运用各种锁概念，并将它们形成多套方案，这些方案就是各大数据库其对应的隔离级别实现

> [Mysql（五）：隔离级别](https://asea-cch.life/achrives/Mysql隔离级别)

以下根据不同层面来对锁专业名词进行分类：

- `锁资源方式`：**两段封锁（2PL）**、基于2PL的一次封锁和顺序封锁

- `锁粒度`：表级锁、**行级锁**、页级锁

- `锁级别`：**共享锁（S）**、**排他锁（X）**

- 加锁方式：自动锁、显式锁

- 使用方式：乐观锁、悲观锁

- sql语言类型：DML（数据操作语言）锁、DDL（数据定义语言）锁

目前大部分DBS都采用`2PL`来满足并发操作的可串行化调度，并根据**锁粒度**和**封锁协议**的方式来调整数据库系统的并发性能

本文将先着重以这三个作为切入点，讲述如Mysql的大部分数据库基础锁机制，再讲述Mysql如何使用其特性（MVCC，间隙锁Next-Key Lock）来更大程度地提升DBS的**并发程度**和**数据一致性**

# **1. 锁资源方式**

在讲到2PL与三级封锁协议时，总是会因为它们都带有一个封锁而感觉迷惑，注意两者切入点并不相同，前者是强调整个过程申请/释放锁资源的流程，后者强调锁资源的细节（即对X锁和S锁的运用）

2PL还很容易与表锁/行锁的死锁问题做混淆，这个混淆点在于表锁和行锁虽都符合2PL范式，但其锁的资源量级不同，才使得两者的死锁情况不同

## **1.1 2PL**

> [2PL](https://blog.csdn.net/aigoogle/article/details/25804285?locationNum=6&fps=1)

2PL，又称两段锁或二次封锁，它强调锁资源不是一次完成的，分为**扩展**和**收缩**两个阶段，扩展阶段只能加锁不能释放锁，收缩阶段只能释放锁不能再加锁，即扩展阶段和收缩阶段不可交替执行

事务的第一个加锁操作意味着进入了扩展阶段，收缩阶段同理

<!-- 在扩展阶段，对全部需要的数据项进行加锁操作，不允许对已经加锁的数据进行解锁。收缩阶段同理，即扩展阶段和收缩阶段不可交替执行 -->

    2PL中，收缩阶段对全部锁资源的释放可以不是一次性的，释放之中可以穿插一些除了加锁以外的的操作，扩展阶段同理

    这也意味着有其他事务在本事务进入收缩阶段后，可以立即获得已释放的锁资源

![2PL](https://asea-cch.life/upload/2021/06/2PL-39de6c5605a1447394e7d0c62514f76c.jpg)

效果：对于遵循两段锁协议的事务，其交叉并发操作的执行结果一定是正确的

遗留问题：

- 死锁

    并发的事务（遵循2PL），在扩展阶段可能会**对多个锁资源的获取**，以**不恰当的顺序对相同的多个锁资源进行竞争**，就有可能发生死锁情况

- 级联中止

    其他事务在本事务进入收缩阶段后，可以立即获得本事务已释放的锁资源，当本事务最终并未提交而选择回滚时，为了保持一致性，其他事务也会因此终止回滚

    ![2PL的级联中止](https://asea-cch.life/upload/2021/06/2PL%E7%9A%84%E7%BA%A7%E8%81%94%E4%B8%AD%E6%AD%A2-a5107b59462a452db1c88baece5fa74f.png)

## **1.2 S2PL/SS2PL**

> [严格二段锁协议实现](https://blog.csdn.net/qq_37904988/article/details/105116789)

在上文中，重点提到S2PL定义的事务执行过程，不能立刻释放锁，必须**要等待整个事务提交或回滚后，才能释放锁**，即没有像普通2PL那样的收缩阶段，不会导致级联终止的情况

![S2PL](https://asea-cch.life/upload/2021/06/S2PL-fb94caefa0c040009f2ea11e27742602.png)

> [知乎用户陈广胜的回答](https://www.zhihu.com/question/39447427)

S2PL(Strict 2PL)：在2PL的基础上，将写锁保持到事务结束

SS2PL(Strong 2PL)：在2PL的基础上，读/写锁都保持到事务结束为止

## **1.3 一次封锁/顺序封锁**

> [《数据库知识整理 - 并发控制（封锁、两段锁协议、意向锁）》](https://blog.csdn.net/Ha1f_Awake/article/details/84994697)这篇文章总结了解决死锁的两类方法：预防和诊断解除

预防的方式有两种：

- 一次封锁法：每个事务一次性将要使用的**所有资源锁定**，数据要么全部锁定，要么全部失败
- 顺序封锁法：预先对数据**规定封锁顺序**，所有事务按照这个顺序加锁

第一种方法通过将对多个锁资源的锁定视作原子操作来解决问题，第二种方法则以固定顺序获取的方式防止闭环

    2.1的表锁，就是一次封锁的一种思路：行锁可以认为是多个锁资源，获取表锁，则相当于一次封锁了全部锁资源

# **2. 锁粒度**

粒度从大到小：表级锁 -> 页面锁 -> 行级锁

- Myisam和Memory引擎：采用表级锁

- BDB引擎：采用页面锁或表级锁（默认页面锁）

- **InnoDB引擎：采用行级锁和表级锁（默认行级锁）**

## **2.1 表锁**

定义：锁定粒度最大，表示对当前**操作的整张表加锁**，分为`表共享读锁（共享锁）`和`表独占写锁（排他锁）`

开销：操作简单，开销最小

死锁情况：不会出现死锁情况，因为粒度为**单个表**，即采用**一次封锁方式**

并发程度：**并发度最差**，因为一次性将资源锁定，要么**全部满足，要么全部等待**

## **2.2 行锁**

定义：锁定粒度最细，表示只针对当前操作的行进行加锁，分为`行共享读锁`和`行独占写锁`

开销：操作复杂，开销最大（涉及到数据筛选）

死锁情况：会出现死锁的情况，因为粒度为**多个行**，且没有硬性控制并发事务对资源的访问顺序，存在死锁的可能性

并发程度：**并发性能最好**，因为发生锁竞争的概率降低了

## **2.3 InnoDB对表锁和行锁的运用**

InnoDB的行锁是通过给索引上的索引项加锁来实现的，这意味着：

- **只有通过索引条件检索数据，InnoDB才可能使用行级锁，否则，InnoDB将使用表锁**
- 最终的加锁情况，由SQL执行优化器决定，如果走的是**全表扫描，就算有索引，也是锁的整个表**
- 锁的是索引，所以即使访问的是不同的行数据，也会因为相同的索引键被锁住
- 表有多个索引时，不同事务可以使用不同的索引来锁定不同的行

行锁可以生效的索引类型有：主键索引、唯一索引、普通索引

# **3. 锁级别**

为了进一步提升并发能力，按照级别将锁分为读锁和写锁，这种思想在很多地方都有体现

> JDK中的[ReentrantReadWriteLock](https://asea-cch.life/achrives/reentrantReadWriteLock)，借助AQS实现的读写锁，相比独占锁可以提升读的效率

InnoDB以行锁粒度，运用封锁协议，以支持不同的事务隔离级别

## **3.1 共享读锁(S)**

```sql
select * from `user` where id = 2 in share mode;
```

英文全称Share Lock，又称为S锁（来源Share的字母S）或读锁，是读取操作时候创建的锁。
数据被加上S锁后，其他事务的修改操作（对数据加X锁）都将阻塞，直至所有的S锁都被释放为止

    S锁与S锁不互斥，与X类型封锁互斥 -> 读读不互斥

作用：并发读提升读效率

缺点：可能会导致写操作饥饿；

如果想通过共享读锁来独占数据，以保证自身接下来的写操作是安全的思路是不可取的。因为其他事务可能也会因为读取数据而加入共享读锁，导致**本机事务接下来的写操作被阻塞，甚至导致死锁**

## **3.2 独占写锁(X)**

```sql
select * from `user` where id = 1 for update;
```

英文全称Exclusive Lock，又称为X锁（来源Exclusive的字母X）、写锁或排他锁，是写操作时创建的锁。
数组被加上X锁后，其他事务的修改操作（对数据加X锁）或读取操作（对数据加S锁）都将阻塞，直至本事务将X锁释放为止

    X锁与任意类型的封锁都互斥 -> 读写互斥，写写互斥

## **3.3 意向锁(IS/IX)**

意向锁是一种快速判断表锁与之前可能存在的行锁冲突的机制

> [innoDB的意向锁有什么用](https://www.zhihu.com/question/51513268)

行写锁和表写锁是互斥的，不可能同时出现在同一份数据中，所以在加表锁时，会进行如下两个判断：

1. 判断表是否已被其他事务使用表级锁锁住
2. 判断表中的每一行，是否有某一行被行级锁锁住

上述第二步的效率极低，所以当事务申请了行锁时，数据库还会自动完成**申请意向锁**，这可以使得其他事务**通过意向锁知道有行数据已经被行锁锁住**，从而快速阻塞

## **3.4 三级封锁协议**

封锁协议，指的是通过对两种不同类型的封锁的运用，以解决不同的数据一致性问题，可以与事务的隔离级别进行大致对应

一致性问题呈向下包含关系，即存在丢失更新问题时，其他三种问题都会存在：
- 丢失更新
- 脏读
- 不可重复读
- 幻读

> [三级封锁协议](https://blog.csdn.net/qq_33369979/article/details/88052203)

### **3.4.1 第一级封锁协议**

定义：事务会对**删改操作的数据加上X锁**，**直到事务结束才释放**，事务结束包括正常结束（COMMIT）或非正常结束（ROLLBACK），注意不会对查操作的数据加上S锁

解决问题：丢失更新

解决思路：在同一个时刻只有一个事务独占锁，事务之间的操作变为串行互斥

遗留问题：不会对查操作的数据加上S锁，会产生[脏读](https://blog.csdn.net/weixin_44939424/article/details/103248097)问题，即不同事务之间可以读取到相互之间操作的中间值

隔离级别：对应广义Read Uncommitted

### **3.4.2 第二级封锁协议**

定义：在一级封锁协议基础上，对查操作的数据加上S锁，并在**查询结束后即可释放S锁**

解决问题：丢失更新 + 脏读

解决思路：不同事务间的读、写操作互斥，会进入阻塞，这也意味着只有当**事务提交**时（独占锁释放），才会读取到数据

遗留问题：会读到其他事务提交后的值，会产生不可重复读问题，即在同事务内对相同数据的查询结果不同

隔离级别：对应广义Read Committed

### **3.4.3 第三级封锁协议**

定义：在一级封锁协议基础上，对查操作的数据加上S锁，**直到事务结束才释放**

解决问题：丢失更新 + 脏读 + 不可重复读

解决思路：与二级封锁协议一致，释放的时机为事务结束时释放，保证在整个事务过程中数据都不会被其他事务修改

遗留问题：仍无法解决幻读问题，因为锁的是已有数据，插入新数据则无能为力

隔离级别：对应广义Repeatabl Read

# **4. Mysql锁机制特性**

在3.3中介绍了广义上的三级封锁协议，而Mysql是通过MVCC和GAP来实现其对隔离级别的支持：

- 读未提交：一级封锁协议
- 读已提交：一级封锁协议 + **MVCC（每次查询使用最新快照）**
- 可重复读：一级封锁协议 + **MVCC（每次查询使用事务刚创建时的快照）** + GAP 
- 串行化：三级封锁协议

注意：`快照读`和`当前读`

## **4.1 MVCC**

MVCC(Multi Version Concurrency Control)，又名多版本并发控制技术，它使得大部分支持行锁的事务引擎，不再单纯的使用行锁进行数据库的并发控制，取而代之，把行锁和行的多个版本结合起来实现**非锁定读**

    用人话来说，正常的二级/三级封锁协议通过加S锁进行读阻塞，而MVCC通过read view来实现Read Committed或Repeatable Read的事务隔离性

> [read committed && MVCC](https://www.jianshu.com/p/fd51cb8dc03b)

### **4.1.1 MVCC实现所需**

MVCC机制通过以下作为支持：
- undo log：回滚日志，用于保证事务的原子性
- 本机事务id：保存本机事务的id，本机事务永远能看到自身的修改
- 活跃列表：在生成快照时，会将记录当前活跃的事务，生成一个ID升序的列表
- 高水位：系统即将分配的下一个事务ID，一般为当前活跃事务的ID + 1
- 低水位：活跃事务中id最小的事务，即活跃列表中的最小id
- 行记录的DB_TRX_ID事务指针：根据当前行的事务ID与活跃列表进行对比，可以区分当前行的活跃状态
- 行记录的DB_ROLL_PTR回滚指针：当前行如果为活跃状态，则通过回滚指针获得undo log中某个已提交的稳定版本
- read view：读快照，是MVCC机制的具体实现，用于判断行数据是否可以返回，综合以上4种措施进行判断

如果当前行的事务ID指针为01版本，其事务回滚指针**指向01版本之前的数据**：

![事务指针](https://asea-cch.life/upload/2021/06/%E4%BA%8B%E5%8A%A1%E6%8C%87%E9%92%88-80c4c4222fc64cca939c5d9d7fe07e68.webp)

### **4.1.2 判断规则**

> [判断规则（有纰漏）](https://database.51cto.com/art/202101/641019.htm)

> [ReadView机制的简单笔记1](https://blog.csdn.net/weixin_39942572/article/details/113441009)

> [ReadView机制的简单笔记2](https://blog.csdn.net/weixin_39969298/article/details/113152402)

> [重点参考：RC和RR下的MVCC](https://www.jianshu.com/p/fd51cb8dc03b)

假设当前活跃的事务ID有：100,150,200，开启事务对行X进行查询操作（快照读）：

![行格式](https://asea-cch.life/upload/2021/06/%E8%A1%8C%E6%A0%BC%E5%BC%8F-27cf39cbcea2448fbfc1a0c42c6dd346.webp)

在开启事务之后，先以当前时刻的事务ID，生成`活跃列表`[100, 150, 200]

根据该列表，生成区间，区间的最小值为最小活跃ID，**最大值为下一个分配的事务ID**，即[100, 201]，接着再**将X事务ID与区间的值进行比较：**

1. 情况一：X的事务ID小于活跃列表的最小值

    说明行X当前的事务版本，是在生成ReadView前已经提交的版本，可以直接返回

**2. 情况二：X的事务ID大于活跃列表的最大值**

    说明行X当前的事务版本，是在生成ReadView后开始的新活跃事务的版本，不可以直接返回当前行的数据（RR级别的一种情况）

**3. 情况三：X的事务ID的大小处于活跃列表区间内**

    需要遍历活跃列表，查找X事务ID是否在活跃列表中
    
    如果在的话，说明行X当前的事务版本，是在生成ReadView时，在活跃列表中的某个事务，不可以直接返回当前行的数据（RR级别的一种情况）

    如果不在的话，说明已经被提交了，可以直接返回当前行的数据（RC级别的不可重复读）

当遇到情况二与情况三时，说明当前的数据有并发操作的现象，此时为了保证可重复读，会借助`行的回滚指针`，定位到`undo log`中最近一个事务版本的日志数据，并**返回该数据的事务ID，重新进行如上比较**

### **4.1.3 RC和RR的MVCC不同**

假设有以下`user`表，共有3行数据，同时有三个事务进行，ID分别为100，150和200：

| id | name | age |
| ------ | ------ | ------ |
| 1 | 绿万 | 10 |
| 2 | 白万 | 20 |
| 3 | 黑万 | 30 |

#### **Read Commited级别下的ReadView：**

每一次快照读都使用**以最新的活跃事务生成的ReadView**，本机事务中可以读到其他事务的提交

| 事务100 | 事务150 | 事务200 |
| ------ | ------ | ------ |
| begin; |  |
| update `user` set name = '绿' where id = 1; | begin;  |
| （活跃列表：[100]，低水位100，高水位101） |  |  |
| | update `user` set name = '白' where id = 2; |
|  | （活跃列表：[100, 150]，低水位100，高水位151） |  |
|  | | begin; |
|  |  | update `user` set name = '黑' where id = 3; |
|  |  | （活跃列表：[100，150, 200]，低水位100，高水位201） |
|  | | commit; |
|  | select name from `user` where id = 3; （返回黑） |  |
|  | （活跃列表：[100, 150]，低水位100，高水位201）  |  |
|  | （id = 3的行的事务ID指针为200, 低水位100 < 200 < 高水位201，且不在活跃列表中，可以直接返回该数据）  |  |
|  | commit; | |
| select name from `user` where id = 3; （返回黑）  |  | |
| （如事务150生成ReadView）  |  | |
|  |  |
| select name from `user` where id = 2; （返回白） |  | |
| （活跃列表: [100]，低水位：100，高水位201）  |  | |
| （id为2的行事务ID为150，低水位100 < 150，且不在活跃列表中，可以返回）  |  | |


#### **Repeatable Read级别下的ReadView：**

每一次快照读都使用**创建事务时生成的ReadView**，本机事务不会读取到其他事务的提交

| 事务100 | 事务150 | 事务200 |
| ------ | ------ | ------ |
| begin; |  |
| （活跃列表：[100]，低水位100，高水位101，先通过一次快照读来生成ReadView） |  |  |
| select * from `user`; |  |  |
| update `user` set name = '绿' where id = 1; | begin;  |
|  | （活跃列表：[100, 150]，低水位100，高水位151，注意下面是当前读，不会生成ReadView） |  |
| | update `user` set name = '白' where id = 2; |
|  | | begin; |
|  |  | （活跃列表：[100，150, 200]，低水位100，高水位201） |
|  |  | update `user` set name = '黑' where id = 3; |
|  | | commit; |
|  | select name from `user` where id = 3; （返回黑，因为没有快照读） |  |
|  | （id = 3的行的事务ID指针为200, 200 > 151，不可以直接返回该数据）  |  |
|  | commit; | |
| select name from `user` where id = 3; （返回黑万）  |  | |
|  |  |
| select name from `user` where id = 2; （返回白万） |  | |
| （id为2的行事务ID为150，高水位101 < 150，不可以返回）  |  | |

    注意，快照读和当前读是不同的，RR只有在第一次快照读时，才会生成ReadView，即一个Select查询语句，而不是网传的事务开始

## **4.2 锁**

> [初步理解MySQL的gap锁：](https://www.cnblogs.com/crazylqy/p/7689447.html)这篇文章讲解了什么是gap

> [record,gap,Next-Key lock：](https://www.cnblogs.com/crazylqy/p/7773492.html)这篇文章讲解了什么是next-key，next-key = record + gap

间隙和记录都根据索引来进行，所以当dcl没有涉及到索引时，不会走行锁和间隙锁，会将全部行加上行锁（类似表锁）

而指定非唯一索引/主键索引的**等值**或**范围指定**的条件，将会在RR级别下使用间隙锁或NEXT_KEY_LOCK

等值规则：根据值定位索引位置，使用NEXT_KEY_LOCK（**间隔锁** + **行锁**），如果值存在索引中，则锁定该**索引行**，大于值与小于等于下一个索引值之间的间隙（闭），小于值与大于上一个索引值之间的间隙，即**左开右闭**

范围指定规则：根据指定的范围加锁，使用**间隔锁**

- **GAP_LOCK（间隙锁）**

    Gap就是**索引树**中**插入新纪录的空隙**，相应的GAP_LOCK就是**加在gap上的锁**，它通过阻止特定条件的新纪录插入，因为插入时也要获取GAP_LOCK，从而达到互斥

    GAP_LOCK只在REPEATABLE READ或以上的隔离级别的特定操作才会获得，当只指定范围时，会只使用GAP_LOCK

- **RECORD_LOCK（索引记录锁/行锁）**

    行锁，锁定的是索引记录，聚簇索引锁定具体行记录，否则锁定二级索引的记录

- **NEXT_KEY_LOCK（GAP + RECORD）**

    组合间隙锁和行锁的一种机制

属于锁定读取的操作：SELECT xxx FOR UPDATE/FOR SHARE，UPDATE，DELETE

> [Mysql官方的隔离级别加锁机制](https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_read-committed)：写的特别好，特别是RR和RC之间的锁选取

### **4.2.1 RC锁定策略**

锁定读取：**只使用RECORD_LOCK**，而不会锁定它们之间的间隙，因此允许在锁定记录旁边自由插入新纪录

锁定读取的加锁机制：

1. 对于FOR UPDATE/DELETE，对扫描路径上的行进行加锁，然后再根据WHERE条件评估，释放不匹配条件的行锁

2. 对于UPDATE，当扫描到的行已被锁定，执行**半一致读**，将最新提交版本提交到Mysql进行WHERE条件评估，如果确实匹配，则加锁/阻塞等待加锁，否则直接跳过

新行插入：由于间隙锁被禁用，可能会出现幻象行的问题，因为其他事务会话可以将新行插入到间隙中

### **4.2.2 RR锁定策略**

锁定读取：**使用NEXT_KEY_LOCK**，会锁定它们之间的间隙，遵循左开右闭的区间原则，避免当前读产生幻读

锁定读取的加锁机制：

1. 统一对扫描路径上的行进行加锁，无论是否匹配WHERE条件

2. 具有唯一搜索条件的唯一索引，只使用RECORD_LOCK锁定记录，而不会锁定间隙，因为扫描会提前短路，不会出现幻读情况

3. 其他搜索条件，都使用耳熟能详的NEXT_KEY_LOCK锁定间隙与行记录，防止幻读情况发生

然而RR仍会出现幻读！！在同一个事务操作序列中，如果当前读操作依赖于上一步的快照读操作，会产生幻读，因为快照读操作并没有对行进行锁定！！

### **4.2.3 Serializable锁定策略**

类似于RR，将所有普通的SELECT语句都隐式转换为了SELECT ... FOR SHARE

在autocommit启用的情况下，单独一个SELECT语句是它自己的事务，不会阻塞其他事务的更新

## **4.3 特性运用**

使用MVCC机制作为多版本并发控制，可以解决大部分的脏读/不可重复读问题，并且不会像二级封锁协议和三级封锁协议一样，使得查询操作阻塞

但是通过`快照读`的数据，在真实的`当前读`操作过程中，仍会遇到幻读的情况

```sql
SELECT * FROM xxx WHERE id = '1' FOR SHARE;
```

通过FOR UPDATE，主动用GAP_LOCK将数据**及其间隙**锁住，直到事务结束再释放S锁，这符合三级封锁协议，还解决了三级封锁协议无法处理的幻读问题

这种做法就是Mysql在串行化隔离级别的做法

# 参考
- [MySQL的MVCC及实现原理](https://blog.csdn.net/SnailMann/article/details/94724197)
- [Mysql中的MVCC](https://blog.csdn.net/chen77716/article/details/6742128)

- [2PL](https://blog.csdn.net/aigoogle/article/details/25804285?locationNum=6&fps=1)
- [严格二段锁协议实现](https://blog.csdn.net/qq_37904988/article/details/105116789)

# 重点参考
- [锁机制总结](https://blog.csdn.net/Ha1f_Awake/article/details/84994697)
- [锁机制分类](https://www.hollischuang.com/archives/909)
- [MySQL中的行级锁,表级锁,页级锁](https://www.hollischuang.com/archives/914)
- [MySQL中的共享锁与排他锁](https://www.hollischuang.com/archives/923)
- [重点参考：RC和RR下的MVCC](https://www.jianshu.com/p/fd51cb8dc03b)
- [Mysql官方的隔离级别加锁机制](https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_read-committed)