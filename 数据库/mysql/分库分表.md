# 分库分表

做法：将原来独立的数据库拆分为若干数据库组成，将数据大表拆分为若干数据表组成，使得单一数据库、表的数据量变小，从而达到提升数据库性能的目的

效果：解决由于数据量过大，导致独立数据库性能降低的问题

# **1. 方向**

> [MySQL 对于千万级的大表要怎么优化？](https://www.zhihu.com/question/19719997/answer/81930332)

先做垂直切分，根据模块的耦合度，将一个大系统切分为多个小系统，即分布式系统。再考虑水平切分，将数据量分出去，因为sharding key的选择要合理，而且水平切分的成本较高

> [彻底搞清分库分表](https://blog.csdn.net/weixin_44062339/article/details/100491744)

按照文章的思路，分库分表的迭代过程为：垂直分表 -> 垂直分库 -> 水平分库（水平分表作为更高阶的补充）

垂直分表分库的角度从业务出发，即对字段拆分出发，**会**影响表结构

水平分表分库的角度从数据量平铺出发，即对数据行拆分出发，**不会**影响表结构

## **1.1 垂直切分**

垂直分表：将一张大表按照冷热业务特点，切分成多张小表

垂直分库：将单库按照业务相关性，切分成多个小库

### **1.1.1 垂直分表**

`垂直分表`：将一个表按照字段分成多个表，每个表存储其中一部分字段

表往往与某个业务模块对应，垂直分表相当于将业务模块进行切分，将大系统切分为多个小系统

数据项的访问频次并不一致，分为**热点字段**和**冷门字段**，垂直分表最典型地应用就是将**性能提升在热点数据的操作效率**；同理，**冷门数据也不会因为热点数据的高频次访问受到影响**，**减少锁表几率**

垂直拆分表的原则：

1. 将不常用的字段放在另外一张表中
2. 把text，blob等大字段拆分出来放在附表中（Dynamic完全行溢出是否还有意义？）
3. 经常组合查询的列放在一张表中（临时表的问题？）

提升：

1. 热点数据与冷门数据的操作解耦，减少互相之间的锁表概率，提升了热点数据操作效率的同时，缓解冷门数据饥饿问题

2. 冷门数据往往可能是大字段text，varchar，blob，会导致I/O效率下降，分到不同的存储结构中，可以更好地提升热门数据的I/O效率，进一步提升操作效率（Dynamic使用完全行溢出的方式组织行，会在一定程度上缓解这个问题）

### **1.1.2 垂直分库**

`垂直分库`：按照业务将表进行分类，分布到不同的数据库上，每个库放在不同的服务器上，做到专库专用

库往往与某个服务器对应，垂直分库相当于将同一个物理机的CPU，内存，网络，IO，磁盘的竞争进行切分

垂直拆分库的原则：

1. 将业务耦合度较高的表分在同一个库
2. 根据业务的访问频次，分配不同的部署服务器性能

提升：

1. 去耦合，业务更清晰，对不同业务的数据进行分级管理

2. 高并发场景下，垂直分库可以一定程度提升I/O，数据库连接数，降低单机硬件的瓶颈，使得多个服务器共同分摊压力的效果，但**这种分摊并不是平均的，根据业务的访问热度决定**

## **1.2 水平切分**

水平切分又称为Sharding，它将**同一个库/表的记录**拆分到**多个结构相同**的库/表中，在获取数据时，通过**Sharding策略**映射获取。每一个结构相同的数据，我们称为**分片**

水平分库：将单库按照sharding key进行水平切分，切分为多库

水平分表：将某个库中的单表按照sharding key进行水平切分，切分为多个表

### **1.2.1 水平分库**

通过1.1的垂直分表分库操作，我们将一张表的冷热字段拆表，并通过模块相关性分库。但随着业务量的增长，单库存储数据仍可能超过预估，可从业务角度分析，已经无法再次垂直分库

`水平分库`：把同一个表的数据**按一定规则（sharding key）**拆到不同的数据库中，每个库可以放在不同的服务器上

提升：
- 解决了单库大数据，高并发的性能瓶颈
- 提供系统稳定性和可用性

    稳定性体现在IO冲突减少，锁定减少，可用性指某个库出问题，部分可用

经过水平切分优化，往往能解决单库存储量及性能瓶颈，但由于同一个表被分配在不同的数据库中，需要**额外进行数据操作的路由工作，提升了系统复杂度**

### **1.2.2 水平分表**

类似水平分库的思路，在同一个库中对表进行水平拆分，目的也是为了解决单表数据量过大的问题

`水平分表`：把同一个表的数据**按照一定规则（sharding key）**拆到不同的表中，这些表放在同一个服务器上

提升：
- 优化单一表数据量过大而产生的性能问题
- 避免IO争抢并减少锁表的几率

水平分表仍然无法突破单机的性能瓶颈，提升幅度有限，它应仅仅作为水平分库的一个补充优化

## **1.3 总结**

在系统设计阶段，就应该按照业务耦合松紧来确定垂直分库，垂直分表的方案

在数据量及访问压力不是特别大的情况下，应遵循以下的顺序进行优化：

1. 优先SQL优化和索引

2. 其次是缓存技术

3. 应用层上的主从复制/读写分离

4. mysql自带分区表，分区表对应用是透明的，无需修改代码。但是sql语句需要针对分区表做优化，sql条件带上分区条件的列，从而使查询定位到少量的分区上

5. 垂直拆分，将大系统分为多个小系统，即分布式系统

    - 垂直分表：将一个宽表的字段按照冷热/大小拆分小表，使业务更加清晰和提升部分性能。**注意：需要联合查询的字段不能垂直拆开，否则性能得不偿失**

    - 垂直分库：将多个表按照业务模块化归类，存放不同的库，得以突破单库的性能瓶颈，将访问压力分散化，并更进一步提升整体架构的业务清晰度

6. 最后才是水平拆分

    针对数据量大的表，sharding key的选择至关重要。并且为了水平拆分后拥有好的查询效率，表结构可能也需要做改动，增加一定的冗余，还需要修改应用层的代码，将查询定位到限定的表上

    - 水平分库：可以把全部表的数据分到不同的库，每个库只有某个表的部分数据，这些库又分布在不同的服务器中，从而使得**单模块的访问压力被进一步分散**

    - 水平分表：一个表的数据分到同一个数据库的多张表中，本质仍在同一个库中，只作为水平分库的补充

# **2. 生产应用**

> [分库分表的中间件设计理念](https://zhuanlan.zhihu.com/p/107100975)

应用上的中间件，更多**针对水平切分操作**；垂直切分由系统业务设计者决定，中间件（如Sharding-jdbc）只是通过数据源配置，屏蔽开发代码中需要对垂直源进行指定的复杂操作

不管使用单库分表（水平分表，表名不同）还是使用多库分表（水平分库，表名相同），都需要以下的步骤；
- 制定sharding key的策略
- 制定路由规则
- 根据路由规则实现路由

根据以上的步骤，可以将中间件的类型归结为两大模式：

1. CLIENT模式

    ![Client模式的sharding](https://asea-cch.life/upload/2021/07/Client%E6%A8%A1%E5%BC%8F%E7%9A%84sharding-f3319443c0b24e08979b8ae56e42d7f7.jpeg)

    client模式需要集成到应用中，应用直接通过jdbc驱动对数据访问请求进行路由

2. PROXY模式

    ![Proxy模式的sharding](https://asea-cch.life/upload/2021/07/Proxy%E6%A8%A1%E5%BC%8F%E7%9A%84sharding-4fd0aae48a1a4b5890287f9132b960c6.jpeg)

    proxy模式下，应用无需感知分库分表的策略，对于应用而言数据库整体是一个黑盒，数据访问请求由中间的代理层进行处理

无论是Client/Proxy模式，几个核心的步骤都是一样的：**SQL解析、重写、路由、执行、结果归并**

## **2.1 Apache ShardingSphere**

一套分布式数据库中间件解决方案**组成的生态圈**，由三款相互独立的产品组成：
- Sharding-JDBC：增强版的JDBC驱动
- Sharding-Proxy：透明化的数据库代理端，可以看作是一个网关服务
- Sharding-Sidecar（计划中）

作为一款数据分片中间件，可以避免通过业务框架进行分片，降低代码的维护成本，解耦业务和DAO层的分片代码

### **2.1.1 sharding-jdbc**

![sharding-jdbc流程图](https://asea-cch.life/upload/2021/07/sharding-jdbc%E6%B5%81%E7%A8%8B%E5%9B%BE-e3c3a75af12a4de483f2a279daab0b8c.webp)

定位为**轻量级Java框架**，该中间件在Java的JDBC层提供额外服务，使用CLIENT模式直连数据库，以jar包形式为应用提供服务

- 中心化：否
- 性能损耗：低
- 连接消耗数：高
- 异构语言：仅Java
- 数据库支持：任意数据库

#### **SQL执行过程**

应注意：工程师是面向逻辑库和逻辑表书写SQL，并不能在真实的数据库环境中执行，sharding-jdbc通过以下流程，执行真正遵循物理表的SQL

**1. SQL解析**

通过词法分析器来解析工程师的SQL语句，提取出：

- Select Items：查询选择项
- Table：表信息
- Sharding Condition：分片条件
- Auto increment Primary Key：自增主键信息
- Order By：排序信息
- Group By：分组信息
- Limit、Rownum、Top：分页查询信息

**2. SQL改写（正确性改写与优化改写）**

1. 正确性改写

    在包含分表场景下，需要将分表配置中的逻辑表**改写为路由之后所获取的真实表名称**，仅分库则不需要表名称的改写。除此之外，还包括**补列**和**分页信息修正**等内容

2. 优化改写

    路由至单节点的SQL，无需优化改写，上述的补列和分页信息等改写也无需进行

**3. SQL路由**

根据SQL解析，并通过SQL改写生成路由路径，根据分片键的不同可以划分为：

- 单片路由：分片键的操作符是等号
- 多片路由：分片键的操作符是IN
- 范围路由：分片键的操作符是BETWEEN AND
- 广播路由：不携带分片键

标准路由包含单片路由、多片路由和范围路由，当分片键操作符是等号时为单片路由，如果是IN为多片路由， 如果是BETWEEN的情况，则需要指定绑定表关系，才能执行性能较高的范围路由

<!-- TODO: 看到路由规则，在思考笛卡尔积路由和范围路由的区别，已经广播路由的区别。接下来是看执行和结果归并，看完后开始了解分布式全局唯一ID和一致性hash算法-->

**4. SQL执行**

**5. 结果归并**

### **2.1.2 sharding-proxy**

![sharding-proxy](https://asea-cch.life/upload/2021/07/sharding-proxy-6b6d8f9576004bc59fff3c3cd8b6dd32.png)

定位为**透明化的数据库代理端**，用于完成对异构语言的支持，可以兼容任何MySQL/PostgreSQL协议的访问客户端操作数据，对DBA更加友好。对于应用而言完全透明，可以直接当做一个Mysql来使用

- 中心化：是
- 性能损耗：高
- 连接消耗数：低
- 异构语言：任意
- 数据库支持：仅Mysql/PostgreSQL

## **2.2 分片**

> [分片](https://blog.csdn.net/u013308490/article/details/94598606)

分片策略包含：分片键和分片算法

开发人员关注：分片键的选取（是否合理至关重要），分片算法（开发人员自行设计）

分片中间件关注：分片算法场景的抽象，组合分片算法场景的分片策略（比分片算法场景更高级的抽象）

### **2.2.1 表概念**

业务场景：在原先的业务系统中，有单库ds，和单表t_u_player，先同时进行水平分库和水平分表

    首先，根据某种规则，将ds库水平拆分为2个库，分别是ds_0和ds_1，数据相当于被切分为两部分，两个库具有相同的表t_u_player；其次根据t_u_player表的主键id，将t_u_player表的拆分为10张表，t_u_player表的数据均匀的分布在这10张表上，分别是t_u_player0到t_u_player9

1. 逻辑表（Logic Table）：进行水平拆分时同一类型（逻辑、数据结构相同）的表的总称

    > 上例中，逻辑表名为t_u_player

2. 真实表（Actual Table）：在分片的数据库中真实存在的物理表

    > 上例中，真实表共有10张，分别为t_u_player0到t_u_player9

3. 数据节点（Data Node）：数据分片的最小单元，由数据源名称和数据表组成

    > 上例中，ds_0.t_u_player0为一个数据节点，共有18个数据节点（ds_0.t_u_player0 ~ ds_0.t_u_player9，以及ds_1.t_u_player0 ~ ds_1.t_u_player9）

4. 动态表（Dynamic Table）：逻辑表和物理表不一定需要在配置规则中静态配置

    > 按照日期分片的场景下，物理表的名称随着时间的推移会发生变化

5. 绑定表（Binding Table）：指分片规则一致的主表和子表，在配置后互为绑定表关系，绑定表之间的多表关联查询，**不会出现笛卡尔积关联**，效率大大提升

    > t_u_player表和t_u_ticket表，均按照id分片，则可以配置此两张表互为绑定表关系

    在执行以下SQL，查询玩家的季票信息和玩家信息时：
    ```sql
    SELECT i.* FROM t_u_player o JOIN t_u_ticket i ON o.id = i.id WHERE o.id in (10, 11);
    ```

    **如果没有配置绑定关系**，假设分片键id将数值10路由至第0片，将数值11路由至第1片，那么路由后的SQL应该为4条：
    ```sql
    SELECT i.* FROM t_u_player_0 o JOIN t_u_ticket_0 i ON o.id=i.id WHERE o.id in (10, 11);

    SELECT i.* FROM t_u_player_0 o JOIN t_u_ticket_1 i ON o.id=i.id WHERE o.id in (10, 11);

    SELECT i.* FROM t_u_player_1 o JOIN t_u_ticket_0 i ON o.id=i.id WHERE o.id in (10, 11);

    SELECT i.* FROM t_u_player_1 o JOIN t_u_ticket_1 i ON o.id=i.id WHERE o.id in (10, 11);
    ```

    **如果配置了绑定关系**：
    ```sql
    SELECT i.* FROM t_u_player_0 o JOIN t_u_ticket_0 i ON o.id=i.id WHERE o.id in (10, 11);

    SELECT i.* FROM t_u_player_1 o JOIN t_u_ticket_1 i ON o.id=i.id WHERE o.id in (10, 11);
    ```

6. 广播表

    指所有的分片数据源中都存在的表，表结构和表中的数据在每个数据库中均完全一致，适用于**数据量不大，且需要与海量数据进行关联查询**的场景

    例如：字典表，配置表

7. 单表

    指所有的分片数据源只存在**唯一一张**的表，适用于数据量不大，且不需要做任何分片操作的场景

### **2.2.2 分片键**

又称分片字段，用于将数据库（表）水平拆分，分片键可以包含不止一个字段

### **2.2.2 分片算法**

进行水平拆分时使用的算法，分片算法因为跟业务会有强相关性，所以需要**开发人员自行实现**

**常见的分片算法实现方案**：

- 哈希取模

    hash(key) % N，适用于简单架构

- 一致性hash算法

    > [简单hash算法和一致性hash算法](https://zhuanlan.zhihu.com/p/34968328)

    适用于集群架构，在集群中节点的添加和删除不会造成数据丢失
    
- 某个值范围，可以是ID范围，也可以是时间范围
    
    按照业务进行分配，ID可能会具备业务意义

- 按照某种规则均匀轮询

- 映射表：使用一个单独的数据库来存储映射关系

以sharding-jdbc为例，为了提供更高灵活度的算法结构，只对**算法场景**提供抽象接口，供开发人员填充`分片算法实现`

sharding-jdbc拥有以下具体的**算法场景**：
- PreciseShardingAlgorithm（精确分片）：使用单一键作为分片键，对=、IN操作进行分片的场景
- RangeShardingAlgorithm（范围分片）：使用单一键作为分片键，对BETWEEN AND进行分片的场景
- ComplexKeysShardingAlgorithm（复合分片）：使用多个键作为分片键
- HintShardingAlgorithm（Hint分片）：使用Hint行作为分片键

### **2.2.3 分片策略**

由于分片和业务紧密相关，以sharding-jdbc为例（在后续会着重讲解），并没有提供内置的**分片算法**，而是通过`分片策略`将**算法场景**再次提炼，提供更高层次的抽象

所以某些分片策略会限定**分片算法场景**，两者需要配合使用

注意：一个策略可以包含多个**算法场景**

sharding-jdbc的常用5种Sharding策略：
- StandardShardingStrategy（标准分片策略）

    只支持单分片键，提供精确分片（必选）和范围分片（可选）两个分片算法，前者处理=、IN，后者处理BETEWEEN AND

    注意：如果不配置范围分片，SQL中的BETWEEN AND将按照全库路由处理

- ComplexShardingStrategy（复合分片策略）

    支持多分片键，同样提供对SQL语句中的=，IN和BETWEEN AND的分片操作支持，没有硬性要求提供算法场景

    注意：因为多分片键场景复杂，该策略并未进行过多的封装，直接将分片键值组合和分片操作符传到下层的分片算法中，需要完全由开发者实现

- **InlineShardingStrategy（行表达式分片策略）**

    只支持单分片键，使用Groovy表达式，提供SQL语句中的=和IN分片操作支持，用于实现**简单分片算法，不需要代码**，常见配置到应用yml文件中

    例如：t_user_$->{u_id % 8}表示t_user表根据u_id模8，而分成8张表，表名称为t_user_0到t_user_7

- HintShardingStrategy（hint分片策略）

    通过Hint而非SQL解析的方式分片的策略（需要再了解下）

- NoneShardingStrategy（不分片策略）

### **2.2.4 分片策略配置**

对于分片策略有`数据源分片策略`和`表分片策略`两种维度

- 数据源分片策略

    对应于DatabaseShardingStrategy，用于配置数据被分配的目标数据源

- 表分片策略

    对应于TableShardingStrategy，用于配置数据被分配的目标表
    
    注意：目标表存在于该数据的目标数据源内，所以表分片策略是依赖于数据源分片策略的结果

## **3. 分布式主键**

> []()

# 参考
- [彻底搞清分库分表（垂直分库，垂直分表，水平分库，水平分表）](https://blog.csdn.net/weixin_44062339/article/details/100491744)
- [分库分表的中间件设计理念](https://zhuanlan.zhihu.com/p/107100975)
- [简单hash算法和一致性hash算法](https://zhuanlan.zhihu.com/p/34968328)

- [ShardingSphere官方文档](https://shardingsphere.apache.org/document/current/cn/overview/)