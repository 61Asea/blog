# Mysql：事务与事务隔离级别

事务又名为**TCL**，全称是transanction control language，意思是事务控制语言，ACID为事务的四大特性，分别为：Atomicity原子性、Consistent一致性、**Isolation隔离性**、Durability持久性

    数据库通过原子性、隔离性、持久性，来保证一致性，也就是说在ACID四大特性之中，C是目的，AID是实现C的手段，为了保证C，必须实现AID三大特性

如果没有**Isolation隔离性**，一个操作会导致四种不同的**不一致情况**，包括：脏读、可重复读、不可重复读、幻读。针对这些情况，事务提供了不同的隔离级别以支持做到不同程度的隔离性

# **1. ACID特性**

假设这样的场景：A账户向B账户转账100块人民币

## **1.1 Atomicity原子性**

如果无法保证原子性：

    A扣了100块后，立即宕机，B账户并没有获得这100块钱
    
    假设这个过程没宕机，存在其他用户看到到A的账户-100，但是B的账户没有+100的中间状态，这也不符合原子性

一个事务是一个不可分割的工作单位。包含的所有操作要么全部成功，要么全部失败回滚，因此事务操作如果成功，则要**完全应用**到数据库，如果操作失败，则不能对数据库有任何影响，**不存在任何中间状态**

## **1.2 Durability持久性**

为了解决外存和内存的读写速度差异，Mysql会将磁盘上的数据加载到内存，对内存进行操作再对磁盘进行回写

如果无法保证持久性：
    
    假设事务在A和B的转账操作成功了，但是在回写磁盘过程中宕机，则内存修改的数据全部丢失，即无法持久化

事务一旦提交，它对于数据库的改变应是**永久性**的，接下来的其他操作或故障对其不应有影响

## **1.3 Isolation隔离性**

出现并发事务时，事务之间感觉不到有其他事务在并发执行。假设有T1和T2两个事务，在T1看来，T2要么在T1开始之前就结束，要么在T1结束之后开始

如果无法保证隔离性：

    1. 丢失更新

       B本来有200块，A向B转账100块，此时C也给B转账100块，但是这两个操作都是以B本来的200块做计算，最后B的余额变成300块，少了100块

    2. 脏读

        B还是200块钱本金，ABC三人约定好如果B的余额小于300块钱，才转给B钱

        这时候A和C同时开始要去转账，A发现B的余额为200块钱本金，则开始转账100块钱给B，但是并没有点击确定按钮；与此同时，C看到


数据库提供了从低到高的4种基本隔离级别，分别解决以上不同的问题。应根据**具体业务所能承受的一致性做选择**，因为隔离级别越高，数据库的并发性将会降低

## **1.4 Consistency一致性**

事务执行前后，数据处于一种合法的状态，这种合法状态由我们决定，也就是说一致性其实是根据业务需求而界定的

一致性是我们的最终目的，原子性和持久性是一致性的必要前提，隔离性作为一致性的手段

# **2. 隔离级别**

> [Mysql的事务隔离级别官方文档](https://dev.mysql.com/doc/refman/8.0/en/innodb-transaction-isolation-levels.html#isolevel_read-committed)

InnoDB提供1992标准下的四大事务隔离级别，但是在具体实现和效果并没有严格遵循标准，而是提供了其他的特性来更好地优化不同隔离级别下可能会遇到的问题

## **2.1 Read Uncommitted**

解决了基本的丢失更新，但因为SELECT操作没有对数据加锁，会导致脏读的情况

## **2.2 Read Committed**

解决了脏读的情况，但不是通过对SELECT操作加锁来解决的，因为这会导致锁定的一致读

通过MVCC机制来实现非锁定的一致读，以**每次SELECT操作**时的行的事务ID指针、活跃事务列表和高低水位来返回ReadView，所以依旧没有解决**不可重复读**的问题

## **2.3 Repeatable Read**

解决了不可重复读的问题，与Read Comitted一样通过MVCC实现非锁定一致读，以**第一次SELECT操作生产的快照**作为整个事务的ReadView

并且在锁定读取中加入了间隙锁和行锁，在唯一索引的唯一搜索条件下使用行锁，在其他搜索条件下使用NEXT_KEY_LOCK（结合间隙锁和行锁），来解决当前读的幻读的问题

但是如果事务操作序列中，如果有当前读的操作依赖于上一步的快照读操作的返回数据时，仍会出现幻读问题

## **2.4 Serializable**

真正意义上解决了幻读问题，SELECT操作隐式转换为FOR SHARE读取，加锁的机制也是通过间隙锁和行锁结合

# **3. 传播机制**

# **4. 总结**

互联网项目应使用RC作为默认隔离级别

RR相比于RC：
1. 在不走索引时，RR会锁住全部行和间隙，且无论是否结果匹配都不解锁；RC会先锁住扫描路径的行，再根据匹配结果进行解锁

2. RC的update操作支持半一致读（semi-consistent），可以增加update操作的并发性。当发现行被锁住时，会通过行的最新版本提交到mysql中进行判断，如果确实是匹配，才加锁阻塞，否则可以直接跳过；而RR不支持，无论是否匹配都会阻塞等待

所以使用RC可以很大程度地提升并发性能，并且**不可重复读**的问题是可以接受的，它可以抛到上层应用中处理

Mysql默认使用RR作为默认隔离级别只是为了binlog主从同步时兼容Statement记录格式不会出现主从不一致的情况，因为在RC级别中并没有间隔锁，而Statement格式在记录操作时，是以事务提交顺序作为操作顺序的

# 参考
- [MySQL事务隔离级别和实现原理](https://zhuanlan.zhihu.com/p/117476959)
- [数据库事务的四大特性](https://www.cnblogs.com/fjdingsd/p/5273008.html)

- [Innodb中的事务隔离级别和锁的关系](https://tech.meituan.com/2014/08/20/innodb-lock.html)
- [](http://blog.itpub.net/31559358/viewspace-2221931/)

- [](https://www.jianshu.com/p/bf862c37c4c9)

# 重点参考
- [事务的四大特性，以及实现原理](https://blog.csdn.net/star1210644725/article/details/96829608)
- [MVCC能否解决幻读？](https://blog.csdn.net/qq_35590091/article/details/107734005)

- [为什么使用RR隔离级别作为默认级别](https://www.cnblogs.com/shoshana-kong/p/10516404.html)

<!-- 读未提交：读取其他事务未提交的内容，即可能脏读

读已提交：只有其他事务提交的内容，才能被本事务读取到。不会脏读，但不可重复读，每次读可能数据都不同

- 快照读
- 当前读

可重复读：使用MVCC做快照读，不会读取到其他事务提交的内容，解决了不可重复读；在写数据时，会做当前读操作，通过间隙锁锁定特定数据的前后间隙，让数据无法插入，以解决了大部分幻读问题

串行化： -->

后续问题：

可重复读中的两种幻读问题：
- 第一种，两个事务同时开启，事务A未提交期间，执行索引范围插入操作时，会将对应的记录直接的间隙也锁住，其他事务将无法在间隙操作，会进行阻塞等待（解决两个当前读的幻读问题）

- 第二种：两个事务同时开启，事务A未提交，接下来要执行第一种问题的操作，此时，事务B立即执行操作并提交。这时候事务A的间隙锁还未开始，且快照读为开启事务的视图，如果以快照读作为其接下来的操作依据，将出现幻读现象