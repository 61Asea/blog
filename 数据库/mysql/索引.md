# Mysql（二）：索引

> [2-3-4树](https://asea-cch.life/achrives/2-3-4-tree)

> [B树](https://asea-cch.life/achrives/btree)

> [B+树](https://asea-cch.life/achrives/b+tree)

铺垫了很多关于树结构、基本外存读写机制和Mysql的存储结构，本文将开始分析Mysql的索引机制

    思考1：如果没有索引的话，我们应如何查找数据？

在没有索引的情况下，最基本的查询算法是**顺序查找**，但O(N)的时间复杂度以及随机性极强的特性，在数据大量级情况下性能及其糟糕

    思考2：顺序查找不行，那让数据的插入按照某种顺序，再用N分查找不行么？

N分查找在一定程度上提升了查找效率，并且降低查询次数的随机性，将最大查找次数控制在了$O(log_N^N)$上。但是按照某种顺序插入这个是痛点，这会造成巨大的数据移动成本，甚至还需要I/O读块到内存，会使得这个移动成本变得更大

    思考3：那既然通过连续空间这种组织数据的方式有移动成本，我使用B-树不就行了

这里就不再强调为什么不用红黑树这个问题了，详情可以查看下面文章的第三章，有讲解到B-树为何更适合作为外部存储的数据结构

> [2-3-4树](https://asea-cch.life/achrives/2-3-4-tree)

使用B/B+/B*树来组织数据，确实可以干掉以上问题的很多痛点，但是又有新的问题出现了：

    树结构的建立是依据数据的某个组织，它的查找优势只能基于该组织，往往我们需要的查找，不应只有该组织，可能是通过其他组织，甚至多个组织组合

所以，数据库维护着满足**基于特定的查找算法**的数据结构，这些数据结构以某种方式引用数据，我们可以通过在这些数据结构上**实现高级查找算法找到数据引用**，再间接地通过引用锁定到真实数据上，这些数据结构就叫做索引

通过索引，我们可以忽视掉底层数据的组织形式，尽管它们可能是以B树组织的，或者按照插入顺序排列的连续空间

> [InnoDB存储](https://asea-cch.life/achrives/innodb存储)采用B+树，将索引键与子节点指针存放在非叶子节点中，数据存储在叶子节点中并冗余索引键

# **使用B-树(B+树)的好处**

一般而言，索引本身也很大，不可能全部存储在内存中，需要以文件的形式存储在磁盘里。这样，在索引查找的过程中就会产生磁盘操作，它比内存的操作耗时多好几个数量级，所以评价一个数据结构作为索引的优劣，**取决于该结构产生磁盘I/O存取次数的渐进复杂度**

Mysql以页为单位进行读取，B+树的非叶子节点与叶子节点冗余了主键，InnoDB通过将真实数据存储在了叶子节点上，而在非叶子节点上只存储主键和子节点的指针引用，从而使得整棵树的高度进一步削短，从而降低读取索引页的次数

# **1. 索引的分类**

当然，数据库系统的索引可能不只是前言所说的高级查找算法，它涉及到的层面很多，本节我们将从不同层面上对索引进行梳理，这些索引术语可能来自数 据存储（应用层）、算法和用户层等各方各面：

先罗列一下这些讨人厌的索引：

    聚簇索引、非聚簇索引、B+树索引、哈希索引、R树索引、全文索引、空间数据索引、唯一索引、普通索引、主键索引、前缀索引、覆盖索引

尽管它们好像都是不同的索引，但有的其实是同一种索引，不同层面上的名词：

- 数据组织：B+树索引、哈希索引、R树索引
- 数据存储：**聚簇索引**、**非聚簇索引**
- 用户层：主键索引、唯一索引、普通索引、联合索引、全文索引、空间索引
- 查询方式：覆盖索引

 **基于聚簇索引建立**的，索引才有**主索引**和**辅助索引**之分，辅助索引将采用**非聚簇索引**

对于Myisam而言，它没有使用聚簇索引组织数据，所以也就没有主/辅助索引之分，在数据和索引的组织方式上，采用的是**非聚簇索引**

## **1.1 主索引（聚簇索引）**

在[数据索引页](https://asea-cch.life/achrives/innodb存储#2-页（数据索引页）)中，会保存当前页处于整棵B+树的哪一个层级。不同层级的页，其行格式不同：非叶子节点的行格式，不保存真实数据，而保存主键索引和子节点的指针；子节点的行格式，保存主键和真实数据

    聚簇索引：将数据与索引存储在一起，索引结构的叶子节点存储了真实数据

![InnoDB的主索引](https://asea-cch.life/upload/2021/06/InnoDB%E7%9A%84%E4%B8%BB%E7%B4%A2%E5%BC%95-bebaed6e09324c969dd3d69a818d9077.png)

根据聚簇索引的B+树结构和特点，可以总结聚簇索引的特性：

- 优先性：

    在创建表的时，就会默认根据**主键索引**创建聚簇索引，若无主键则会寻找**唯一索引**字段，若也无则通过row_id隐藏列进行创建

- 唯一性：

    **一个表仅有一个聚簇索引**，所以也叫其**主索引**

- 物理有序：

    页内的行数据，以及相邻叶子节点页，在物理存储上都是**主键有序**的，并且相邻叶子节点页之间用双向链表进行链接，可以更方便地进行遍历


所以，这几种索引昵称在InnoDB默认情况下是同个意思：聚簇索引、主索引、主键索引、无主键索引时的唯一索引

    因为Myisam并没有聚簇索引，其主索引和二级索引，都是类似相同的结构，叶子节点都存放的是物理地址

## **1.2 辅助索引（非聚簇索引）**

    非聚簇索引：将数据与索引分开存储，索引结构的叶子节点指向了数据对应的位置

非聚簇索引是相对于聚簇索引而言的，辅助索引是相对于主索引而言的，非聚簇索引是辅助索引存储数据的方式

1. InnoDB采用非聚簇索引的方式实现二级索引：

    ![InnoDB的二级索引](https://asea-cch.life/upload/2021/06/InnoDB%E7%9A%84%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95-b345c79d0a694860bb2fdd7a3bf754c7.png)

    可以看出叶子节点存放的都是主键的值，这也是二级/辅助的来由，它会根据主键的值进行**回表**操作，即根据主键值回到主索引中查找真实的数据，那么使用辅助索引检索都将**经过两颗B+树查找**

    我们可以在InnoDB引擎下，通过建立唯一索引（已有主键索引）、普通索引、联合索引来建立二级索引

2. Myisam采用非聚簇索引的方式实现索引，其索引没有主/辅之分，都是平级的：

    ![Myisam的非聚簇索引](https://asea-cch.life/upload/2021/06/Myisam%E7%9A%84%E9%9D%9E%E8%81%9A%E7%B0%87%E7%B4%A2%E5%BC%95-05b43f59c2634872acc57ee350652e73.png)

根据非聚簇索引构建的B+树和特点，可以总结非聚簇索引的特性：

- 物理凌乱

    存储的是主键值的物理地址，可能逻辑上相邻的节点，在物理上是不相邻的。当找到叶子节点后，还需要一次I/O操作对值寻址

- 占用空间小

    因为存储的不是真实数据，所以索引整体占用空间小，可以直接将整个索引加载到内存中

这几种索引昵称在InnoDB默认情况下都采用非聚簇索引方式构建B+树：辅助索引、有主键索引时的唯一索引、联合索引、普通索引

## **1.3 聚簇索引的优势(InnoDB对比Myisam的优势)**

聚簇索引使得数据与索引存储在一起，这意味着当I/O读取页时，就已经将索引和数据一同加载到内存

非聚簇索引将数据与索引分开存储，叶子节点存储的是数据的物理地址，真实数据存储上为凌乱的，在叶子节点逻辑相邻的行并不一定实际相邻

所以，聚簇索引有以下两大方面优势：

### **I/O次数**

InnoDB找到叶子节点时，就可以直接从内存返回数据；而Myisam找到叶子节点后，会**多一次根据物理地址查找值的I/O操作**，这个I/O寻址操作可能是效率极低的

假设接下来的情况，数据的存储都不在同一操作系统页中（即查询数据必定不在上次I/O操作的缓存里）：

- 当遇到**范围查询**时，Myisam多一次的I/O操作就将会变成O(N)数量级的操作，磁盘将不停的寻道，效率极差

- 当需要继续访问同一数据页的相邻行记录时，已经把页加载到了Buffer缓存器中，再次访问时，InnoDB内存中完成访问并返回数据，不必访问磁盘；Myisam仍得进行一次I/O寻址操作

### **二级索引维护成本**

InnoDB二级索引采用非聚簇索引，叶子节点存放主键的值，以回表的方式查询主索引；Myisam二级索引同样采用非聚簇索引，但叶子节点存放的仍是物理地址

这样的话，当遇到数据变化导致树结构变化的情况时，InnoDB可以只关注主索引树结构的维护，而不用维护二级索引

## **1.4 非聚簇索引的优势（Myisam对比InnoDB的优势）**

非聚簇索引不需要存储数据，**所占空间小**，可以直接将整个都读取到内存，这将带来以下好处：

- 大数据量的排序
- count操作
- 全表扫描

# **2. InnoDB索引优化**

建立下列的demo表，来讲解索引优化机制，其中id字段为主键索引，bcd三个字段共同组成联合索引

```sql
CREATE TABLE `demo` (
	`id` INT(20) NOT NULL AUTO_INCREMENT,
	`b` INT(20) NOT NULL DEFAULT '0',
	`c` INT(20) NOT NULL DEFAULT '0',
	`d` INT(20) NOT NULL DEFAULT '0',
	`e` INT(20) NOT NULL DEFAULT '0',
	PRIMARY KEY (`id`),
	UNIQUE INDEX `b_c_d` (`b`, `c`, `d`)
) COLLATE='utf8mb4_0900_ai_ci';
```

使用**EXPLAIN**对语句性能进行分析

## **EXPLAIN**

> [mysql中explain的type的解释](https://blog.csdn.net/dennis211/article/details/78170079)

type：
- all：全表扫描，**性能最差**
- index：另一种形式的全表扫描，**不用回表**，它的扫描顺序是按照索引的顺序
- range（走索引）：有范围的索引扫描，有范围限制，优于index，出现了range一定是基于了索引进行查询
- ref（走索引）：查询调节列使用了索引，而且不为主键和unique，即使使用了索引，但因为索引列的值不唯一，**不能立即停止**
- const（走索引）：表示将一个**唯一列**作为where的条件查询，会将其转化为常量，**效率高**
- eq_ref（走索引）：读取本表和关联表中的每行组合成的一行，按联表的主键或唯一键查询，**效率高**
- system：表只有一行记录，相当于系统表

> 效率：system/const > eq_ref > range/ref > index > all

>[如何利用工具，迅猛定位低效SQL？](https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651962587&idx=1&sn=d197aea0090ce93b156e0774c6dc3019&chksm=bd2d09078a5a801138922fb5f2b9bb7fdaace7e594d55f45ce4b3fc25cbb973bbc9b2deb2c31&mpshare=1&scene=1&srcid=&sharer_sharetime=1564102656434&sharer_shareid=7cd5f6d8b77d171f90b241828891a85f&key=c072b2c2faef4d9438b6f0b6badfe53fcf4db318fb2a87c291408a33555d137d4353da96dcb877b705e357a29afaa1479a898d0c98e72842de1bb41b2ff2a9c73a6131f5ce9fb58a76278f542f301b23&ascene=1&uin=MTAwMjA4NTM0Mw%3D%3D&devicetype=Windows+7&version=62060739&lang=zh_CN&pass_ticket=%2B86JlczuokhjGWtJYlXewkRQ80VvS7ZrhQjqxZGhalDK9QZVXHBjqvVIoMCl8QmU)

extra：
- Using where：SQL使用了where条件过滤数据
- Using index：SQL所需要返回的所有列数据均在一颗索引树上，无须回表访问实际的行记录（覆盖索引查询）
- Using index condition：确实命中了索引，但不是所有列数据都在索引树上，所以还需回表查询时机的行记录

## **2.1 使用自增id作为主键**

1. 如果使用较大的值作为主键，辅助索引叶子节点存放的是主键的值，则所占空间也将会增大

2. 如果插入数据是索引键有序的，数据可以直接插在索引树的最后面位置，即直接分配到最后的数据页，或新开一个数据页进行存储，效率更高；否则，会引入调整索引树的结构的复杂度，引起页分裂，消耗更多时间与资源

> [页分裂和页合并](https://zhuanlan.zhihu.com/p/98818611)都会导致索引的锁争用，在索引树上加写锁(x-latch)，在操作频繁的系统中将是隐患

## **2.2 减少回表**

    覆盖索引：索引包含所有需要查询的字段

二级索引根据索引键的值进行建立，如果我们查询字段没有加以提取，即使用“*”查询全部，那么在二级索引搜索到结点后，**需要回表**查询完整的行数据

当执行以下查询时（上述例子将构造一颗以`b`、`c`、`d`三者值的一颗索引树），效率较差：
```sql
EXPLAIN SELECT * FROM `demo` WHERE b = '3' AND c = '2' AND d = '1';
```

    type: ref
    key：index_test_b_c_d_index
    Extra: NULL

type：ref和key：index_test_e_index，证明使用到二级索引，但是因为查询的字段是全部，所以还得回表查询真正的行数据（Extra=NULL）

优化后的sql如下：
```sql
EXPLAIN SELECT `b` FROM `demo` WHERE b = '3' and c = '2' and d = '1';
```

    type: ref
    key: index_test_b_c_d_index
    Extra: Using index

Extra = Using index，不用回表了

## **2.3 增加索引匹配率（最左前缀匹配法则/索引下推）**

联合索引：

    多个字段联合起来建立索引，根据创建索引语句中字段的先后进行创立，如：`bcd`索引和`cbd`索引是两个索引

最左前缀匹配法则：

    匹配时从最左列开始，如果跳过了最左列，将无法使用到联合索引

所以建议查询从索引的最左列开始，不能跳过索引中的列

索引下推：

- "="：

    多个字段的值排序从**最左开始**进行匹配，当第一个字段相同时，再比较第二个字段的值，一直比较到最后一个字段的值，得出给定where应处在叶子结点的行位置，再进行扫描

- “>，<，>=，<=”：

    也是通过从**最左开始**进行匹配，比较规则根据where条件给定的范围符号进行判断

从左往右进行推断，从而选取最优的数据行进行遍历，提前减少匹配行数，减少回表次数，这种操作也被称为**索引下推**

> 用于解决5.6之前，联合索引满足最左前缀匹配，但是遇到非等值判断时匹配停止的问题

![索引下推的解释](https://asea-cch.life/upload/2021/08/%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%E7%9A%84%E8%A7%A3%E9%87%8A-0448432e65a94102a62a722682e36fb4.png)

```sql
SELECT * FROM `demo` WHERE b = 1 and c = 1 and d = 1;

SELECT * FROM `demo` WHERE c = 1 and d = 1;
```

第一条语句将使用到索引，因为可以根据bcd的联合索引的排序来进行查找；第二条语句因为没有指定b字段的值，那么索引顺序将c和d字段的查找没有任何帮助，直接走ALL全表扫描

该法则同样适用于范围查找和ORDER BY/GROUP BY，可以帮助后者减少临时表的创建


# question:

问：myisam和innodb都是用的B+树存数据，为什么myisam可以没有主键

答：其实innodb也可以没有主键，是一般建议有主键，因为聚簇索引存的是所有列数据，一般是查到主键ID，通过聚簇索引回表查到所有数据；
myisam的叶子节点存的是地址好像，树结构存的东西不一样

问：是不是聚簇索引不仅是包含主键索引的那一个B+树，还包含了其他的二级索引对应的B+树

答：不是，聚簇存的是所有行数据 ，普通索引存的是主键索引的值

# 参考
- [Cyc2018：Mysql](https://www.cyc2018.xyz/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL.html#%E4%B8%80%E3%80%81%E7%B4%A2%E5%BC%95)

# 重点参考
- [MySQL索引背后的数据结构及算法原理](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)
- [浅谈聚簇索引和非聚簇索引的区别](https://my.oschina.net/xiaoyoung/blog/3046779)
- [页分裂和页合并](https://zhuanlan.zhihu.com/p/98818611)

- [MySQL在有索引列情况下select *的输出结果顺序](https://blog.csdn.net/maray/article/details/8477612)

- [如何利用工具，迅猛定位低效SQL？](https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651962587&idx=1&sn=d197aea0090ce93b156e0774c6dc3019&chksm=bd2d09078a5a801138922fb5f2b9bb7fdaace7e594d55f45ce4b3fc25cbb973bbc9b2deb2c31&mpshare=1&scene=1&srcid=&sharer_sharetime=1564102656434&sharer_shareid=7cd5f6d8b77d171f90b241828891a85f&key=c072b2c2faef4d9438b6f0b6badfe53fcf4db318fb2a87c291408a33555d137d4353da96dcb877b705e357a29afaa1479a898d0c98e72842de1bb41b2ff2a9c73a6131f5ce9fb58a76278f542f301b23&ascene=1&uin=MTAwMjA4NTM0Mw%3D%3D&devicetype=Windows+7&version=62060739&lang=zh_CN&pass_ticket=%2B86JlczuokhjGWtJYlXewkRQ80VvS7ZrhQjqxZGhalDK9QZVXHBjqvVIoMCl8QmU)

- [关于MySQL种的in函数到底走不走索引、我和同事差点大打出手！](https://www.cnblogs.com/chengxuyuanxiaoyang/p/13801636.html)