# Redis高可用：主从复制/主备/集群

# **1. 主从复制**

架构：`一主多从`

关键指令：`SLAVEOF <host> <port>`

一主多从：通过`SLAVEOF`指令，让一台服务器去复制另一台服务器的状态，我们称被复制的服务器为`主服务器`，而对主服务器进行复制的服务器称为`从服务器`

Redis的复制(replicate)功能分为**两个**操作步骤，两者结合工作；
- 同步(sync)：从服务器主动拉

    > 用于将从服务器的数据库状态更新为主服务器所处的数据库状态，场景为：断线重连/初次连接

- 命令传播（command propagate）：主服务器主动推送
    
    > 主服务器的数据库状态被修改时，向从服务器发送变动，重新回到一致状态，场景为：主从连接健康，主服务器有新的写操作

## **1.1 同步**

旧版通过`SYNC`指令实现，指令步骤如下：

1. 从服务器向主服务器发送SYNC命令
2. 主服务器收到SYNC命令后开始执行BGSAVE命令，在后台生成一个RDB文件，并使用一个缓冲区记录从现在开始执行的所有写命令
3. 当主服务器的BGSAVE命令执行完毕后，发送到从服务器，从服务器载入文件后同步到RDB中主服务器的状态
4. 主服务器将在RDB文件生成期间的操作记录到缓冲区中，并在RDB文件发送完毕后再发送到从服务器执行，从服务器读取后将同步到主服务器的最新状态

> 同步的情况有两种：`初期复制`和`断线重连复制`，前者使用RDB文件复制无可厚非，但是后者可能数据变动极少，如果也一样用RDB进行同步，效率将十分低下

## **1.2 命令传播**

在从服务器和主服务器的同步执行完毕后，主从会暂时达到一致状态，但这个一致状态不是一成不变的，每当主服务器执行新的写操作时，主从又将回到不一致状态，这时候就需要`命令传播`机制

> 在Redis2.8后，写命令传播到从服务器的过程中，还会将这些命令写入到一个复制积压缓冲区中，这是为了实现接下来讲的新同步机制`PSYNC`

## **1.3 PSYNC**

新版（Redis2.8之后）通过`PSYNC`指令实现，为了解决SYNC在**断线重连**同步的低效率

指令格式：`PSYNC <runid> <offset>`

其中又分为两种同步场景：
- `完全重同步`：用于处理初次复制情况，执行步骤于`SYNC`命令的执行步骤基本一致，都是通过让主服务器后台创建和发送RDB文件，以及向从服务器发送保存在缓冲区内的写命令进行同步
- `部分重同步`：用于解决`SYNC`断线重连后的复制低效率情况，通过只发送`增量`的方式（与命令传播类似），减少需要同步的数据量，做到**只同步不一致的数据集**
    - 复制偏移量\<offset\>

        主服务器和从服务器都会维护一个复制偏移量，判断主从状态是否一致的方式就是：**判断主与从的复制偏移量是否相同**（如果从服务器断连则可能收不到同步数据）

        主服务器：每次向从服务器传播N个字节数据时，就往自己的复制偏移量加上N

        从服务器：每次收到主服务器传播来的N个字节数据时，同样为自己的复制偏移量加上N

    - 复制积压缓冲区

        维护一个固定长度的先进先出队列，保存着一部分最近主服务器**传播**的写命令
        
        PSYNC根据队列中是否存在**从服务器传过来的复制偏移量**，来选择使用完全重同步还是部分重同步

    - 主服务器ID(runid)
    
        从服务器会记录上一次同步成功的主服务器ID，在每次同步时都会向当前主服务器发送上次成功的服务器ID，若发送的ID与当前主服务器ID不一致，则采用完全重同步的方式

        当出现ID不一致情况，则说明从服务器一定与之前的主服务器断开连接，或是之前的主服务器出现了故障，这时候使用完全重同步较为安全保险

## **1.4 心跳监测**

命令格式：`REPLCONF ACK <replication_offset>`

用于完善`命令传播`阶段的机制，从服务器会以每秒1次的频率，向主服务器发送命令：
- 检测主从服务器的网络连接状态

    主服务器会记录从服务器的最好一次发送命令与当前时间的间隔（`lag`），正常在0到1秒内跳动

- 辅助实现min-slaves选项

    ```shell
    # 最少可写的从节点个数
    min-slaves-to-wrtie 3
    # 最大可写的延迟间隔
    min-slaves-max-lag 10
    ```

    通过`lag`和从节点的成功连接个数，主服务器决定是否执行写命令，这种方式可以防止主服务器在不安全的情况下执行写命令

- **检测命令丢失**

    > 如果因为网络问题，导致传播失败，且此时从服务器和主服务器并没有断开连接（触发PSYNC的部分重同步），这将导致主从不一致情况

    从服务器发送REPLCONF ACK心跳时，会带上当前自身的复制偏移量，如果发现复制偏移量出现不同，则主动推送到从服务器中，重新恢复一致状态

注意：整个过程中，一开始从服务器为主服务器的客户端，在同步阶段完成后（进入传播阶段），两者都互相是各自的客户端，可以相互主动推

## **1.5 总结**

在从服务器刚启动时，发送`PSYNC`命令对RDB和生成RDB期间的缓冲区数据进行复制，

在从服务器同步到最新状态后，主从通过`命令传播`的方式进行状态同步，并且期间根据心跳监测的方式来判断是否有`断线`或`传播失败`的情况：
- 断线：主服务器能感知，让从服务器重连上后自己使用PSYNC
- 传播失败：主服务器能感知，从服务器不能感知，通过从服务器在心跳上报的偏移量进行修正

# **2. Redis Sentinel**

Sentinel，又称为**哨岗/哨兵**，是Redis的高可用性的解决方案

作用：可以`监视`**多个主**服务器，以及这些主服务器**属下的所有从**服务器，并在被监视的**主服务器进行下线**状态时，自动将下线主服务器**属下的某个从**服务器升级为新的主服务器，然后由新的主服务器代替旧主服务器继续处理命令请求

> 主服务器下线时，从服务器会中止对主服务器的复制操作

Sentinel系统：指的是由一个或多个Sentinel共同组成的系统

## **2.1 Sentinel启动**

> Sentinel本质上只是一个运行在特殊模式下的Redis服务器，执行的工作和普通Redis服务不同，所以初始化过程和普通Redis服务器的初始化过程并不完全相同

启动单个Sentinel命令：
`redis-sentinel <config>`或`redis-server <config> --sentinel`

Sentinel启动过程中，需要执行以下步骤：
- 初始化服务器

    Sentinel不使用数据库，所以不会载入RDB文件或AOF文件

- 将普通Redis服务器使用的代码替换为Sentinel专用代码

    替换命令表，以及对配置的参数读取不同，所以Sentinel不能执行诸如SET、DBSIZE等等指令

    > Sentinel七个可执行指令：PING、SENTINEL、INFO、SUBSCRIBE、UNSUBSCRIBE、PSUBSCRIBE、PUNSUNSCRIBE

- 初始化Sentinel状态

    取而代之正常服务器的RedisServer结构，sentinel服务器会初始化一个`sentinel状态`的结构，保存所有和sentinel功能相关的功能

    ```c++
    struct sentienlState {
        // 当前纪元，用于实现故障转移
        uint64_t current_epoch;

        // 保存sentinel监视的主服务器字典，键为主服务器名字，值为指向sentinelRedisInstance结构的指针
        dict *masters;

        // 是否进入了TILT模式
        int tilt;

        // 目前正在执行的脚本数量
        int running_scripts;

        // 进入TILT模式的时间
        mstime_t tilt_strat_time;

        // 最后一次执行时间处理器的时间
        mstime_t previoust_time;

        // 一个FIFO队列，包含了所有需要执行的用户脚本
        list *scripts_queue;
    } sentinel;
    ```

- 根据给定的配置文件，初始化Sentinel的监视主服务器列表

    ```c++
    typedef struct sentinelRedisInstance {
        // 主服务器实例的地址
        sentinelAddr *addr;

        // SENTINEL down-after—milliseconds选项设定的值
        // 实例无响应多少毫秒后，才会被判断为主观下线
        mstime_t down_after_period;

        // SENTINEL monitor <master-name> <IP> <port> <quorum>选项中的quorum参数
        // 判断该实例为客观下线所需的支持投票数量
        int quorum;

        // SENTINEL parallel-syncs <master-name> <number>选项的值
        // 在执行故障转移时，可以同时对新的主服务器进行同步的从服务器数量
        int parallel_syncs;

        // SENTINEL failover-timeout <master-name> <ms>选项的值
        // 刷新故障迁移状态的最大时限
        mstime_t failover_timeout;
    } sentinelRedisInstance;
    ```

    sentinelRedisInstance.addr指向的结构，保存着实例的IP地址和端口号：
    ```c++
    typedef struct sentinelAddr {
        char *ip;
        int port;
    } sentinelAddr;
    ```

    以上的结构的最上层为sentinalState.master引用，当sentinel状态初始化时，也会引发对master字段的初始化，master字典的初始化则是**根据被载入的Sentinel配置**进行

- 创建连向主服务器的网络连接

    运行代码/监视列表等一系列状态初始化后，将会创建连向主服务器的网络连接，成为主服务器的客户端，可以向主服务器发送命令，并从命令回复中获取相关信息

    连接有两个：
    - 一个是`命令连接`，专门用于向主服务器发送命令，并接收命令回复
    - 另一个是`订阅连接`，专门用于订阅主服务器的`__sentile__:hello`频道

    > 

## **2.2 监视过程**

### **2.2.1 获取主服务器信息**

Sentinel默认会以`每十秒一次`的频率，通过`命令连接`向被监视的主服务器发送`INFO`命令：

```shell
# Server
...
run_id: xxxxxxxx
...

# Replication
role:master
...
slave0:ip=xxx,port=xxx,state=online/offline,offset=43,lag=0
slave1:...
slave2:...

# Other sections
...
```

通过分析INFO命令的回复来获取主服务器的当前信息：
- 获取主服务器本身信息，包括run_id域记录的服务器运行ID、role域记录的服务器角色
- INFO会返回关于主服务器属下的所有从服务器信息，Sentinel可以通过这些信息，**自动**发现从服务器

获取信息后，将更新到对应sentinel的sentinelRedisInstance结构上

### **2.2.2 获取从服务器信息**

发现有主服务器有新从服务器出现时，Sentinel除了会为该新从服务器创建相应实例结构外，还会创建两个连接到从服务器的`命令连接`和`订阅连接`

### **2.2.3 向主服务器和从服务器发送信息**

<!-- 疑问1：为什么要两个连接，发布订阅机制是什么？

疑问2：为什么都能通过主服务器信息获取从服务器信息，还需要再跟从服务器建立连接？ -->

## **2.3 故障转移**

# **3. Redis集群**

# 参考
- [集群和主从复制有什么关系和区别？](https://www.zhihu.com/question/34366991)