# Redis持久化

Redis是内存数据库，如果进程挂掉/机器断电，内存数据将全部丢失，所以需要将内存数据持久化到硬盘上

Redis提供了两种持久化模式：
- RDB：数据**快照**

- AOF：命令记录**日志**，类似binlog的`STATEMENT`格式

![启动加载持久化文件](https://asea-cch.life/upload/2021/08/%E5%90%AF%E5%8A%A8%E5%8A%A0%E8%BD%BD%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%87%E4%BB%B6-0f27481012914e46bf813c5f7187863d.png)

*图：redis进程启动时，对持久化文件选择的策略*

# **1. RDB**

定义：将进程某个时间点的**所有数据**都存放到硬盘上，保存到一个**RDB文件**中

触发方式：手动执行，或根据服务器配置定期执行

阻塞操作：使用SAVE命令生成RDB文件、RDB文件载入

## **1.1 RDB文件的创建与加载**

### **1.1.1 创建**

RDB文件是一个**经过压缩的二进制文件**，通过SAVE或`BGSAVE`指令进行生成

- SAVE：**阻塞**Redis服务器进程，直到RDB文件创建完毕位置，**阻塞期间服务器不能执行任何命令请求**
- `BGSAVE`：派生（fork）出一个子进程，由子进程创建RDB，服务器进程（父进程）**可以继续处理命令请求**

RDB文件生成由rdb.c/rdbSave函数完成，SAVE和BGSAVE会以不同的方式调用该函数进行RDB创建：

```python
def SAVE():
    rdbSave()

def BGSAVE():
    # 创建出子进程
    pid = fork()
    if pid == 0:
        # 子进程负责创建RDB文件
        rdbSave()
        # 完成之后向父进程传递信号
        signal_parent()
    elif pid > 0:
        # 父进程继续处理命令请求，并通过轮询等待子进程的信号
        hanle_request_and_wait_signal()
    else:
        # 处理出错情况
        handle_fork_error()
```

### **1.1.2 加载**

RDB载入在服务器**启动时自动执行**，没有专门用于载入RDB文件的命令

因为AOF文件的更新频率比RDB文件的更新频率高，所以存在以下流程，判断该用RDB还是AOF进行载入：
- 如果服务器开启AOF，优先使用AOF文件来还原数据库状态
- 只有在AOF处于关闭状态时，服务器才会使用RDB文件来还原数据库状态

> 服务器在载入RDB文件期间，会一直处于**阻塞状态**，直到载入工作完成为止

### **1.1.3 状态总结**

- 保存
    - SAVE：服务器阻塞，所有命令请求都会被拒绝

    - BGSAVE：后台执行，所以仍然可以处理客户端请求，但是在BGSAVE执行期间，需要区别对待SAVE、BGSAVE和BGREWRITEAOF这三个命令，以防止**同时执行**大量的写入操作

        1. 拒绝所有SAVE命令，因为BGSAVE和SAVE如果同时执行，会使得父进程与子进程同时执行两个rdbSave调用，出现竞态条件

        2. 拒绝所有BGSAVE命令，因为两个BGSAVE也会出现竞态条件

        3. BGREWRITEAOF和BGSAVE不能同时执行，如果已经在执行BGSAVE，则延迟后来的BGREWRITEAOF到前者执行完毕再执行

    - BGREWRITEAOF：后台执行AOF文件重写，在执行期间，直接拒绝BGSAVE、SAVE请求，因为**fork两个子进程是重量级操作，且还伴随大量写入操作，性能急剧下滑**

- 加载

    会一直处于**阻塞状态**，直到载入工作完成为止

## **1.2 自动间隔性保存**

### **1.2.1 设置保存周期**

用户可以通过设置配置的`save`选项，让服务器每隔一段时间自动执行一次`BGSAVE`命令

可以提供多个`save <时间间隔> <修改次数>`，只要其中任意一个条件被满足，服务器就会执行BGSAVE命令
以下是redis的默认条件：

```xml
save 900 1
save 300 10
save 60 10000
```

设置后，会将save的条件注入到redisServer结构中的`saveparams`属性上

```c++
struct redisServer {
    int dbnum;
    redisDb *db;
    // 记录了保存条件的数组
    struct saveparam *saveparams;
    // 修改计数器
    long long dirty;
    // 上一次执行保存的时间
    time_t lastsave;
}

struct saveparam {
    // 秒数
    time_t seconds; // <interval>
    // 修改数
    int changes; // <save_times>
};
```

接下来，服务器成功执行数据库修改命令后，对`dirty`属性进行递增更新；如果保存操作执行完毕，会更新`lastsave`属性，代表上次执行保存的操作时间

### **1.2.2 检查是否满足保存条件**

驱动：通过`serverCron`周期性操作函数，每隔**100ms**一次对正在运行的服务器进行维护

检查内容：serverCron其中一项工作就是检查save选项设置的保存条件是否已满足，是的话就执行BGSAVE

检查方式：遍历saveparams数组中的所有保存条件

## **1.3 RDB文件结构**

![rdb文件结构](https://asea-cch.life/upload/2021/08/rdb%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84-70297091e1184c2ab5d4d7181ec81262.png)

一个完整的RDB文件，包含了以下5个部分：
- REDIS
    - 大小：5字节
    - 内容："REDIS"5个字符，是常量
    - 用途：用于判断所载入的文件是否为RDB文件
- db_version
    - 大小：4字节
    - 内容：字符串，编码为整数
    - 用途：代表RDB文件的版本，如果为"0006"，则代表第六版RDB
- databases
    - 内容：包含多个数据库，以及库的键空间
    - 用途：数据库的数据状态，用于加载恢复
- EOF
    - 大小：1字节
    - 内容：常量
    - 用途：用于标记RDB文件正文内容的结束，当读入程序遇到EOF时，表示databases的数据已经加载完毕
- check_sum
    - 大小：8字节长
    - 内容：无符号整数，校验和，由REDIS、db_version、databases、EOF四个部分的内容计算得出
    - 用途：在载入RDB文件时，将载入数据所计算出的校验和与check_sum记录做对比，检查RDB文件是否出现损坏出错的情况

### **1.4 RDB的优缺点**

**RDB的优点**

- RDB是一个紧凑压缩的二进制文件，大小适中，载入速度较AOF块

- 非常适用于备份，全量复制等场景，比如每6小时执行bgsave备份，并把RDB文件拷贝到远程机器或者文件系统中（如hdfs），**用于灾难恢复**

**RDB的缺点**

- RDB没办法做到实时持久化/秒级持久化

    > 因为bgsave每次执行fork子进程，属于重量级操作，如果频繁执行则成本过高

- RDB文件使用特定二进制格式保存，Redis版本演进过程中有多个格式的RDB版本（db_version属性），存在老版本Redis服务无法兼容新版RDB格式的问题

**实践**

一般作为时间段的备份方案，同时开启AOF

# **2. AOF**

针对**RDB无法实时持久化**的问题，Redis提供了AOF持久化方式来解决

定义：AOF通过保存Redis服务器**执行的写命令**来记录数据库状态

触发方式：执行写命令

## **2.1 AOF的持久化和加载**

```
redis> SELECT 0
OK

redis> SET msg "hello"
OK
```

假设目前redis只有0号db有"hello"数据：

- RDB：将msg数据键值对保存到RDB文件中的databases属性上
- AOF：将SET执行命令保存到AOF文件中，**以Redis命令请求协议格式保存**

    > 直接打开AOF文件，可以直接看到**写**命令请求协议格式下的命令详情

### **2.1.1 持久化**

持久化功能的实现共有三个步骤：命令追加（append）、文件写入和文件同步（sync）

**1. 命令追加（append）**

服务器在**执行完一个写命令后**，会以协议格式将被执行的写命令，追加到**服务器状态的aof_buf缓冲区的末尾**

```c++
struct redisServer {
    // AOF缓冲区
    sds aof_buf;
};
```

可以看到aof_buf为sds类型，每次有新的写命令，都会将详情**追加**到字符串上

**2. 文件写入**

在服务器每次结束一个事件循环之前，都会调用flushAppendOnlyFile函数，考虑是否将aof_buf缓冲区中的内容写入和保存到AOF文件中

```python
def eventLoop():
    while True:
        # 处理文件事件，接收命令请求，以及发送命令回复
        processFileEvents()

        # 处理时间事件
        processTimeEvents()

        # 判断是否将aof_buf内容写入到AOF文件中
        flushAppendOnlyFile()
```

> Redis服务器进程就是一个事件循环（eventloop），以上伪代码为每一个事件的触发事件，涉及到：处理接收客户端请求/回复客户端，处理serverCron，以及目前介绍的aof文件写入

`flushAppendOnlyFile()`函数的行为由服务器配置的appendfsync选项的值来决定：
- alawys: 每次事件循环都将aof_buf缓冲区的所有内容写入到AOF文件，并进行同步
- eversec：将aof_buf缓冲区的所有内容写入到AOF文件。然后1秒/次，由专门的线程负责进行，如果上次AOF文件的事件距离当前超过1秒，则再次同步
- no：只写入文件，但不同步，同步由OS决定

**3. 文件同步（sync）**

<!-- # **持久化**

## **AOF**
AOF（append only file）持久化：**通过追加写命令到文件实现持久化**， 以独立日志的方式记录每次写命令， 重启时再重新执行AOF文件中的命令达到恢复数据的目的。AOF的主要作用解决了数据持久化的实时性，目前已经是Redis持久化的主流方式，类似于moongo等日志记录

- 所有的写入命令会追加到aof_buf（缓冲区）中
- AOF缓冲区根据对应的策略向硬盘做同步操作
- 随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的

如果每次写AOF文件命令都直接追加到硬盘，那么**性能完全取决于当前硬盘负载**。先写入缓冲区aof_buf中，还有另一个好处，Redis可以提供多种缓冲区同步硬盘的策略，在性能和安全性方面做出平衡。

## **阻塞场景**
持久化阻塞主线程场景有：fork阻塞和AOF追加阻塞。fork阻塞时间 跟内存量和系统有关，AOF追加阻塞说明硬盘资源紧张 -->

# 参考
- [Redis设计与实现]()
- [Redis持久化](https://www.jianshu.com/p/d3ba7b8ad964)