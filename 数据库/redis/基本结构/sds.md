# Redis结构：简单动态字符串

sds（simple dynamic string），中文名为简单动态字符串，Redis将其作为默认的字符串实现，而不使用C的字符串

redis包含字符串的键值对在底层都是用sds实现的

- 键值对的键是一个字符串对象，对象的底层实现是一个保存着键字符串的sds
- 键值对的值也是一个字符串对象，对象的底层实现是一个保存着值字符串的sds

# **1. 定义**

c字符串只用在某些无须对字符串进行修改的地方，如打印日志：
```c++
redisLog(REDIS_WARNING, "Redis is now ready to exit, bye bye...");
```
相比原始的c++字符串字符数组，sds封装了`len`长度, `free`未分配字节数，提高某些操作的效率

```c++
struct sdshdr {
    // 记录buf数组已使用字节的数量
    // 等于SDS所保存字符串的长度
    int len;
    // 记录buf数组中未使用字节的数量
    int free;
    // 字节数组，用于保存字符串
    char buf[];
}
```
- len：代表了SDS保存了一个`len`长度的字符串，该长度计算不包括空字符
- free：代表SDS的预分配空间，为0表示没有预分配空间
- buf：又称为字节数组，redis不是用这个数组来保存字符，而是用它来保存一系列`二进制数据`

为了使得sds也能像c字符串一样，兼容C字符串函数库中的函数，遵循了**以空字符结尾的惯例**，保存空字符的1字节不计入到len属性中

# **2. 优势（区别）**

可以认为是与C字符串相比的区别

## **2.1 获取字符串长度**

时间复杂度：O(1)，常数级

确保`STRLEN`指令/底层获取字符串长度的操作，不会成为redis操作的瓶颈

## **2.2 防止缓冲区溢出**

以字符串拼接操作为例（字符串变长）：

- c字符串：

    需要检查是否空间符合大小，不足则**手动扩展空间**，否则会导致内存中相邻的值被覆盖新增的字符串，这就称为缓冲区溢出

- sds：

    解决了缓冲区溢出问题

    使用sds的api对字符串进行修改时，会先检查sds的空间是否满足修改所需的要求，如果不满足的话，**API会自动将sds的空间扩展至执行修改所需的大小**，然后再执行实际的修改操作

## **2.3 减少修改字符串时的内存重分配次数**

也可以认为是减少内存复制的次数，C字符串的长度和底层数组长度有关联性，每次增加或删除一个字符，程序都需要对这个数组进行一次**内存重分配操作**

如果这种操作不频繁的话，每次修改都执行一次内存重分配是勉强可以接受的；但应综合redis的实际应用场景：

    redis作为内存数据库，经常被用于速度要求严苛，数据被频繁修改的场合，如果每次修改都需要重分配字符串，效率将急剧下降

sds通过未使用空间，实现`空间预分配`和`惰性空间释放`的方案进行优化，以期减少内存复制的次数

### **2.3.1 空间预分配**

针对**C字符串拼接时**的内存重分配的问题，sds使用`空间预分配`的思路优化：

> 当sds的api对一个sds进行修改，并且需要对sds的空间进行扩展时，不仅会为sds分配出字符串实际所需要的空间增量，还会对sds分配额外的**未使用空间**

额外的未使用空间通过以下公式获得：

- 如果sds修改后，长度将小于1MB，那么程序将分配和`len`属性同样大小的未使用空间

    len = free，buf.length = len + free + 1byte

- 如果sds修改后，长度将大于1MB，那么程序将分配1MB未使用空间，防止预分配过大

    len != free，buf.length = len + 1MB + 1byte

好处：大大降低了字符串重分配的次数，当新拼接的内容长度符合free大小时，无须重分配，这将从必定重分配N次优化为**最多重分配N次**

### **2.3.2 惰性空间释放**

针对**C字符串缩短时**的内存重分配问题，sds使用`惰性空间释放`的思路优化：

> 当sds的api需要缩短字符串长度时，程序不会立即回收这些多出来的字节，而是使用free属性将这些字节记录起来，并等待后续使用

好处：避免了缩短字符串时所需的内存重分配操作，并为后续的拼接增长提供了优化空间

    sds的api提供释放free功能，当内存不够用时，可以通过api释放掉这些惰性空间

## **2.4 二进制安全**

C字符串中的字符必须符合某种编码，并且除了末尾外，其它地方不能包含空字符，否则会导致程序读入错误，这些限制使得c字符串只能保存文本数据

redis可以适用于各种不同使用场景，sds的api都是二进制安全的，会**以处理二进制的方式来处理sds存放在buf数组中的数据**

> 可以称sds的字符数组为**字节数组**的原因，它并不是用这个数组保存字符，而是用它来保存一系列二进制数据

# **3. 字符串值类型**

Redis以字符串的形式存储所有内容，包括数值类型/二进制类型

而比如INCR这样的操作，需要经历以下操作：

1. 将字符串的值解析为C中的int类型

2. 对值进行原子递增操作

3. 转换为字符串类型，对客户端进行返回

# 参考
- [Redis设计与实现]()
- [字符串和SDS](https://blog.csdn.net/qq193423571/article/details/81637075)
- [Redis是否只允许字符串表示而不允许数字值](https://www.jb51.cc/spring/129351.html)

