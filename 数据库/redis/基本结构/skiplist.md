# Redis基础结构：skiplist

跳跃表是一种**有序**的数据结构，它通过在**每个节点中维持多个指向其它节点的指针**，从而达到快速访问节点的目的，是一种**空间换时间的策略**

时间复杂度：平均情况*O(logN)*，最坏情况*O(N)*

> 效率可以与平衡树媲美(跳表稍逊一筹)，但跳表的实现复杂度远远低于平衡树，所以不少程序使用跳跃表代替平衡树

优势：
- 不俗的查找效率
- 节点按`分值(score)`有序排列，可以通过顺序性操作来批量处理节点
- `双向`

Redis使用跳表的场景较少：
- 在集群节点中用作内部数据结构
- **作为有序集合类型键的底层实现之一**

# **1. 定义**

## **1.1 跳表理解**

**1. 为什么要有跳表**

链表不像有序序列具备随机访问性，不能直接使用二分法来进行查找。所以将链表改造为跳表，并通过索引来进行快速查找，跳表可以认为是：**有序链表和二分法的结合**

**2. 跳表的结构**

- 空间

    有序的底层双向链表 + 3维链表：3维指节点拥有随机高度，相同高度节点的前进指针可以串起来更高维度的**单向链表**（这些高维度的**链表**被认为是底层链表的子集），它们共同组成了跳表

- 实现

    有序底层双向链表 + 多级索引，通过索引来实现快速查找

## **1.2 跳表节点**

```c++
typedef struct zskiplistNode {
    // 层数结构
    struct skiplistLevel {
        // 前进指针
        struct zskiplistNode *forward;
        // 跨度
        unsigned int span;
    }level[]; // 层数（等级）数组
    
    // 后退指针
    struct zskiplistNode *backward;

    // 分值（值可相等）
    double score;
    
    // 键对应成员对象（唯一）
    robj *obj;
}zskiplistNode;
```

1.  层（节点在跳表中的层信息）

    节点生成时，会为其分配随机的最高层数（`1至32之间的随机数`），并以此初始化层数数组长度。如果节点最高层数为N，则跳表中的第1层~第N-1层必定有这个节点
    
    - 前进指针

        节点的每个层信息都有指向表尾方向的下一节点指针，这个指针就是前进指针（level[i].forward属性），跳表的高效率查找就是通过该指针实现的

    - 跨度

        用于记录当前节点跳跃到前进指针指向节点的距离，**指向NULL节点的跨度为0**

        > 注意：跨度与遍历操作并没有实际关系，常用来计算当前节点排位位置。在查找目标节点过程，将沿途路过的所有层跨度累计起来，就是目标节点

2. 后退指针

    用于从表尾向表头方向访问节点。每个节点只有一个后退指针，每次只能后退至前一个节点，可以认为其实现最底层链表的`双向`遍历

3.  分值和成员

    - 分值score

        double类型浮点数，用于确定节点在跳表中的位置，默认按分值**从小到大**排序，分值可相同

    - 成员obj

        指向一个字符串对象，对象保存着一个sds值，对象在跳表中唯一

注意：**表头结点拥有所有level，从第1层到第32层，所以不保存键属性和分值，作为遍历/查找的起始位置**

## **1.3 跳表**

跳表由多个跳表节点组成，redis通过zskiplist来持有某些节点和信息，程序就可以更方便地对整个跳表进行处理

```c++
typedef struct zskiplist {
    // 表头节点，表尾节点
    structz skiplistNode *header, *tail;

    // 表中节点个数
    unsigned long length;

    // 表中层数最大的节点的层数
    int level;
}zskiplist;
```
- header指针：指向跳跃表的表头节点
- tail指针：指向跳跃表的表尾节点
- length长度：记录节点数量，O(1)时间复杂度获得跳表的长度
- level最大高度：记录层高最大的节点的层数量，O(1)时间复杂度获取，**不包括表头结点的最大层数**

> 以三维立体视角观察跳表，每一层的水平方向都是一个链表，越高层的链表节点越少

# **2. API**

查找、添加和删除结点操作

## **2.1 查找元素**

跳表其实就是有序底层双向链表 + 多级索引，是一种可以进行`二分查找`的有序链表

方法：从最高级索引上查找**最后一个小于**当前查找元素的位置，然后再跳到次高级的索引继续查找，直到跳到最底层为止

    通过索引可以一次跳过多个不满足的元素，所以查找速度就变快了

查找方向：从表头结点层数中，有指针指向并且层数最高的结点开始；每个结点都从其**最高层向下**，并逐步**往表尾方向推进**

```java
public Node<E> get(int score) {
    Node<E> c = head;
    while (c != null) {
        if (c.data == score) {
            return c;
        } else if (c.next == null) {
            // 右侧没有结点，向下推进
            c = c.down;
        } else if (c.next.data > score) {
            // 右侧大于目标值，向下推进
            c = c.down;
        } else {
            // 向右推进
            c = c.next;
        }
    }
}
```

## **2.2 添加元素**

方法：通过跳表的查找方法，根据**值大小排序**找到新增元素应在位置，并调整索引

- 传统调整索引：每次添加都需要删除原先的索引，并重新生成来调整跳表的索引，性能差得不偿失

    - 时间复杂度：O(N)

- 解决方法：`随机数法`，每插入一个新节点，其最大层数在`1-32之间的数`随机，以正态分布调整索引
    - 时间复杂度：O(1)
    - 算法：随机根据当前索引的**50%的概率上升得到更上级的索引**，即保证**生成越高层数的概率越低**

> 索引的理想情况：每级索引的个数是下一级索引节点个数的一半

```java

```

## **2.3 删除元素**

方法：通过跳表的查找方法找到删除元素，并从找到位置开始的每一层，一路向下删除和调整前后指向

# 参考
- [Skiplist的原理与使用](https://blog.csdn.net/baijiwei/article/details/82872334)
- [Redis设计与实现]()
- [跳表详解](https://zhuanlan.zhihu.com/p/342410015)