# Redis线程模型

<!-- # **模型**
单线程，因为Redis主要为内存存储介质，shell更多是操作服务器的内存，CPU并不是Redis的瓶颈。

采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。

采用多路复用I/O模型，通过select（无差别轮询）, poll（忙轮询，用户数组存储到内核链表，无连接数限制）, epoll（事件驱动）监察多个I/O流。与阻塞I/O模型类似，会阻塞掉I/O操作的两个阶段：
- 准备数据阶段
- 将内核数据(kernel)拷贝到用户内存

但多路复用可以等待多个数据包就绪，即可以处理多个连接，当某一路的数据准备就绪时，开始I/O操作。（与非阻塞I/O不同的是，非阻塞I/O不会直接阻塞掉用户进程，用户进程需要反复询问kernel数据）

![clipboard.png](https://segmentfault.com/img/bVbgA3t) -->

# **1. 事件**

Redis服务器本质上是一个**事件驱动**程序，服务器需要处理以下两种事件：
- 文件事件(file event)
- 时间事件(time event
- 其他事件：aof日志追加等等

## **1.1 文件事件**

定义：文件事件就是服务器对**客户端套接字的抽象**，服务器与客户端的通信会产生相应的**文件事件**，服务器通过监听并处理这些事件，来完成一系列网络通信操作

模式：Reactor模式



# 参考
- [dackh-I/O模型总结](https://github.com/dackh/blog/blob/master/IO%E6%A8%A1%E5%9E%8B.md)
- [Redis入门指南]()
- [阻塞、非阻塞、多路复用等I/O模型](https://www.jianshu.com/p/b8203d46895c)