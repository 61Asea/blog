# Redis线程模型

<!-- # **模型**
单线程，因为Redis主要为内存存储介质，shell更多是操作服务器的内存，CPU并不是Redis的瓶颈。

采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗 CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。

采用多路复用I/O模型，通过select（无差别轮询）, poll（忙轮询，用户数组存储到内核链表，无连接数限制）, epoll（事件驱动）监察多个I/O流。与阻塞I/O模型类似，会阻塞掉I/O操作的两个阶段：
- 准备数据阶段
- 将内核数据(kernel)拷贝到用户内存

但多路复用可以等待多个数据包就绪，即可以处理多个连接，当某一路的数据准备就绪时，开始I/O操作。（与非阻塞I/O不同的是，非阻塞I/O不会直接阻塞掉用户进程，用户进程需要反复询问kernel数据）

![clipboard.png](https://segmentfault.com/img/bVbgA3t) -->

# **1. 事件**

Redis服务器本质上是一个**事件驱动**程序，服务器需要处理以下两种事件：
- 文件事件(file event)
- 时间事件(time event
- 其他事件：aof日志追加等等

## **1.1 文件事件**

定义：文件事件就是服务器对**客户端套接字的抽象**，服务器与客户端的通信会产生相应的**文件事件**，服务器通过监听并处理这些事件，来完成一系列网络通信操作

模式：Reactor模式

1. kernel准备数据
2. 将kernel缓冲区的数据拷贝到用户进程中

同步IO：第二步出现阻塞的，就是同步IO
异步IO：两步都不会阻塞的，就是异步IO

阻塞IO：调用后，会一直block到操作结束的IO

非阻塞IO：kernel准备数据过程中不会阻塞，可以立即返回的IO

5大IO模型：
- 同步阻塞IO
- 同步非阻塞IO（同步非阻塞I/O，第二个过程会阻塞）
- IO多路复用（基于选择器的同步非阻塞I/O，同样第二个过程会阻塞）
- 信号驱动IO（基于信号驱动，第二个过程同样会阻塞，属于同步IO）
- 异步IO（异步非阻塞I/O，两个过程都不阻塞）

- 同步IO：IO调用期间会被BLOCK住的，都算同步IO。所以阻塞IO一定是同步IO
    - 同步阻塞IO：在调用IO会一直block住
    - 同步非阻塞IO：在kernel准备数据的阶段中，可以返回，但是在kernel将数据复制到用户进程时会阻塞
- 异步IO：一定也是非阻塞IO

epoll rbr和rdlist

# 参考
- [dackh-I/O模型总结](https://github.com/dackh/blog/blob/master/IO%E6%A8%A1%E5%9E%8B.md)
- [Redis入门指南]()
- [阻塞、非阻塞、多路复用等I/O模型](https://www.jianshu.com/p/b8203d46895c)