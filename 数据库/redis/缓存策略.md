# Redis缓存

> [Redis持久化](https://asea-cch.life/achrives/redis持久化)

当开启持久化时，作为数据库使用。不开启持久化时，作为高效的缓存方案

# **1. 缓存配置**

作为缓存服务器，不加以**限制内存**会出现整台服务器内存被耗光的情况，通过以下思路进行限制保护：
- **配置缓存内存限制和清理策略**
- **关闭持久化**
- 可选项：增加ip绑定、指定客户端连接数量、考虑主从模式

具体配置：
```shell
# 限定redis的最大内存使用量
maxmemory 1536mb

# 指定缓存淘汰算法
maxmemory-policy allkeys-lru

# 配对lru算法配置
maxmemory-samples 5

# 只做缓存服务器，所以关闭持久化
save ""
```

## **1.1 maxmemory**

- =0：表示缓存的数据量没有限制
- \>0：超过该数据时，将触发数据淘汰

设置`maxmemory`的值为物理内存的`3/4或更小`较为合适，牺牲掉一部分内存的原因：
    
> redis复制数据等其他功能也需要使用内存空间，以防缓存数据过大导致redis崩溃

先预测好系统所需要的内存高峰，部署相对应内存的缓存服务器，保证整体系统可用性

## **1.2 maxmemory-policy（缓存置换算法）**

当redis内存使用量达到了`maxmemory`时，redis会选择设置好的`maxmemory-policy`对老数据进行置换

置换策略有如下6种：
- `noeviction`：即使内存达到上限也不进行置换，所有能引起内存增加的命令都会返回error

- all-key：全量数据，从全部的key中选择删除

    - `allkeys-lru`：lru算法
    - `allkeys-random`：随机算法

- volatile：部分数据，从设置了ttl的key中选择删除
    > 如果没有设置ttl的键，以下三种策略和`noeviction`策略一样，不会对任何key置换。这就有可能导致无法淘汰出足够多的空间

    - `volatile-lru`：lru算法
    - `volatile-random`：随机算法
    - `volatile-ttl`：ttl最小的key

### **近似LRU算法**

> [真实LRU](https://asea-cch.life/achrives/lru)

底层结构：`双向链表`

实现思路：出于**节省内存和提升性能**的考虑，Redis的LRU算法**并非完整实现**，采用近似LRU的算法，通过**对少量键进行取样**，从中选择最久未被访问的键进行回收

采样精度（数量）：通过`maxmemory-samples`设置取出数目key

Redis3.0的具体实现：

1. 提供一个待淘汰候选key的`eviction pool`，里面默认有16个key，按照`idle_time`排好序
2. 当内存空间不足时，更新Redis后会从键空间选取`maxmemory-samples`数目key，分别计算它们的idle_time，以此作为依据更新到eviction pool中
    > key在pool不满时，或idle_time大于pool里最小的idle_time时，才会进入pool
3. 从pool中选择空闲时间最大的key淘汰掉

优势（2.8的问题）：2.8并没有将多次选择的结果进行保存，这使得每次新随机选取的key，其idle_time比历史随机选取过的还要新，却被淘汰，导致结果不接近真正的LRU实现

### **算法选择场景**

置换算法没有优劣之分，只有适不适合场景，取决于**应用访问模式**，可以通过`INFO`命令输出cache的命中率情况，进而对置换算法进行调优：

- allkeys-lru：不确定使用哪种策略，或幂次分布（所有key都是最近最经常使用）

- allkeys-random：平等分布（所有key的访问概率差不多）

- volatile-ttl：对数据有足够了解，能够通过expire/ttl为key指定hint，并且缓存对象的ttl值最好有差异

- volatile-lru / volatile-random：单redis实例来同时实现cache和持久化

    未设置过期时间的键进行持久化保存，设置了过期时间的键参与缓存淘汰

## **1.3 置换工作流程**

1. 客户端执行一条写命令，导致数据库需要新增数据
2. Redis检查内存占用，如果内存超过maxmemory，就按照策略删除一些key
3. 删除后，执行写命令，并返回

可以看出，置换的流程属于**被动触发**，一般情况下置换策略会将内存的使用率降低到`maxmemory`以下

如果一次需要使用很多的内存（一次写入很大的数据），那么Redis的真实内存大小可能会超过`maxmemory`限制一段时间

# **2. 使用场景**

# **3. 双写一致性**

# 参考
- [Redis只作为缓存，不做持久化的配置](https://www.cnblogs.com/l1pe1/p/7873725.html)
- [缓存与数据库双写一致性问题](https://blog.csdn.net/qq_33135813/article/details/91352093)

# 重点参考
- [Redis 缓存过期（maxmemory） 配置/算法 详解](https://www.cnblogs.com/52php/p/6171172.html)
- [Redis中的LRU淘汰策略分析](https://www.cnblogs.com/linxiyue/p/10945216.html)
- [经典面试题：如何保证缓存与数据库的双写一致性？](https://zhuanlan.zhihu.com/p/66462064)
- [Redis双写一致：穿击、穿透、雪崩、污染](https://zhuanlan.zhihu.com/p/384826352)