# Redis类型键：zset

> zset和set的重要区别在于前者有序且支持范围操作，后者无序，更深层次的原因在于双方底层结构的不同

## **编码方式**

有序集合对象的编码可以是`REDIS_ENCODING_ZIPLIST`或者`REDIS_ENCODING_SKIPLIST`，这句话等价于：列表对象的底层实现可以是`ziplist`或者`skiplist`

- 当使用ziplist作为zset键的底层结构时，每个集合元素使用**两个紧密相邻**的entry来存储

    第一个entry保存的是元素的成员obj（member），第二个entry保存的是元素的分值（score）

    > 有序集合默认按**从小到大**进行排序，分值越小的元素越靠近表头的方向

- 当使用skiplist作为zset键的底层结构时，使用zset结构作为底层实现

    ```c++
    typedef struct zset {
        zskiplist *zsl;
        dict *dict;
    }zset;
    ```

    zset同时维护一个字典和一个跳跃表，其中：

    - 跳表：按分值从小到大保存了所有集合元素，跳表节点的object属性保存了元素的成员，score属性保存了分值

        > 通过跳表结构，我们可以对有序集合进行范围型操作：`ZRANK`，`ZRANGE`

    - 哈希表：为有序集合创建了从成员到分值的映射，键保存成员，值保存分值

        > 通过hashtable，可以O(1)复杂度查找给定成员的分值：`ZSCORE`

zset元素的成员和值是字符串对象，只是分值在对比时会转换long double类型的浮点数，这个只在过程中进行转换

### **同时维护跳表和字典的优势**

字典的缺点：`无序`，无法进行排序

跳表的缺点：`O(logN)时间复杂度查找`

同时维护两个结果，取长补短，zset可以实现以下特征：

1. 有序，支持范围操作

2. O(1)时间复杂度获取成员对应分值

3. 插入时，两种数据结构都有较为不错的效率：
    - skiplist得益于索引跳跃，可以较快找到插入位置，且链表的修改成本低
    - hashtable哈希化使用位运算，效率高，找到桶节点后直接插入到桶链表尾

4. 删除时，skiplist的删除与插入的效率基本一直，而hashtable可能需要遍历桶链表

## **编码转换**

当有序集合同时满足以下两个条件时，会使用ziplist编码：
- 集合的元素个数不超过128个
- 每个元素**成员的长度**都小于64字节

## **API**

# 参考
- [Redis设计与实现]()