# Redis

这篇总结Redis基础功能的实现：
- Redis的数据库是如何存储的
- 键的生命周期，包含了：生存时间、删除策略、过期键持久化和同步
- 后续补充...

# **1. 数据库存储与实现**

## **1.1 服务器/客户端结构**

`redis.h/redisServer`的db数组中，每一项都是一个redisDb结构，一个redisDb代表一个数据库

在初始化服务器时，程序会根据`dbnum`属性来决定初始化数组容量 -> 创建对应个数的数据库，默认该选项的值为16个，由服务器配置的database选项决定

```c++
// redis服务器结构
struct redisServer {
    // ...

    // 服务器的数据库数量
    int dbnum;

    // 一个数组，保存着服务器中的所有数据库
    redisDb *db;
};
```

我们在使用shell命令`SELECT [num]`选择数据库后，redis客户端结构中的db指针，将会指向到服务器`db数组`下标的**数据库结构**

```c++
// redis客户端结构
typedef struct redisClient {
    // ...

    // 记录客户端当前正在使用的数据库
    redisDb *db;
} redisClient;
```

![redisServer&redisClient](https://asea-cch.life/upload/2021/08/redisServer&redisClient-f91bebeab4464c29b6e860c8bcbfe69d.png)

## **1.2 数据库结构**

数据库本身使用`dict`字典实现，dict保存了用户存储的所有键值对，我们称这个dict为键空间（`key space`）：

- key space中的各个键，即数据库的键，都是一个字符串对象
- key space中的各个值，即数据库的值，每个值可以是5种对象的任意一种

```c++
// redis数据库结构
typedef struct redisDb {
    // ...

    // 数据库键空间，保存着数据库中的所有键值对
    dict *dict;
} redisDb;
```

图为存有三个键值对的数据库：

![db](https://asea-cch.life/upload/2021/08/db-29644952bceb4f2dbb5226f0092bf18e.png)

所有针对数据库的操作的具体实现可以参照**hashtable操作**

## **1.3 读写操作时的维护操作**

处理用户对redis键空间的读写操作时，还会执行一些额外的操作

1. 计算缓存命中率

    处理读请求时，根据键是否存在来更新服务器的`命中次数(hit)`或`不命中次数(miss)`，记录缓存命中率

2. **更新LRU时间**

    除开`OBJECT IDLETIME`指令外，其他指令对键做操作时都会更新键的LRU时间，这个涉及到缓存淘汰策略或过期策略

3. **过期键的被动触发**

    处理读请求时，如果键已经过期，那么服务器会先删除这个过期键，再执行余下的操作

    > 假设服务器为AOF持久化模式，还会追加一条DEL message命令到AOF文件

4. **WATCH监视键**

    与事务相关，如果键被某个客户端使用`WATCH`命令监视，当键值发生变动时会将键标记为脏，从而让事务程序感知到该键已经被修改

5. **脏页计数**

    与**持久化**和**主从复制**相关，当键被修改后，会对脏键计数器递增1，这个计时器会触发服务器的持久化和主从复制

6. 数据库通知功能

    如果服务器开启了数据库通知功能，对键修改后，服务器将按配置发送相应的数据库通知

# **2. 键的生存周期**

![redis键的生存周期](https://asea-cch.life/upload/2021/08/redis%E9%94%AE%E7%9A%84%E7%94%9F%E5%AD%98%E5%91%A8%E6%9C%9F-f19cf7b05d5d4b1ca9cf976ae8788637.png)

TTL：全称Time To Live，通过命令，客户端将以秒或毫秒精度为数据库中的某个键设置生存时间，每个键都有生存时间，在经过指定的秒数或者毫秒数之后，服务器就会自动/惰性删除生存时间为0的键

> 默认没有设置的话，TTL为-1，表示永不过期。TTL设置为-1后不代表一定永久存在，因为还存在redis的内存占用达到maxmemory阈值，且满足缓存淘汰策略，被其他新的键置换掉

```c++
typedef struct redisDb {
    // ...
    // 键空间
    dict *dict
    // 键空间对应的过期字典
    dict *expires;
} redisDb;
```

## **2.1 过期时间相关操作**

### **设置过期时间**

expires字典保存了数据库中所有键的过期时间：
- 键是一个**指针**，指向了键空间中的某个键对象
- 值是一个long long类型的整数，保存了过期时间（毫秒精度）

通过以下的命令都可以设置过期时间，前三个命令最终都会转换为最后的命令`PEXPIREAT`：
- `EXPIRE <key> <ttl>`：将key的生存时间设置为当前时间 + ttl（秒）
- `PEXPIRE <key> <ttl>`：将key生存时间设置为当前时间 + ttl（毫秒）
- `EXPIREAT <key> <timestamp>`：将key生存时间设置为timestamp（秒级）
- `PEXPIREAT <key> <timestamp>`：将key生存时间设置为timestamp（毫秒级）

### **移除过期时间**

可以使用`PERSIST`在过期字典中查找给定的键，并解除键在过期字典中和过期时间的管理，可以认为是`PEXPIREAT`的反向操作

### **获得剩余时间**

`TTL`：返回以秒为单位的键剩余生存时间

`PTTL`：返回以毫秒为单位的键剩余生存时间

以上两个命令通过：计算键的过期时间 - 当前时间，计算并返回键的剩余生存时间判定

## **2.2 过期键删除策略**

通过以下步骤判定一个键是否过期：

1. 检查给定键是否存在于过期字典，如果存在，那么获得该键的过期时间

2. 检查当前UNIX时间戳是否大于键过期时间，如果是，那么键已经过期

### **常用的过期删除策略**

如果键已经过期，那么它可以通过**三种不同的删除策略**进行删除：

**1. 定时删除**
- 做法：在**设置键的过期时间的同时**，创建一个定时器（timer），让定时器在键的过期时间来临时，**立即执行**对键的删除操作

- 方式：主动删除
- 时机：设置键ttl时
- 优点：对**内存友好**，可以及时删除过期键，释放内存
- 缺点：
    - 对**CPU时间不友好**，在过期键较多的情况下，删除过期键这一操作会耗费大量的CPU，在内存不紧张但CPU紧张的场景下，无疑对服务器的吞吐量和响应时间造成影响
    
    - 定时器需要用到Redis的**时间事件**，实现方式为无序链表，查找一个事件的时间复杂度为O(N)，这意味着不能高效地处理大量时间事件

**2. 惰性删除**
- 做法：**放任键过期不管**，但是每次从键空间中**获取键时，检查取得的键是否过期**，如果过期的话，就删除该键；如果没有过期，就返回该键

- 方式：被动删除
- 时机：获取键时
- 优点：对**CPU时间友好**，只有在取出键的时候才进行过期检查，删除的目标也仅限于当前操作的键
- 缺点：对**内存不友好**，如果有大量的冷数据过期键，它们将长时间停留在数据库中，只要没有被操作到，所占用的内存就不会释放，甚至可以视为一种内存泄漏（除非主动调用FLUSHDB操作）

**3. 定期删除**
- 做法：每隔一段时间，就对数据库进行一次检查，删除里面过期的键，至于删除多少过期键，和检查多个数据库，由算法决定

- 方式：主动删除
- 时机：每隔一段时间，时间可配置
- 优点：对`定时删除`和`惰性删除`两种策略的一种整合和折中，通过限制删除数量和删除执行频率减少对CPU时间的影响，同时减少内存浪费
- 缺点：难以确定`执行时长（删除数量）`和`频率`，如果太频繁或执行时长过长，又退化成了定时删除策略；反之退化为惰性删除

### **Redis怎么做**

Redis服务器：同时使用`惰性删除`和`定期删除`两种策略，以在CPU时间和内存占用上取得平衡

1. Redis的惰性删除实现：每个被访问的键如果过期，则被`expireIfNeeded`函数删除
    
    所以每个命令的实现函数应能同时处理**键存在和不存在**的两种情况：
    - 键存在，正常执行

    - 键不存在，按照键不存在的情况执行，正常是**返回空回复**

2. Redis的定期删除实现：周期性操作`serverCron`函数，在规定时间内，**分多次遍历**服务器中的各个数据库，从expires字典中**随机**检查一部分键的过期时间

> 结合惰性删除策略，可以大大提升定期删除对执行时长和频率配置的容错性

## **2.3 持久化/主从同步对过期键的处理**

RDB/AOF持久化，以及复制功能需要对过期键进行相应处理，才能保证各自的功能模块不受影响

### **RDB**

保存：
执行SAVE命令或BGSAVE命令创建一个新的RDB文件时，会对数据库中的键进行检查，**已过期的键不会被保存到新创建的RDB文件**中

载入：
按服务器的运行模式处理过期键

- 主服务器模式

    未过期的键会从RDB文件被载入到数据库，已过期则忽略

- 服务器模式

    所有键都会被加载，无论是否过期

### **AOF**

写入：
不会因为过期键产生影响，当过期键被`惰性删除`或`定期删除`时，往AOF文件内追加一条DEL命令，来显式记录该键已被删除

重写：
与RDB的保存思路类似，在执行AOF重写时，已过期的键不会被保存到重写后的AOF文件中

加载：
按照AOF文件载入后，恢复到某一数据库状态，所以无论是否过期，都会被加载

### **复制**

> 主从复制模式下，从服务器的过期键删除动作由主服务器控制！！！

- 主服务器在删除一个过期键后，会显式地向所有从服务器发送一个DEL命令，从服务器接受到后才真正的删除过期键

- 从服务器的键即使到了过期时间，也不会主动将键删除，除非主服务器进行复制同步

    在没有通知之前，从服务器对客户端过期键的访问，以正常键的方式进行处理

很明显地，这种方式保证了主从服务器数据的**最终一致性**，但是做不到强一致

# 参考
- [Redis设计与实现]()