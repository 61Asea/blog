# Redis

这篇总结Redis基础功能的实现：
- Redis的数据库是如何存储的
- 键的生命周期，包含了：生存时间、删除策略、过期键持久化和同步
- redis运转的根本：redis事件机制
- 后续补充...

# **1. 数据库存储与实现**

## **1.1 服务器/客户端结构**

`redis.h/redisServer`的db数组中，每一项都是一个redisDb结构，一个redisDb代表一个数据库

在初始化服务器时，程序会根据`dbnum`属性来决定初始化数组容量 -> 创建对应个数的数据库，默认该选项的值为16个，由服务器配置的database选项决定

```c++
// redis服务器结构
struct redisServer {
    // ...

    // 服务器的数据库数量
    int dbnum;

    // 一个数组，保存着服务器中的所有数据库
    redisDb *db;
};
```

我们在使用shell命令`SELECT [num]`选择数据库后，redis客户端结构中的db指针，将会指向到服务器`db数组`下标的**数据库结构**

```c++
// redis客户端结构
typedef struct redisClient {
    // ...

    // 记录客户端当前正在使用的数据库
    redisDb *db;
} redisClient;
```

![redisServer&redisClient](https://asea-cch.life/upload/2021/08/redisServer&redisClient-f91bebeab4464c29b6e860c8bcbfe69d.png)

## **1.2 数据库结构**

数据库本身使用`dict`字典实现，dict保存了用户存储的所有键值对，我们称这个dict为键空间（`key space`）：

- key space中的各个键，即数据库的键，都是一个字符串对象
- key space中的各个值，即数据库的值，每个值可以是5种对象的任意一种

```c++
// redis数据库结构
typedef struct redisDb {
    // ...

    // 数据库键空间，保存着数据库中的所有键值对
    dict *dict;
} redisDb;
```

图为存有三个键值对的数据库：

![db](https://asea-cch.life/upload/2021/08/db-29644952bceb4f2dbb5226f0092bf18e.png)

所有针对数据库的操作的具体实现可以参照**hashtable操作**

## **1.3 读写操作时的维护操作**

处理用户对redis键空间的读写操作时，还会执行一些额外的操作

1. 计算缓存命中率

    处理读请求时，根据键是否存在来更新服务器的`命中次数(hit)`或`不命中次数(miss)`，记录缓存命中率

2. **更新LRU时间**

    除开`OBJECT IDLETIME`指令外，其他指令对键做操作时都会更新键的LRU时间，这个涉及到缓存淘汰策略或过期策略

3. **过期键的被动触发**

    处理读请求时，如果键已经过期，那么服务器会先删除这个过期键，再执行余下的操作

    > 假设服务器为AOF持久化模式，还会追加一条DEL message命令到AOF文件

4. **WATCH监视键**

    与事务相关，如果键被某个客户端使用`WATCH`命令监视，当键值发生变动时会将键标记为脏，从而让事务程序感知到该键已经被修改

5. **脏页计数**

    与**持久化**和**主从复制**相关，当键被修改后，会对脏键计数器递增1，这个计时器会触发服务器的持久化和主从复制

6. 数据库通知功能

    如果服务器开启了数据库通知功能，对键修改后，服务器将按配置发送相应的数据库通知

# **2. 键的生存周期**

![redis键的生存周期](https://asea-cch.life/upload/2021/08/redis%E9%94%AE%E7%9A%84%E7%94%9F%E5%AD%98%E5%91%A8%E6%9C%9F-f19cf7b05d5d4b1ca9cf976ae8788637.png)

TTL：全称Time To Live，通过命令，客户端将以秒或毫秒精度为数据库中的某个键设置生存时间，每个键都有生存时间，在经过指定的秒数或者毫秒数之后，服务器就会自动/惰性删除生存时间为0的键

> 默认没有设置的话，TTL为-1，表示永不过期。TTL设置为-1后不代表一定永久存在，因为还存在redis的内存占用达到maxmemory阈值，且满足缓存淘汰策略，被其他新的键置换掉

```c++
typedef struct redisDb {
    // ...
    // 键空间
    dict *dict
    // 键空间对应的过期字典
    dict *expires;
} redisDb;
```

## **2.1 过期时间相关操作**

### **设置过期时间**

expires字典保存了数据库中所有键的过期时间：
- 键是一个**指针**，指向了键空间中的某个键对象
- 值是一个long long类型的整数，保存了过期时间（毫秒精度）

通过以下的命令都可以设置过期时间，前三个命令最终都会转换为最后的命令`PEXPIREAT`：
- `EXPIRE <key> <ttl>`：将key的生存时间设置为当前时间 + ttl（秒）
- `PEXPIRE <key> <ttl>`：将key生存时间设置为当前时间 + ttl（毫秒）
- `EXPIREAT <key> <timestamp>`：将key生存时间设置为timestamp（秒级）
- `PEXPIREAT <key> <timestamp>`：将key生存时间设置为timestamp（毫秒级）

### **移除过期时间**

可以使用`PERSIST`在过期字典中查找给定的键，并解除键在过期字典中和过期时间的管理，可以认为是`PEXPIREAT`的反向操作

### **获得剩余时间**

`TTL`：返回以秒为单位的键剩余生存时间

`PTTL`：返回以毫秒为单位的键剩余生存时间

以上两个命令通过：计算键的过期时间 - 当前时间，计算并返回键的剩余生存时间判定

## **2.2 过期键删除策略**

通过以下步骤判定一个键是否过期：

1. 检查给定键是否存在于过期字典，如果存在，那么获得该键的过期时间

2. 检查当前UNIX时间戳是否大于键过期时间，如果是，那么键已经过期

### **常用的过期删除策略**

如果键已经过期，那么它可以通过**三种不同的删除策略**进行删除：

**1. 定时删除**
- 做法：在**设置键的过期时间的同时**，创建一个定时器（timer），让定时器在键的过期时间来临时，**立即执行**对键的删除操作

- 方式：主动删除
- 时机：设置键ttl时
- 优点：对**内存友好**，可以及时删除过期键，释放内存
- 缺点：
    - 对**CPU时间不友好**，在过期键较多的情况下，删除过期键这一操作会耗费大量的CPU，在内存不紧张但CPU紧张的场景下，无疑对服务器的吞吐量和响应时间造成影响
    
    - 定时器需要用到Redis的**时间事件**，实现方式为无序链表，查找一个事件的时间复杂度为O(N)，这意味着不能高效地处理大量时间事件

**2. 惰性删除**
- 做法：**放任键过期不管**，但是每次从键空间中**获取键时，检查取得的键是否过期**，如果过期的话，就删除该键；如果没有过期，就返回该键

- 方式：被动删除
- 时机：获取键时
- 优点：对**CPU时间友好**，只有在取出键的时候才进行过期检查，删除的目标也仅限于当前操作的键
- 缺点：对**内存不友好**，如果有大量的冷数据过期键，它们将长时间停留在数据库中，只要没有被操作到，所占用的内存就不会释放，甚至可以视为一种内存泄漏（除非主动调用FLUSHDB操作）

**3. 定期删除**
- 做法：每隔一段时间，就对数据库进行一次检查，删除里面过期的键，至于删除多少过期键，和检查多个数据库，由算法决定

- 方式：主动删除
- 时机：每隔一段时间，时间可配置
- 优点：对`定时删除`和`惰性删除`两种策略的一种整合和折中，通过限制删除数量和删除执行频率减少对CPU时间的影响，同时减少内存浪费
- 缺点：难以确定`执行时长（删除数量）`和`频率`，如果太频繁或执行时长过长，又退化成了定时删除策略；反之退化为惰性删除

### **Redis怎么做**

Redis服务器：同时使用`惰性删除`和`定期删除`两种策略，以在CPU时间和内存占用上取得平衡

1. Redis的惰性删除实现：每个被访问的键如果过期，则被`expireIfNeeded`函数删除
    
    所以每个命令的实现函数应能同时处理**键存在和不存在**的两种情况：
    - 键存在，正常执行

    - 键不存在，按照键不存在的情况执行，正常是**返回空回复**

2. Redis的定期删除实现：周期性操作`serverCron`函数，在规定时间内，**分多次遍历**服务器中的各个数据库，从expires字典中**随机**检查一部分键的过期时间

> 结合惰性删除策略，可以大大提升定期删除对执行时长和频率配置的容错性

## **2.3 持久化/主从同步对过期键的处理**

RDB/AOF持久化，以及复制功能需要对过期键进行相应处理，才能保证各自的功能模块不受影响

### **RDB**

保存：
执行SAVE命令或BGSAVE命令创建一个新的RDB文件时，会对数据库中的键进行检查，**已过期的键不会被保存到新创建的RDB文件**中

载入：
按服务器的运行模式处理过期键

- 主服务器模式

    未过期的键会从RDB文件被载入到数据库，已过期则忽略

- 服务器模式

    所有键都会被加载，无论是否过期

### **AOF**

写入：
不会因为过期键产生影响，当过期键被`惰性删除`或`定期删除`时，往AOF文件内追加一条DEL命令，来显式记录该键已被删除

重写：
与RDB的保存思路类似，在执行AOF重写时，已过期的键不会被保存到重写后的AOF文件中

加载：
按照AOF文件载入后，恢复到某一数据库状态，所以无论是否过期，都会被加载

### **复制**

> 主从复制模式下，从服务器的过期键删除动作由主服务器控制！！！

- 主服务器在删除一个过期键后，会显式地向所有从服务器发送一个DEL命令，从服务器接受到后才真正的删除过期键

- 从服务器的键即使到了过期时间，也不会主动将键删除，除非主服务器进行复制同步

    在没有通知之前，从服务器对客户端过期键的访问，以正常键的方式进行处理

很明显地，这种方式保证了主从服务器数据的**最终一致性**，但是做不到强一致

# **3. 事件**

Redis服务器本质上是**事件驱动程序**，服务器需要处理以下两种事件：
- 文件事件（file event）

    通过socket与客户端进行连接，文件事件就是服务器对套接字的抽象，服务器与客户端的通信会产生相应的文件事件，而服务器通过监听并处理这些事件来完成一系列网络通信操作

- 时间事件（time event）

    比如serverCron函数需要在给定的时间点执行，时间事件就是服务器对这类定时操作的抽象

除了以上两种事件，还有持久化介绍的AOF追加操作

```python
def eventLoop():
    while True:
        # 处理文件事件，接收命令请求，以及发送命令回复
        processFileEvents()

        # 处理时间事件
        processTimeEvents()

        # 判断是否将aof_buf内容写入到AOF文件中
        flushAppendOnlyFile()
```

## **3.1 文件事件**

**定义**：文件事件就是服务器对**客户端套接字的抽象**，服务器与客户端的通信会产生相应的**文件事件**，服务器通过监听并处理这些事件，来完成一系列网络通信操作

**模式**：[Reactor模式](https://asea-cch.life/achrives/reactor)（I/O多路复用模型）

**组成部分**：

Redis基于Reactor模式开发了网络事件处理器，这个处理器被称为`文件事件处理器`（file event handler）:

> 文件事件处理器以**单线程方式**运行，通过使用I/O多路复用程序监听多个套接字，既实现了高性能的网络通信模型，又可以很好地于Redis服务器中其它同样以单线程方式运行的模块进行对接，保持Redis内部单线程设计的简单性

- 套接字：对应`Handle`
- I/O多路复用程序：对应`Reactor的Synchronous Event Demultiplexer`
- 文件事件分派器：对应`Reactor的dispatcher功能`
- 事件处理器：对应`Event Handler`

    - 连接应答处理器
        - 文件：networking.c/acceptTcpHandler
        - 实现：sys/socket.h/accept()
        - 触发：初始化时，会将连接应答处理器和服务监听套接字的AE_READABLE
        - 作用：对连接服务器监听套接字的客户端进行应答。并在成功连接之后，将**客户端套接字**的AE_READABLE事件和命令请求处理器关联起来

    - 命令请求处理器
        - 文件：networking.c/readQueryFromClient
        - 实现：unistd.h/read()
        - 触发：连接过后，后续客户端向服务器发送命令请求时，套接字就会产生AE_READABLE事件，引发命令请求处理器执行
        - 作用：执行套接字读入

    - 命令回复处理器

**流程**：
1. I/O多路复用程序初始化时，先创建epfd描述符，再往中加入对接收（AE_ACCEPTABLE）的兴趣事件
2. 当新连接到来时，I/O多路复用程序感知到后返回，并将连接请求分配到Redis连接应答处理器
3. `连接应答处理器`会以可读(AE_READABLE)事件创建新连接的fd到epfd中，以此建立该fd与可读事件的关联
4. 当客户端向服务器发送命令请求时，**客户端套接字**会产生AE_READABLE事件，引发`命令请求处理器`的处理

    > DMA内存拷贝完成后，将自身加入到rdlist中，此时epoll_wait方法从队列取出就绪事件

5. 服务器返回命令请求，将客户端套接字的AE_WRITABLE事件与`命令回复处理器`进行关联，关联后，如果缓冲区可写，则触发命令回复的操作

## **3.2 时间事件**

分为两种：

- 定时事件：让一段程序在指定的时间之后执行一次

- `周期性时间`：让一段程序每隔指定时间就执行一次

一个时间事件主要由三个属性组成：
- id：服务器为时间事件创建的全局唯一ID
- when：毫秒精度的UNIX时间戳，记录了时间事件到达时间
- timeProc：时间事件处理器，调用该属性指定的处理器来处理事件

> 目前Redis只使用周期性事件，没有或很少使用定时事件

### **3.2.1 底层实现**

数据结构：`无序链表`，表头入队

实现方式：时间事件执行器运行时，**遍历整个链表，查找所有已到达的时间事件**，并调用相应的事件处理器

> 正常模式下只使用`serverCron`一个时间事件，服务器几乎是将无序链表退化成一个指针使用

### **3.2.2 serverCron**

用于对Redis的自身资源和状态进行检查和调整：
- 更新服务器的各类统计数据
- **清理过期键值对**
- 关闭和清理失效客户端
- **尝试进行AOF或RDB持久化操作**
- 主服务器会对从服务器定期同步
- 处于集群模式下，对集群进行等定期同步和连接测试

Redis服务器以`周期性事件`来运行serverCron函数，每隔一段时候，就会执行一次serverCron直至服务器关闭

# 参考
- [Redis设计与实现]()
- [dackh-I/O模型总结](https://github.com/dackh/blog/blob/master/IO%E6%A8%A1%E5%9E%8B.md)
- [阻塞、非阻塞、多路复用等I/O模型](https://www.jianshu.com/p/b8203d46895c)