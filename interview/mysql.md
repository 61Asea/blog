# Interview Six：mysql

- innodb文件系统
    - 文件、db页大小、磁盘块
    - 行格式
    - 完全行溢出
- 索引
    - 聚簇/非聚簇索引
    - 覆盖索引、回表
    - 最左匹配法则、索引下推
    - 索引类型、种类
    - `索引失效场景、索引不适用场景`
- db锁
    - 排它锁（写锁）、共享锁（读锁）
    - 行锁、表锁
- ACID
    - 事务隔离级别
    - MVCC
- 分库分表
    - 垂直分、水平分
    - ID唯一、sharding_key
    - 非sharding_key的查询
- Mysql主从同步
    - 线程模型
    - 异步、半同步、全同步
    - 内部XA

# **1. innodb的文件系统**

在innodb文件系统中，一个表使用一个.ibd文件进行存储，表空间由若干个页组成，以**页作为磁盘和内存的基本交互单位**

数据索引页：页默认大小为16KB，数据和索引放在同一个结构中，并建立起聚簇索引

磁盘块：默认大小为4KB

所以一个.ibd文件的大小为16的倍数，B+树的每个节点至少为一个页大小

问题：页多大最好？

- 小页：

    - 读：小页读性能更好，即使只读取需要的数据需要的最小I/O也为一个页，小I/O就可以获得数据

    - 写：写入压力更大，写入数据不在同一个页内，则意味着相比大页需要更多的IOPS次数刷盘

- 大页：

    - 读：读性能较差，都是读取数据的，但是大I/O

    - 写：写入压力小，相比小页，需要的IOPS次数更少

# **2. 聊聊db索引**

先介绍聚簇索引，通过聚簇索引来引申出innodb的数据存储结构，以及聚簇索引相比非聚簇索引的优势，其他问题等待询问

## **2.1 db有哪些类型的索引？**

索引按照结构类型来讲，主要包含：B+树和Hash索引

- B+树索引：使用B+树组织数据，非叶子节点存放`索引列 + 指针`，叶子节点存放`索引列 + 数据`，叶子节点之间**通过前/后指针链接**形成双向链表
        
    - 优点：

        - 有序：数据在逻辑上为`索引列值有序`

        - 局部性原理：最小I/O读为一个页，每一次I/O能读取更多的数据（对比二叉树），且想要读取的字其相邻的字在接下来被访问的概率极高

        - 高扇出性：由于非叶子节点并不保存数据（对比B树），相比B树和二叉搜索树可以存储更多的指针，B+树一般不会超过4层，而**越低的高度代表着更少的I/O次数**

    > 一张表只能有一个聚簇索引，默认为主键，若没有定义主键则选择一个唯一的非空索引代替，再没有则隐式定义一个主键，将其作为聚簇索引

- hash索引：使用散列表组织数据，通过对索引列值哈希计算，以O(1)时间复杂度得到表中指向数据行的**指针元素**

    - 优点：

        - 占用空间小：自身只存储指针，可以直接读入到内存中

        - 精确匹配：包含索引所有列的查询，可以达到O(1)

    - 缺点：

        - 无序：只支持等值查询，不支持任何范围的查找

        - `最左匹配无效`：由于散列表是根据索引列计算生成的，所以必须精确匹配索引列才能生效

> 对于myisam和innodb的大部分索引，都是使用B+树实现，区别只在于叶子节点所存储的内容，引申出聚簇索引

聚簇索引：**真实**数据和索引在一起存储，其他类型都叫做非聚簇索引（如：myisam索引（数据地址）、innodb二级索引（主键值））

## **2.2 覆盖索引/回表**

覆盖索引：指在一次查询中，如果**查询的字段包含在索引列内**，则称为覆盖索引

回表：指通过在辅助索引上获得主键值后，再**返回到主索引**上查询真实数据。在满足覆盖索引的情况下，无需回表查询

![explain条件](https://asea-cch.life/upload/2022/01/explain%E6%9D%A1%E4%BB%B6-ecba788f7d6d4af5b8bbd967e24e01de.webp)

```sql
# explain SELECT id, b, c FROM `demo` WHERE b = 2;

# using index：查询列全在索引中，无需回表，属于覆盖索引查询
# using index; using where：查询列全在索引中，范围索引查询
# using where：需要索引回表查询数据
# using index condition：包括了索引下推内容，

### 无需回表类型

# 覆盖索引查询，type: ref；extra：using index
EXPLAIN SELECT b, c FROM `demo` WHERE b = 1;

# 范围索引查询，type：range; extra：using where; using index
EXPLAIN SELECT b, c FROM `demo` WHERE b > 1;

# 范围索引查询（索引下推），type：range；extra：using where；using index
EXPLAIN SELECT b, c FROM `demo` WHERE b > 1 AND c = 1;

# 无索引条件查询，
EXPLAIN SELECT b, c FROM `demo`;

### 需回表类型

# 索引条件回表查询，type：ref，extra；extra: null
EXPLAIN SELECT e FROM `demo` WHERE b = 1;

EXPLAIN SELECT b FROM `demo` WHERE b > 1;

# 索引条件回表查询 + 非索引条件查询，type：ref；extra：using where
EXPLAIN SELECT e FROM `demo` WHERE b = 1 AND f = 0;

```

## **2.3 索引种类（最左前缀匹配/索引下推）**

种类：

- 主键索引、唯一性索引：

    - NULL：主键不可以为NULL，唯一索引可以为NULL

    - 主键可以被其他表引用为外键

- 普通索引、联合索引

    - **最左匹配法则**：用于联合索引的判断法则，匹配时按照联合列的从左到右的顺序进行，如果跳过了其中一列，将无法使用联合索引

    - **索引下推**：联合索引范围查询时，在符合最左匹配法则的情况下，依旧可以使用其他顺序列来进行索引筛除，而无需回表

        ![5.6之前没有索引下推会出现回表](https://asea-cch.life/upload/2021/08/%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%E7%9A%84%E8%A7%A3%E9%87%8A-0448432e65a94102a62a722682e36fb4.png)

        > 在5.6之前涉及到联合索引范围查询时，会直接停止联合索引查询，后续的列将无法通过索引进行筛选

        如：

            假设存在联合索引(a, b, c)，sql语句select * from `test` where a >= 1 and b = 1，则b = 1将无法使用到联合索引的筛除，需要回表进行判断

        根本原因：db处理where条件时，分为index key、index filter和table filter，但5.6之前的index filter是放在mysql server层面，5.6之后将index filter下推到引擎层中实现，这样**大大减少了引擎层返回的无用数据**

        - index key：确定查询在索引的连续位置，即起始位置和结束位置

        - index filter：通过index key确定了范围数据后，先过滤掉与where条件相关，但并不匹配结果的索引列条件

        - table filter：where中不能用索引处理的，需要回表进行过滤

## **2.4 索引失效/不适用场景**

索引的两个步骤：

1. 读取索引数据，如查询列全在索引列中，则**需回表**则获取主键ID（using where），否则可直接返回结果（using index）

2. 根据第一步的结果，从表中获取数据


- 索引失效：没有按照预期走索引，变成全表扫描

    失效场景判断的步骤：

    1. 先判断是否会回表查询，根据查询列、where条件中分析出可能的索引列，并对比`查询列`、`where条件`中是否有索引列不存在的列出现（无法覆盖），**无需回表一定会走索引**

    2. 如果不是覆盖索引查询，则判断当前where条件中是否运用到了索引，如果不符合最左匹配法则，则没有运用到索引，直接走全表
    
    3. 如果满足索引条件，则再以**RANGE查找的匹配记录占全部记录某个比重时使用全表扫描**的思维去判断

        思维：`不满足覆盖索引需要回表`，且回表查询的成本与全表扫描相差不大

        - != 、NOT IN：一般情况下，这两种操作在第一步会选择表中**绝大部分**数据，使得回表操作跟一开始就全表扫描一样，所以**默认直接走全表扫描**

        - IN(多个参数)

        - \>, <等范围查找 

        - 使用参数、表达式作为条件

        - 使用左模糊条件：`like '%xxx'`，这种方式不符合最左匹配法则

        - or：只要有部分条件没有索引，且需要回表查找，就会走全表扫描

        <!-- - 条件使用了null，使用count(*) -->

- 不适用场景

# 参考
- [数据库索引的知识点](https://segmentfault.com/a/1190000023314270)：索引类型（按结构划分）、聚簇索引、非聚簇索引、覆盖索引、索引种类（按作用范围）、最左匹配法则、`索引失效场景`、`索引不适用场景`

- [为什么使用B+树](https://zhuanlan.zhihu.com/p/81273236)

- [B+树节点有多大](https://blog.csdn.net/dl674756321/article/details/102987984)：B+树高度低，能减少I/O次数，跳表、B树高度较高，Hash不支持联合索引的最左匹配，范围查询

# 重点参考
- [mysql 物理顺序_实验：innodb 的存储顺序是否完全物理无关？](https://blog.csdn.net/weixin_35531726/article/details/113441137)：innodb在ibd文件中存储的数据，无论是页之间还是页内记录都是**物理顺序无关**的，页内记录的物理无关只限制在页内，不能跨越到其他页中

- [放弃索引读取，改为全表扫描的原因](https://blog.csdn.net/z69183787/article/details/53393153/)：全表扫描可以顺序读I/O，而如果采取索引扫描，得到的只是索引值有序但主键值无序的集合，在回表查询的时候会有产生随机I/O
- [索引下推的解释 + explain](https://www.jianshu.com/p/9927a2307329)

- [索引失效的场景](https://www.zhihu.com/question/295402716)