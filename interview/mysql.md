# Interview Six：mysql

- innodb文件系统
    - 文件、db页大小、磁盘块
    - 行格式
    - 完全行溢出
- 索引
    - 聚簇/非聚簇索引
    - 覆盖索引、回表
    - 最左匹配法则、索引下推
    - 索引类型、种类
    - `索引失效场景、索引不适用场景`
- db锁和事务
    - 排它锁（写锁）、共享锁（读锁）、意向锁、行锁、表锁
    - ACID
    - 事务隔离级别
    - MVCC
- 分库分表
    - 垂直分、水平分
    - ID唯一、sharding_key
    - 非sharding_key的查询
- Mysql主从同步
    - binlog、redo log
    - 线程模型
    - 异步、半同步、全同步
    - 内部XA

# **1. innodb的文件系统**

在innodb文件系统中，一个表使用一个.ibd文件进行存储，表空间由若干个页组成，以**页作为磁盘和内存的基本交互单位**

数据索引页：页默认大小为16KB，数据和索引放在同一个结构中，并建立起聚簇索引

磁盘块：默认大小为4KB

所以一个.ibd文件的大小为16的倍数，B+树的每个节点至少为一个页大小

问题：页多大最好？

- 小页：

    - 读：小页读性能更好，即使只读取需要的数据需要的最小I/O也为一个页，小I/O就可以获得数据

    - 写：写入压力更大，写入数据不在同一个页内，则意味着相比大页需要更多的IOPS次数刷盘

- 大页：

    - 读：读性能较差，都是读取数据的，但是大I/O

    - 写：写入压力小，相比小页，需要的IOPS次数更少

# **2. 聊聊db索引**

先介绍聚簇索引，通过聚簇索引来引申出B+树结构及优势（B+树高度更低），以及聚簇索引相比非聚簇索引的优势，其他问题等待询问

## **2.1 db有哪些类型的索引？**

索引按照结构类型来讲，主要包含：B+树和Hash索引

- B+树索引：使用B+树组织数据，非叶子节点存放`索引列 + 指针`，叶子节点存放`索引列 + 数据`，叶子节点之间**通过前/后指针链接**形成双向链表
        
    - 优点：

        - 有序：数据在逻辑上为`索引列值有序`

        - 局部性原理（对比二叉树）：最小I/O读为一个页，每一次I/O能读取更多的数据，且想要读取的字其相邻的字在接下来被访问的概率极高

        - 高扇出性（对比B树）：由于非叶子节点并不保存数据，相比B树和二叉搜索树可以存储更多的指针，B+树一般不会超过4层，而**越低的高度代表着更少的I/O次数**

    > 一张表只能有一个聚簇索引，默认为主键，若没有定义主键则选择一个唯一的非空索引代替，再没有则隐式定义一个主键，将其作为聚簇索引

- hash索引：使用散列表组织数据，通过对索引列值哈希计算，以O(1)时间复杂度得到表中指向数据行的**指针元素**

    - 优点：

        - 占用空间小：自身只存储指针，可以直接读入到内存中

        - 精确匹配：包含索引所有列的查询，可以达到O(1)

    - 缺点：

        - 无序：只支持等值查询，不支持任何范围的查找

        - `最左匹配无效`：由于散列表是根据索引列计算生成的，所以必须精确匹配索引列才能生效

> 对于myisam和innodb的大部分索引，都是使用B+树实现，区别只在于叶子节点所存储的内容，引申出聚簇索引

聚簇索引：**真实**数据和索引在一起存储，其他类型都叫做非聚簇索引（如：myisam索引（数据地址）、innodb二级索引（主键值））

## **2.2 覆盖索引/回表**

覆盖索引：指在一次查询中，如果**查询的字段包含在索引列内**，则称为覆盖索引

回表：指通过在辅助索引上获得主键值后，再**返回到主索引**上查询真实数据。在满足覆盖索引的情况下，无需回表查询

![explain条件](https://asea-cch.life/upload/2022/01/explain%E6%9D%A1%E4%BB%B6-ecba788f7d6d4af5b8bbd967e24e01de.webp)

```sql
# explain SELECT id, b, c FROM `demo` WHERE b = 2;

# using index：查询列全在索引中，无需回表，属于覆盖索引查询
# using index; using where：查询列全在索引中，范围索引查询
# using where：需要索引回表查询数据
# using index condition：包括了索引下推内容，

### 无需回表类型

# 覆盖索引查询，type: ref；extra：using index
EXPLAIN SELECT b, c FROM `demo` WHERE b = 1;

# 范围索引查询，type：range; extra：using where; using index
EXPLAIN SELECT b, c FROM `demo` WHERE b > 1;

# 范围索引查询（索引下推），type：range；extra：using where；using index
EXPLAIN SELECT b, c FROM `demo` WHERE b > 1 AND c = 1;

# 无索引条件查询，
EXPLAIN SELECT b, c FROM `demo`;

### 需回表类型

# 索引条件回表查询，type：ref，extra；extra: null
EXPLAIN SELECT e FROM `demo` WHERE b = 1;

EXPLAIN SELECT b FROM `demo` WHERE b > 1;

# 索引条件回表查询 + 非索引条件查询，type：ref；extra：using where
EXPLAIN SELECT e FROM `demo` WHERE b = 1 AND f = 0;

```

## **2.3 索引种类（最左前缀匹配/索引下推）**

种类：

- 主键索引、唯一性索引：

    - NULL：主键不可以为NULL，唯一索引可以为NULL

    - 主键可以被其他表引用为外键

- 普通索引、联合索引

    - **最左匹配法则**：用于联合索引的判断法则，匹配时按照联合列的从左到右的顺序进行，如果跳过了其中一列，将无法使用联合索引

    - **索引下推**：联合索引范围查询时，在符合最左匹配法则的情况下，依旧可以使用其他顺序列来进行索引筛除，而无需回表

        ![5.6之前没有索引下推会出现回表](https://asea-cch.life/upload/2021/08/%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8%E7%9A%84%E8%A7%A3%E9%87%8A-0448432e65a94102a62a722682e36fb4.png)

        > 在5.6之前涉及到联合索引范围查询时，会直接停止联合索引查询，后续的列将无法通过索引进行筛选

        如：

            假设存在联合索引(a, b, c)，sql语句select * from `test` where a >= 1 and b = 1，则b = 1将无法使用到联合索引的筛除，需要回表进行判断

        根本原因：db处理where条件时，分为index key、index filter和table filter，但5.6之前的index filter是放在mysql server层面，5.6之后将index filter下推到引擎层中实现，这样**大大减少了引擎层返回的无用数据**

        - index key：确定查询在索引的连续位置，即起始位置和结束位置

        - index filter：通过index key确定了范围数据后，先过滤掉与where条件相关，但并不匹配结果的索引列条件

        - table filter：where中不能用索引处理的，需要回表进行过滤

## **2.4 索引失效/不适用场景**

索引的两个步骤：

1. 读取索引数据，如查询列全在索引列中，则**需回表**则获取主键ID（using where），否则可直接返回结果（using index）

2. 根据第一步的结果，从表中获取数据


- 索引失效：没有按照预期走索引，变成全表扫描

    失效场景判断的步骤：

    1. 先判断是否会回表查询，根据查询列、where条件中分析出可能的索引列，并对比`查询列`、`where条件`中是否有索引列不存在的列出现（无法覆盖），**无需回表一定会走索引**

    2. 如果不是覆盖索引查询，则判断当前where条件中是否运用到了索引，如果没有运用到索引（如：不符合最左匹配法则），直接走全表
    
    3. 如果满足索引条件，则再以**RANGE查找的匹配记录占全部记录某个比重时使用全表扫描**的思维去判断

        思维：`不满足覆盖索引需要回表`，且回表查询的成本与全表扫描相差不大，当未命中行数占总数12.5%左右

        - != 、NOT IN：一般情况下，这两种操作在第一步会选择表中**绝大部分**数据，使得回表操作跟一开始就全表扫描一样

        - IN(多个参数)

        - \>, <等范围查找 

        - 使用参数、表达式作为条件

        - 使用左模糊条件：`like '%xxx'`，这种方式不符合最左匹配法则

        - or：只要有部分条件没有索引，且需要回表查找，就会走全表扫描

        - 需要类型转换：如字符串没有用单括号

    > !=不一定就不走索引，根据比重分析

- 索引不适用场景

    - **频繁更新的字段**不适合创建索引，因为每次更新都要维护索引，形成更大的开销

    - 表记录太少，就不需要创建索引

    - where条件用不上的字段不用创建索引

    - **数据重复且分布平均**的字段，这种字段创建索引没有太大效果

# **3. 锁**

1. 按照功能分

    - X锁：写锁（排它锁），**全互斥**，涉及的操作有`select ... for update`、`update`、`delete`

    - S锁：读锁（共享锁），**读读不互斥，读写互斥**，涉及的操作有：`select ... lock in share mode`、`select ... for share`

    - IX（意向写锁）、IS（意向读锁）：意向锁，表锁和行锁进行冲突检测的fail-fast机制

        表锁与行锁冲突，如果没有意向锁，则需要通过遍历手段来检测哪一行有行锁，效率低下

2. 按照粒度

    - RECORD：行锁

    - GAP：间隙锁，innodb在RR隔离级别下使用，用于解决幻读问题

        `生效范围`：
        
        - 等值条件：命中值时，选取当前索引值的上一个值作为左区间，下一个值作为右区间，遵循左开右闭；没有命中值时，以条件值可处的上下索引值作为区间，遵循全开

        - 范围条件：命中值时，选取当前索引值的上/下一个值作为左/右开区间，并根据剩余值割裂出多个全闭区间，共同组成生效范围

        间隙锁出现的场景：

        - sql是一个`范围的当前读`操作

        - sql走的索引是`非唯一索引`

        这也意味着如果索引走唯一索引，且为等值当前读，将不会产生间隙锁

    - NEXT KEY LOCK：RECORD + GAP组合

    - TABLE：表锁，锁定整张表并且阻塞其他用户对表的读写操作，涉及操作有：`alter [表结构]`

3. 判断一条sql的加锁步骤

    - 先确定当前db会话/全局的隔离级别属性，RC不会有GAP

    - 根据等值条件、范围条件来判断sql的**索引使用情况**，对于`当前读`有以下场景：

        - 无索引条件：
            - RC：在引擎层返回全部加锁的行，并由server层进行筛除，不匹配的行记录会unlock record
            - RR：锁全部record和全部gap
        - 非唯一索引：
            - RC：查找二级索引的行并加锁，再查找对应主索引的行并加锁
            - RR：查找二级索引的范围加RECORD X和GAP，再查找对应主索引涉及的行加RECORD X（支持ICP的情况下，会减少一些主索引不匹配的RECORD，和辅助索引不匹配的RECORD与GAP）
        - 唯一索引：
            - RC：只加范围下的行锁
            - RR：在等值查询条件下，不会加上间隙锁，范围查询则根据范围进行锁定

# **4. 事务特性、隔离级别**

1. ACID：**原子性和隔离性是实现一致性的必要前提，隔离性是实现一致性的手段**

    - 原子性：事务操作只会全部成功或全部失败，**由undo log日志保证**

    - 持久性：事务一旦提交，所做修改将永久保存到db中，**由redo log保证**

    - 隔离性：事务之间的操作不可见，解决丢失更新的问题，**由MVCC等机制保证**

    - 一致性：db总是从一个一致性状态，转换到另一个一致性状态，由**不同的隔离级别，加上代码层面**进行保证

2. 隔离级别：都解决了丢失更新问题，在当前读操作下都会加行锁，innodb采用MVCC机制来实现隔离级别规范

    - Read Uncomitted（读未提交）：有脏读问题，能读到其他事务未提交的操作

    - Read Committed（读已提交）：有不可重复读问题，能读到其他事务已提交的操作

    - Repeatable Read（可重复读）：innodb在该级别下实现可重复读，并通过MVCC + GAP解决了当前读的幻读问题

    - Serializable（串行化）：最高级别，即使是快照读也会加上S锁，锁激烈竞争下会造成大量阻塞导致效率低下

# **5. 幻读**

1. MVCC：全称多版本并发控制，**小开销实现非锁定读**，来满足标准的隔离级别语义

    实现手段：undo log

    行记录的每一个修改操作都视作一个版本，innodb根据当前隔离级别，判断当前事务ID与记录最新版本号的大小，来确定返回**快照读的版本**

    版本存于undo log中，事务的原子性也是由undo log提供

2. 幻读：指两次读取出现了新行，在并发事务中，有进行插入操作并进行提交成功可能会出现幻读

    - RU、RC：存在幻读现象，在事务内可以读到新行

    - RR

        - 快照读：单独的快照读不会有幻读情况，MVCC能判断出新插入的行版本大于当前事务ID

        - 当前读：不会出现幻读现象，通过GAP锁住空闲防止其他并发事务插入新行，否则会出现当前事务操作结果出现幻读

            假设t1和t2事务并发执行，t1的update操作执行后，t2的insert操作在t1提交前**阻塞**

            ```sql
            -- t1
            begin;
            update `table` set a = 1 where id > 10;
            commit;

            -- t2
            begin;
            insert `table`(id, a) value(13, 2);
            commit;
            ```

        - 快照读 + 当前读操作：当前读操作**依赖于快照读的结果**，通过MVCC返回的数据不会有幻读现象，但新数据已经被其他事务插入。本事务将出现插入失败，不符合快照读结果的情况

# **6. 表量级，分库分表**

1. 表量级：为什么数据越多，压力越大？

    - `内存无法覆盖所有索引`：db会将索引数据预先读取到innodb buffer中，如果数据量级过大且buffer size过小，将会产生更多的磁盘随机I/O读

        解决方案：增加机器的内存配置、分表

    - B+树的高度变高：这意味着到达叶子节点需要更多次I/O读

        - 非叶子节点指针数：`默认页大小 / （指针大小 + key大小）`，指针大小在mysql中为6字节，key和页大小则根据实际情况

        - 叶子节点数据个数：`默认页大小 / 行数据大小`

        - 一个非叶子节点的所有叶子节点可存储数据个数：非叶子节点指针数 * 叶子节点数据个数

        - 树高度对应的数据量级： 非叶子节点指针数 ^ (树高度 - 1) * 叶子节点数据个数

            - 高度为2，key为bigint，每行1k：18720条数据，**一次I/O**

            - 高度为3，key为bigint，每行1k：21902400条数据，**两次I/O**

2. 分库分表思路

    - 切分方向：方向分为垂直和水平，前者由**业务层面**驱动，对表库结构会产生影响；后者由**数据平铺**驱动，不对表库结构产生影响

    - sharding key：分表字段，用于映射路由sql条件到具体的表上，可以根据C端业务来选取，如：面向用户端的用户Id、玩家Id

    - 分片算法：主要是形成映射，最简单的方式有哈希取模、一致性哈希算法（削弱取模数改动后导致的不均影响）、均匀轮询（Kafka也有）、**映射表**等方式

    - 主要问题：

        - 分布式主键：雪花算法、**基础起始步长**

        - 笛卡尔积问题：以shardingsphere为例，需要指定联表的绑定关系，减少无必要的查询

        - 非sharding key的查询：与sharding key有关联，但sql条件上无法直接利用sharding key作为查询条件

            - `映射表`：将非sharding key通过映射转换为sharding key，具体做法是映射非sharding key与sharding key的关系，取出所有相关联的sharding key进行查询

            - 后台处理：通过多线程全表扫，再聚合最终结果来做，以异步的形式实现

**sharding key**：

# **7. 日志，主从同步**

![RC搭配ROW格式binlog导致问题](https://asea-cch.life/upload/2022/01/RC%E6%90%AD%E9%85%8DROW%E6%A0%BC%E5%BC%8Fbinlog%E5%AF%BC%E8%87%B4%E9%97%AE%E9%A2%98-b06485d318de492d832da3f98c986415.JPG)

日志：

- undo log：记录事务内**相关操作**以实现原子性，MVCC基于undo log实现多个版本并发控制

- redo log：记录数据的**刷页情况**日志以实现持久性，可与binlog搭配用于宕机恢复，内部XA事务保持redo log和binlog的一致性

- binlog：以事件的形式，记录mysql server执行层上导致数据变动的**操作日志**，用于主从同步

    > binlog的STATEMENT格式日志需要搭配**RR隔离级别来达成操作的阻塞提交顺序**，因为binlog的记录是以事务commit为触发点进行一次性提交，如果使用RU/RC将无法感知真正的执行顺序

主从同步过程：

1. master：创建dump线程，将binlog内容推送到slave服务器上

2. slave：启动I/O线程接收binlog数据，保存到relay log（中继日志）中

3. slave：启动SQL线程，读取relay log中的数据应用到本机数据上

主要分为三种主从同步模式：

- 异步复制：默认模式，在**事务提交后**主库把binlog数据发送给从库即可，不关心从库是否应用

- 半同步复制：

    - 传统半同步：在**组提交的最后commit阶段**后，发送binlog给所有从库，并等待从库应用完毕后的ack，只要获得至少一个从库ack就算确认完成

        缺点：session没有返回，但是该节点的其他事务已经可以感知到该事务的提交，在master宕机后，从节点可能并没有收到binlog的推送就变成了新主节点，丢失数据导致幻读

    - semi-sync：在**组提交的第二阶段sync**后，与传统半同步类似，可以本机commit事务时，从节点一定应用了binlog日志

        优点：解决了传统半同步丢失数据的问题，因为还未到commit阶段，该节点的其他事务操作不能感知到数据变化

        缺点：对于发送事务的session，在主机宕机后会出现数据变多的风险，因为其事务操作是失败的，但是从节点可能是成功的，在主从切换后会出现本应失败的数据出现的情况

# **8. 疑问：Mysql悲观锁和乐观锁对应的业务场景是怎么样的**

- [Mysql悲观锁和乐观锁](https://www.cnblogs.com/cyhbyw/p/8869855.html)

![mysql乐观锁悲观锁疑问](https://asea-cch.life/upload/2022/01/mysql%E4%B9%90%E8%A7%82%E9%94%81%E6%82%B2%E8%A7%82%E9%94%81%E7%96%91%E9%97%AE-6d3a56b3592c472d9dd56b9caaa39b13.JPG)

# 参考
- [数据库索引的知识点](https://segmentfault.com/a/1190000023314270)：索引类型（按结构划分）、聚簇索引、非聚簇索引、覆盖索引、索引种类（按作用范围）、最左匹配法则、`索引失效场景`、`索引不适用场景`

- [为什么使用B+树](https://zhuanlan.zhihu.com/p/81273236)

- [B+树节点有多大](https://blog.csdn.net/dl674756321/article/details/102987984)：B+树高度低，能减少I/O次数，跳表、B树高度较高，Hash不支持联合索引的最左匹配，范围查询

- [关于MySQL buffer pool的预读机制](https://www.cnblogs.com/geaozhang/p/7397699.html)

# 重点参考
- [mysql 物理顺序_实验：innodb 的存储顺序是否完全物理无关？](https://blog.csdn.net/weixin_35531726/article/details/113441137)：innodb在ibd文件中存储的数据，无论是页之间还是页内记录都是**物理顺序无关**的，页内记录的物理无关只限制在页内，不能跨越到其他页中

- [放弃索引读取，改为全表扫描的原因](https://blog.csdn.net/z69183787/article/details/53393153/)：全表扫描可以顺序读I/O，而如果采取索引扫描，得到的只是索引值有序但主键值无序的集合，在回表查询的时候会有产生随机I/O
- [索引下推的解释 + explain](https://www.jianshu.com/p/9927a2307329)

- [索引失效的场景](https://www.zhihu.com/question/295402716)

- [Mysql加锁过程详解（1）-基本知识](https://www.cnblogs.com/crazylqy/p/7611069.html)：不同隔离级别的加锁详情，包括db锁过程的详细解答

- [Mysql悲观锁和乐观锁](https://www.cnblogs.com/cyhbyw/p/8869855.html)

- [索引失效](https://mp.weixin.qq.com/s/lEx6iRRP3MbwJ82Xwp675w)
- [](https://mp.weixin.qq.com/s/7zBJOrlljXIhpuzV69afIg)