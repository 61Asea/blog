# interview nine：network

# **1. tcp/ip协议**

1. TCP/IP四层模型

    - 数据链路层：物理手段将主机连接到网络中，并对比特流数据进行分组为帧数据

    - 网络层：主机之间通信，IP协议处理**数据包传输**、路由分组交换、主机间通信

    - 传输层：端到端通信，也称为**进程**与**进程**之间的通信，协议包括TCP、UDP、QUIC、ICMP

        - TCP：面向连接、**可靠的**、**基于字节流**的传输层通信协议

            - 面向连接：点对点连接，UDP则是同时向多个主机发送消息

            - 可靠：TCP尽可能保证报文到达接收端

            - 字节流：有序、重复丢弃、无边界

    - 应用层：协议实现，数据转换，建立连接，协议包括HTTP、FTP

2. TCP报文段：包括TCP首部 + 数据，首部包括序列号（seq）、确认号（ack）、控制位（ctl）、窗口

    - seq：发送方发送数据字节流的标识，首部中的序号值则是**本报文段数据**第一个字节在整个TCP连接中的序号，使用随机算法初始化值，防止**复用旧连接**后导致数据错乱

        > **因此，seq根据数据长度来增加，当没有数据时则+1**

    - ack：接收方响应的确认号，也表示期望收到对方下个报文段第一个字节的序号

    - ctl

        - SYN：前两次握手的建立控制位，由于是双向通信所以双方的第一次发送都会携带

        - ACK：有求必应，否则会触发发送方的超时重传机制

        - FIN：关闭连接的第一、三次挥手

# **2. TCP三次握手**

1. client向server发送SYN报文段（seq=client_isn），状态变为SYN_SEND

2. server接收到SYN报文段，并发送SYN+ACK报文段（seq=server_isn，ack=client_isn + 1）表示接收发起方的连接请求，状态由LISTEN进入SYN_RCVD

3. client接收到server的ack，状态由SYN_SEND进入ESTABLISHED，再返回ACK报文段给server（seq=client_isn + 1, ack=server_isn + 1）

server最终接收到第三次握手后，进入ESTABLISHED

**问题1：为什么不是2次？**

- **阻止网络时延造成的重复、历史连接初始化**

    当网络出现时延时，第一次握手和第二次握手超过RTT（往返时间）后，将触发发起方`超时重传`，产生新的第一次握手包
    
    如果没有第三次握手，则接收端只能为全部重传的握手包都建立连接，产生了重复多个的历史连接
    
    > 这种思路就是通过第三次握手，提供给client纠正的机会，由client检查错误ack并提供RST报文给服务端进行修正

- 确保双方的初始化序列号都被同步接收

    对于server端而言，如果没有第3次握手，将无法确保自己的seq被client端正确接收

**问题2：为什么不是4次？**

3次就够了，而且第二次握手中server端可以同时发送SYN位和ACK位的数据包

**问题3：accept()发生在三次握手的哪个阶段**

> 在第三次握手完成后，不要被哪个阶段误导了

- `第一次握手`：server为client新建socket句柄，将句柄放入到内核的半连接队列中（syn队列）

- 第二次握手：句柄仍旧在syn队列中

- `第三次握手`：将句柄从syn队列中移除，加入到全连接队列中（accept队列）

- **`第三次握手之后`**，accept()：将句柄从全连接队列中取出

**问题4：建立和处理连接用的是同一个socket吗？**

建立连接：listen_socket_fd

处理连接：client_fd

**问题5：SYN攻击是什么？如何缓解？**

恶意连接方发送第一次握手后，不再发送第三次握手，通过这种方式启动多个恶意连接占满服务方的半连接队列，从而导致服务方无法再正常为其他请求建立连接

缓解手段：

1. 指定半连接队列大小，指定队列溢出时的拒绝策略，如发送RST报文拒绝

2. 启用syn cookies算法，在第一次握手后不将该请求放入半连接队列中，转而通过syn cookies算法计算出一个随机值填充到seq中返回给对方，如果对方正常建立连接发送第三次握手，则再通过算法反解得出第一次握手时对方的数据，为请求建立句柄并放入全连接队列中

# **3. TCP四次挥手**

1. 第一次挥手：主动方发送FIN报文给被动方请求结束连接

    主动方状态：ESTABLISHED变为FIN_WAIT1

2. 第二次挥手：被动方接收FIN报文后，向客户端发送ACK报文，并开始进行数据收尾处理

    主动方状态：FIN_WAIT1变为FIN_WAIT2
    
    被动方状态：ESTABLISHED变为CLOSED_WAIT

3. 第三次挥手：被动方处理数据完毕，发送FIN报文给主动方

    主动方状态：FIN_WAIT2变为TIME_WAIT

    被动方状态：CLOSED_WAIT变为LAST_ACK

4. 第四次挥手：主动方接收到被动方的FIN包后，向被动方发送ACK，保证服务端正确关闭，并**等待2MSL**后进入CLOSED状态

    主动方状态：TIME_WAIT变为CLOSE（2MSL后）

    被动方状态：LAST_ACK变为CLOSE

**问题1：为什么要4次挥手**

FIN包：当前发送方已经没有数据要发送，但**仍可接收数据**

相较握手阶段，结束连接时被动关闭方通常还需要完成数据收尾处理和发送，所以其ACK和FIN分开发送

**问题2：为什么主动关闭方还需要等待2MSL后才能进入CLOSED状态**

MSL：数据包在网络发送中的最大生存时间，超过该时间的数据包将直接被丢弃掉

1. 防止tcp连接复用之后，**历史连接**的时延数据包影响**当前连接**的数据正确性，等待2MSL可以保证极限情况下**一来一回**的历史数据肯定都失效了

2. 辅助被动关闭方正确进入CLOSED状态，**至少会进行一次FIN包重试**，如果主动方接收到FIN包后就进入CLOSED状态，被动方将无法保证自己的FIN包是否被主动接收，从而进入长时间的LAST_ACK状态，**导致该连接在很长一段时间都无法复用**

# **4. TCP可靠性**

1. 校验和：接收方接收到数据后，计算checksum校验和并与报文中的校验和做对比，若不一致表明数据传输有误

2. 确认应答机制：有求必应，基于字节流传输的tcp连接对每个数据都进行了编号，ack的值表示接收方当前接收的数据序号

3. 重传机制：当没有ack（超过RTO时间，RTO值略大于RTT值）或ack返回值重复时，触发发送方通过`超时重传`或`快重传`等机制，重发数据报文

    > 快速重传解决超时重传触发时间仍旧过久的问题，可以提前发送丢包现象并进行修复

    TCP将超时重传视作相当重要的事件，当出现超时重传时，会增大RTO的退避因子，并减少发送窗口大小限制发送速率

4. 流量控制：通过滑动窗口提升网络通信效率，应答方通过累计应答减少应答次数，并将自己的接收窗口填入TCP首部中通告对方，对方的发送窗口变为接收方的接收窗口值，通过该窗口值限制发送速率

5. 拥塞控制：控制发送窗口的增长，当出现快速重传/超时重传时，会降低窗口值与增长阈值，通过恢复阶段后才能恢复到原先的窗口大小

**5. 浏览器请求一个网站的过程**

1. 通过**dns服务器解析域名获得IP地址**，通过子网掩码判断IP地址是否处于同一个子网，如果是同一个子网可直接连接，否则需要经过路由器、交换机的传输

2. `与目标主机建立TCP连接`

3. 连接建立成功后，应用层构造http请求报文，传输层添加tcp首部，IP层添加IP头，数据链路层添加以太网协议首部

4. 交互完毕后，与目标主机断开TCP连接

# **6. HTTPS的工作原理（安全证书交换过程）**

https：http + TLS（SSL/TLS），默认端口为443

> 目前市面上所有https都用TLS而不是TLS

在TCP三次握手后，再进行应用层TLS四次握手，后续数据加密传输（**前两个步骤为明文传输**）：

1. Client Hello：客户端向服务器发起https连接请求，携带自身支持的hash算法、加密算法和一个随机数A

2. `Server Hello`：服务器选择hash算法和加密算法，同样产生一个随机数B，协同证书发送给客户端，证书内包含公钥

3. `Client Key Exchange`：客户端检查证书的完整性和安全性，若有问题则提示警告，否则通过随机数A和B生成对称秘钥X，并通过摘要算法计算摘要值，最后使用证书公钥进行加密，后续客户端加解密数据都使用X

4. Server Finish：服务器使用私钥解密得到X，通过X加密一段Finish消息发送给客户端验证加解密通道是否成功

后续通信过程都采用X和约定好的加密算法进行加解密，得到最终的网页内容

相比较http明文传输，https有效的提升了传输过程的安全性，防篡改，防窃取，**防冒充（钓鱼节点）**

# **7. GET与POST区别**

本质上没有区别，是http应用层协议的两种不同请求方式，在传输层都基于tcp传输

GET：获取服务器资源，只读操作

POST：增删改服务器资源

- 安全性：指服务器的资源安全，通信数据在http明文传输下无法保证，需要https加密传输保证

    - POST：资源不安全，会修改服务器上的资源

    - GET：资源安全，只读操作不会破坏资源

- 幂等性：

    - POST：不幂等，多次执行结果不一致，可能会破坏服务器资源，一般由服务器提供幂等机制

    - GET：幂等，只读查询执行几次结果都是一样的

结论：
- GET资源安全且幂等，POST资源不安全且不幂等
- GET效率更高因为其可被浏览器缓存
- 查询数据使用GET，增删改数据使用POST
- GET和POST在不同浏览器上，TCP报文发送方式不同，GET普遍一个报文，POST可能分为为两个报文（一个http header，一个data）
- **GET的数据只支持ASCII字符，拼接在url上，长度有限制最大为2048个字符（URL长度限制）；POST没有长度限制，也支持二进制**
- 现实安全性而言，GET会把数据拼接在url上，可能会被人窥见

# **8. http1.1特性**

- 持久连接：**任意一端**没有提出明确断开连接，则保持tcp连接状态

    1.0每次请求结束后都会断开tcp连接，1.1持久连接大大减少了重复建立和断开连接开销

- http pipeline：管道网络传输，指允许客户端在已发送请求收到服务器响应前，发送下一个请求，但服务端仍旧按照请求发送的顺序返回响应

    - 队头阻塞：指由于上一个请求未发送/接收完毕，导致后续的请求被阻塞

        接收方无法识别拼装乱序请求，后续请求的响应会由于队头请求延迟而阻塞，在http2引入帧概念进行解决

    - 缺点：关闭http pipeline，避免http pipeline接收方队首阻塞，导致小文件传输连接迅速完成任务进入空闲，而大文件传输连接延迟导致其他请求阻塞，整体效率不升反降

现阶段主流做法：持久连接 + 并行连接，客户端可以根据各个连接的完成情况选择空闲的tcp连接进行传输

# **9. 负载均衡有哪几种实现方式**

1. DNS

    分层：协议层

    负责主体：域名服务商的dns服务器
    
    实现**地理级别**的负载均衡，不同地区的用户通过DNS解析返回不同地址
    
    缺点：控制权在域名服务商，扩展性差

2. HTTP重定向

    分层：协议层

    负责主体：http重定向服务器

    返回302响应并修改http响应头的Location达到负载均衡

    缺点：
    
    - 性能差，**产生二次请求增加请求耗时**

    - 请求响应都由http重定向服务器中转，性能有瓶颈

3. 协议层反向代理

    分层：协议层

    负责主体：反向代理服务器（Ngnix）

    反向代理服务器**解析请求**，获得客户端请求的主体IP，并通过均衡算法得到真实web服务器地址并转发该http请求

    优点：反向代理隐藏了真实服务器的ip地址，相比http重定向少了一次请求

    缺点：请求响应都由反向代理服务器中转，性能有瓶颈

4. IP层反向代理

    分层：网络层 + 传输层

    负责主体：反向代理服务器

    直接**在内核**对数据包的IP地址和端口进行修改，并根据负载算法计算真实web服务器地址后进行流转

    优点：相比协议层反向代理少了解析请求的开销

    缺点：依旧由反向代理服务器中转

5. 数据链路层负载均衡（三角传输）

    分层：数据链路层

    负责主体：负载均衡服务器

    分发过程中不修改IP地址，转而修改目的mac地址，且**配置真实物理服务器集群所有机器虚拟IP与负载均衡服务器IP地址一致**，做到响应数据可直接返回到用户浏览器，形成三角形关系

    优点：仅在请求分发时由反向代理服务器中转，响应数据可直接返回，降低了负载均衡服务器性能对整个系统性能的影响

# **10. 负载均衡算法**

1. 源地址散列：对IP地址进行hash计算，得到应用服务器，来自同一个IP地址的请求总在同一个服务器上处理，形成会话黏滞

2. 最少连接：将新到的请求分发到最少连接的服务器上，是最符合负载均衡定义的算法

3. 随机

4. 轮询：由负载服务器维护递增数，依次分发到每台应用服务器上

# 参考
- [epoll空轮询](https://www.jianshu.com/p/3ec120ca46b2)
- [常考的 BIO，NIO，AIO 总结](https://blog.csdn.net/m0_38109046/article/details/89449305)
- [get请求可以被缓存](https://segmentfault.com/q/1010000021784624)
- [TLS四次握手](https://zhuanlan.zhihu.com/p/156034207)

- [浏览器中网址访问过程](https://blog.csdn.net/m_buddy/article/details/77800998)

# 重点参考
- [网络篇夺命连环12问](https://mp.weixin.qq.com/s?__biz=MzkzNTEwOTAxMA==&mid=2247488227&idx=1&sn=36587eab67d87824179dd5edda3533db&chksm=c2b25a1ef5c5d308ae02ba5a2e5922738fd43305faf74c41320272acecc77d6a155eb50ad33a&token=982147105&lang=zh_CN&scene=21#wechat_redirect)
- [TCP队头阻塞和HTTP队头阻塞](https://blog.csdn.net/weixin_34364071/article/details/91416530)
- [java BIO/NIO的accept()方法](https://blog.csdn.net/Tom098/article/details/116107072)