# interview nine：network

# **1. tcp/ip协议**

1. TCP/IP四层模型

    - 数据链路层：物理手段将主机连接到网络中，并对比特流数据进行分组为帧数据

    - 网络层：主机之间通信，IP协议处理**数据包传输**、路由分组交换、主机间通信

    - 传输层：端到端通信，也称为**进程**与**进程**之间的通信，协议包括TCP、UDP、QUIC、ICMP

        - TCP：面向连接、**可靠的**、**基于字节流**的传输层通信协议

            - 面向连接：点对点连接，UDP则是同时向多个主机发送消息

            - 可靠：TCP尽可能保证报文到达接收端

            - 字节流：有序、重复丢弃、无边界

    - 应用层：协议实现，数据转换，建立连接，协议包括HTTP、FTP

2. TCP报文段：包括TCP首部 + 数据，首部包括序列号（seq）、确认号（ack）、控制位（ctl）、窗口

    - seq：发送方发送数据字节流的标识，首部中的序号值则是**本报文段数据**第一个字节在整个TCP连接中的序号，使用随机算法初始化值，防止**复用旧连接**后导致数据错乱

        > **因此，seq根据数据长度来增加，当没有数据时则+1**

    - ack：接收方响应的确认号，也表示期望收到对方下个报文段第一个字节的序号

    - ctl

        - SYN：前两次握手的建立控制位，由于是双向通信所以双方的第一次发送都会携带

        - ACK：有求必应，否则会触发发送方的超时重传机制

        - FIN：关闭连接的第一、三次挥手

# **2. TCP三次握手**

1. client向server发送SYN报文段（seq=client_isn），状态变为SYN_SEND

2. server接收到SYN报文段，并发送SYN+ACK报文段（seq=server_isn，ack=client_isn + 1）表示接收发起方的连接请求，状态由LISTEN进入SYN_RCVD

3. client接收到server的ack，状态由SYN_SEND进入ESTABLISHED，再返回ACK报文段给server（seq=client_isn + 1, ack=server_isn + 1）

server最终接收到第三次握手后，进入ESTABLISHED

**问题1：为什么不是2次？**

- **阻止网络时延造成的重复、历史连接初始化**

    当网络出现时延时，第一次握手和第二次握手超过RTT（往返时间）后，将触发发起方`超时重传`，产生新的第一次握手包
    
    如果没有第三次握手，则接收端只能为全部重传的握手包都建立连接，产生了重复多个的历史连接
    
    > 这种思路就是通过第三次握手，提供给client纠正的机会，由client检查错误ack并提供RST报文给服务端进行修正

- 确保双方的初始化序列号都被同步接收

    对于server端而言，如果没有第3次握手，将无法确保自己的seq被client端正确接收

**问题2：为什么不是4次？**

3次就够了，而且第二次握手中server端可以同时发送SYN位和ACK位的数据包

**问题3：accept()发生在三次握手的哪个阶段**

> 在第三次握手完成后，不要被哪个阶段误导了

- `第一次握手`：server为client新建socket句柄，将句柄放入到内核的半连接队列中（syn队列）

- 第二次握手：句柄仍旧在syn队列中

- `第三次握手`：将句柄从syn队列中移除，加入到全连接队列中（accept队列）

- **`第三次握手之后`**，accept()：将句柄从全连接队列中取出

**问题4：建立和处理连接用的是同一个socket吗？**

建立连接：listen_socket_fd

处理连接：client_fd

**问题5：SYN攻击是什么？如何缓解？**

恶意连接方发送第一次握手后，不再发送第三次握手，通过这种方式启动多个恶意连接占满服务方的半连接队列，从而导致服务方无法再正常为其他请求建立连接

缓解手段：

1. 指定半连接队列大小，指定队列溢出时的拒绝策略，如发送RST报文拒绝

2. 启用syn cookies算法，在第一次握手后不将该请求放入半连接队列中，转而通过syn cookies算法计算出一个随机值填充到seq中返回给对方，如果对方正常建立连接发送第三次握手，则再通过算法反解得出第一次握手时对方的数据，为请求建立句柄并放入全连接队列中

# **3. TCP四次挥手**

1. 第一次挥手：主动方发送FIN报文给被动方请求结束连接

    主动方状态：ESTABLISHED变为FIN_WAIT1

2. 第二次挥手：被动方接收FIN报文后，向客户端发送ACK报文，并开始进行数据收尾处理

    主动方状态：FIN_WAIT1变为FIN_WAIT2
    
    被动方状态：ESTABLISHED变为CLOSED_WAIT

3. 第三次挥手：被动方处理数据完毕，发送FIN报文给主动方

    主动方状态：FIN_WAIT2变为TIME_WAIT

    被动方状态：CLOSED_WAIT变为LAST_ACK

4. 第四次挥手：主动方接收到被动方的FIN包后，向被动方发送ACK，保证服务端正确关闭，并**等待2MSL**后进入CLOSED状态

    主动方状态：TIME_WAIT变为CLOSE（2MSL后）

    被动方状态：LAST_ACK变为CLOSE

**问题1：为什么要4次挥手**

FIN包：当前发送方已经没有数据要发送，但**仍可接收数据**

相较握手阶段，结束连接时被动关闭方通常还需要完成数据收尾处理和发送，所以其ACK和FIN分开发送

**问题2：为什么主动关闭方还需要等待2MSL后才能进入CLOSED状态**

MSL：数据包在网络发送中的最大生存时间，超过该时间的数据包将直接被丢弃掉

1. 防止tcp连接复用之后，**历史连接**的时延数据包影响**当前连接**的数据正确性，等待2MSL可以保证极限情况下**一来一回**的历史数据肯定都失效了

2. 辅助被动关闭方正确进入CLOSED状态，**至少会进行一次FIN包重试**，如果主动方接收到FIN包后就进入CLOSED状态，被动方将无法保证自己的FIN包是否被主动接收，从而进入长时间的LAST_ACK状态，**导致该连接在很长一段时间都无法复用**

# **4. TCP可靠性**

1. 接收方接收到数据后，计算checksum校验和并与报文中的校验和做对比，若不一致表明数据传输有误

2. 确认应答机制，有求必应，基于字节流传输的tcp连接对每个数据都进行了编号，ack的值表示接收方当前接收的数据序号

3. 当没有ack（超过RTO时间，RTO值略大于RTT值）或ack返回值重复时，触发发送方通过超时重传或快重传等机制，重发数据报文

    > 快速重传解决超时重传触发时间仍旧过久的问题，可以提前发送丢包现象并进行修复

    TCP将超时重传视作相当重要的事件，当出现超时重传时，会增大RTO的退避因子，并减少发送窗口大小限制发送速率

4. 流量控制：通过滑动窗口提升网络通信效率，应答方通过累计应答减少应答次数，并将自己的接收窗口填入TCP首部中通告对方，对方的发送窗口变为接收方的接收窗口值，通过该窗口值限制发送速率

5. 拥塞控制：控制发送窗口的增长，当出现快速重传/超时重传时，会降低窗口值与增长阈值，通过恢复阶段后才能恢复到原先的窗口大小

**5. 浏览器请求一个网站的过程**

1. 通过dns服务器解析域名获得IP地址，通过子网掩码判断IP地址是否处于同一个子网

2. 应用层构造http请求报文，传输层添加tcp首部，IP层添加IP头，数据链路层添加以太网协议首部

3. 经过路由器、交互机的传输，请求最终到达目标服务器，反向进行解析获得http报文进行处理

# **6. HTTP的工作原理（安全证书交换过程）**

https：http + SSL/TLS安全协议，在传输层三次握手后，再进行应用层上的https四次握手

1. 客户端

# **负载均衡实现方式**

# **I/O模型**

# **BIO、NIO、AIO**

# **Reactor**

# 参考
- [epoll空轮询](https://www.jianshu.com/p/3ec120ca46b2)
- [常考的 BIO，NIO，AIO 总结](https://blog.csdn.net/m0_38109046/article/details/89449305)