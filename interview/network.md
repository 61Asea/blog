# interview nine：network

# **1. tcp/ip协议**

1. TCP/IP四层模型

    - 数据链路层：物理手段将主机连接到网络中，并对比特流数据进行分组为帧数据

    - 网络层：主机之间通信，IP协议处理**数据包传输**、路由分组交换、主机间通信

    - 传输层：端到端通信，也称为**进程**与**进程**之间的通信，协议包括TCP、UDP、QUIC、ICMP

        - TCP：面向连接、**可靠的**、**基于字节流**的传输层通信协议

            - 面向连接：点对点连接，UDP则是同时向多个主机发送消息

            - 可靠：TCP尽可能保证报文到达接收端

            - 字节流：有序、重复丢弃、无边界

    - 应用层：协议实现，数据转换，建立连接，协议包括HTTP、FTP

2. TCP报文段：包括TCP首部 + 数据，首部包括序列号（seq）、确认号（ack）、控制位（ctl）、窗口

    - seq：发送方发送数据字节流的标识，首部中的序号值则是**本报文段数据**第一个字节在整个TCP连接中的序号，使用随机算法初始化值，防止**复用旧连接**后导致数据错乱

        > **因此，seq根据数据长度来增加，当没有数据时则+1**

    - ack：接收方响应的确认号，也表示期望收到对方下个报文段第一个字节的序号

    - ctl

        - SYN：前两次握手的建立控制位，由于是双向通信所以双方的第一次发送都会携带

        - ACK：有求必应，否则会触发发送方的超时重传机制

        - FIN：关闭连接的第一、三次挥手

# **2. TCP三次握手**

1. client向server发送SYN报文段（seq=client_isn），状态变为SYN_SEND

2. server接收到SYN报文段，并发送SYN+ACK报文段（seq=server_isn，ack=client_isn + 1）表示接收发起方的连接请求，状态由LISTEN进入SYN_RCVD

3. client接收到server的ack，状态由SYN_SEND进入ESTABLISHED，再返回ACK报文段给server（seq=client_isn + 1, ack=server_isn + 1）

server最终接收到第三次握手后，进入ESTABLISHED

**问题1：为什么不是2次？**

- **阻止网络时延造成的重复、历史连接初始化**

    当网络出现时延时，第一次握手和第二次握手超过RTT（往返时间）后，将触发发起方`超时重传`，产生新的第一次握手包
    
    如果没有第三次握手，则接收端只能为全部重传的握手包都建立连接，产生了重复多个的历史连接
    
    > 这种思路就是通过第三次握手，提供给client纠正的机会，由client检查错误ack并提供RST报文给服务端进行修正

- 确保双方的初始化序列号都被同步接收

    对于server端而言，如果没有第3次握手，将无法确保自己的seq被client端正确接收

**问题2：为什么不是4次？**

3次就够了，而且第二次握手中server端可以同时发送SYN位和ACK位的数据包

# **3. TCP四次挥手**

1. 

2. 

3. 

# **4. TCP可靠性**

# **HTTP**

# **HTTPS安全证书交换过程**

# **负载均衡实现方式**

# **I/O模型**

# **BIO、NIO、AIO**

# **Reactor**

# 参考
- [epoll空轮询](https://www.jianshu.com/p/3ec120ca46b2)
- [常考的 BIO，NIO，AIO 总结](https://blog.csdn.net/m0_38109046/article/details/89449305)