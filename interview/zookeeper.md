# interview eleven：zookeeper

# **1. Zookeeper的理解**

分布式协调的集中式服务，目标是提供高可用、顺序访问控制的能力，也用于解决分布式环境下**一致性**的问题

具有以下特点：

- 顺序一致性 ：leader会根据请求顺序生成**ZXID**，加入到**队列**中严格保证按照FIFO顺序执行

- 原子性 ：所有事务请求的处理结果在整个集群中所有机器上都是一致的；不存在部分机器应用了该事务，而另一部分没有应用的情况

    > 只要有机器应用了事务，最终一定会通过master选举和**宕机恢复**恢复

    假设leader在发送了部分commit后宕机，会通过从follower中重新选举，将当前事务ID最大的结点作为新leader，后续再**通过数据同步达到数据一致性**

- 单一视图 ：所有客户端看到的服务端数据模型都是一致的

    依旧会有不一致的情况出现，来源于**过半写入机制**，结点只要有过半写入成功即代表整个集群写入成功，如果恰好有请求打在**未写入完毕**的结点，会出现查询不一致的情况

    > 我们在讨论CAP时，**默认忽略延迟**导致的一致性问题，zk只能保证在一段时间后数据必定进入**最终一致性**

- 可靠性 ：一旦服务端成功应用了一个事务，则其引起的改变会一直保留，直到被另外一个事务所更改

    

- 实时性 ：一旦一个事务被成功应用后，Zookeeper可以保证客户端立即可以读取到这个事务变更后的最新状态的数据

# **zk运用场景**

# **zk集群架构**

- 基于Leader的非对等部署（单点写一致性）

- 过半机制（防脑裂）

# **master选举**

# **数据同步**

proposal

minCommittedLog

maxCommittedLog

# **如何保证顺序一致性（ZAB）**

# **数据不一致场景**

# **znode数据结构**

# **watcher**

# **zk实现分布式锁**

# **如何理解CAP**

# 参考
- [Zookeeper夺命连环9问](https://mp.weixin.qq.com/s?__biz=MzkzNTEwOTAxMA==&mid=2247488995&idx=1&sn=990d099cd9724931da9a414da549d093&chksm=c2b25d1ef5c5d40821fe69e42fadb96312c02654ffb921cddc9801c8ab3c4f4d3e5cae2b0b9c&token=982147105&lang=zh_CN&scene=21#wechat_redirect)

- [主流微服务注册中心浅析和对比](https://my.oschina.net/yunqi/blog/3040280)