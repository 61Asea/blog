# **4. 回收算法有哪些？**

标记-清除算法：通过GC ROOT标记所有活的对象，再线性遍历堆内存，记录死亡对象的内存到空闲列表中

- 优点：效率中等，实现简单

- 缺点：产生内存碎片，导致后续分配效率低下

- 应用：CMS、G1

- mark阶段与存活对象数量成正比，sweep阶段耗时与**整堆大小**成正比

复制算法：将内存分为相等大小的两个区域，每次只使用其中的一块。回收时将所有存活对象拷贝到另一块空的内存区域中，并将当前内存区域清空

- 优点：效率最快

- 缺点：一半的内存空间浪费

- 应用：G1、大多数分代收集器的年轻代

- 耗时与**存活对象大小**成正比

标记-整理算法：通过GC ROOT标记所有活的对象，再将存活的对象全部移动到连续内存块的一边

- 优点：不会产生内存碎片

- 缺点：效率最低

- 应用：HotSpot大多数老年代的回收算法

- mark阶段与**存活对象的数量**成正比，compact阶段耗时与**存活对象的大小**成正比

`compact、copying、sweep、mark的效率排行`：

    compact >= copying > mark > sweep

    mark + sweep > copying

## **统一答复**

回收算法主要分为三类：标记清除、复制、标记整理，第一种算法是通过GC ROOT标记所有存活对象，并线性遍历堆内存的非存活对象进行清除，清除是通过空闲列表记录而不是真正的清空；第二种算法，则是将内存区域分为两块相同大小，使用时只使用一块，当触发回收时将使用中的内存区域存活对象拷贝到另一块空的内存区域中，并清空当前的内存区域；第三种算法，也是通过GC ROOT标记所有存活对象，后将所有存活对象移动到内存区域的一边，并清除掉边界以外的其他内存区域

# **5. GC ROOT是什么？有哪些GC ROOT**

GC ROOT是追踪式GC的起点，这些引用都是当前活跃存活的对象引用，从起点往下开始搜索走过的路径称为引用链，当一个对象到GC ROOT没有任何引用链相连，则判定该对象是可被回收的

- 所有线程的虚拟机栈中的局部变量表（主要）

- 本地方法栈中引用的对象

- 类的静态属性、常量池属性

`跨代引用`：在young gen之上，维护一个记忆集（卡表）来对老年代的内存区域进行标记，存在跨代引用的区域会被写为脏页，写脏页的动作通过写屏障实现

YGC：

- GC ROOTS：基础GC ROOTS + 跨代引用（但是GC ROOTS只扫描指向young gen的那部分引用，一个子集）

    由于只收集young gen，所以gc root出发遍历到的节点是old gen时，则不会继续遍历直接忽视，因为大部分情况下扫描到old gen节点后，其下一个节点大概率也为old gen节点
     
    然而，还是存在old引用young的情况，所以为了程序的正确性，将old gen的对象都视为活的，并将**存在跨代引用**的部分加入到gc root中，这部分是需要遍历到尾部的

- 扫描区域：young gen

FGC：

- GC ROOTS：基础GC ROOTS（会扫描全部引用）

- 扫描区域：old gen

## **统一回复**

GC ROOTS是tracing gc的起点，根据起点往下遍历获得的引用链上的引用，都被认为是存活对象，反之为死亡对象

GC ROOT的范围：

- 所有线程虚拟机栈栈帧上的局部变量表
- 本地方法栈栈帧引用的对象
- 类静态属性、常量池属性

# **5附加题：分代的优势**

传统GC：整个过程需要stop the world，分代可以减少需要检查的对象数量，缩短STW的耗时

并发GC：不存在STW，分代是为了更快的触发回收，并更快的获得空闲内存区域，以满足与此同时一直上升的分配需要

# **6. **

# 参考
- [类加载的代码解析](https://blog.csdn.net/yangcheng33/article/details/52631940)

# 重点参考
- [并发垃圾收集器（CMS）为什么没有采用标记-整理算法来实现？](https://hllvm-group.iteye.com/group/topic/38223#post-248757)