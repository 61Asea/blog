# Interview：JVM

- JVM内存区域
- 类初始化过程（加载、连接、初始化）
- 双亲委派机制（破坏双亲委派机制）
- 三大回收算法
- CMS工作原理
- G1工作原理
- Full GC排查
- 参数调优

# **1. JVM内存布局**

包括：`堆`、`虚拟机栈`、元空间、本地方法栈、程序计数器

- 堆：**线程共享**内存区域，基本上所有的**对象实例都在堆上**分配，堆细分为**Young区**和**Old区**（默认比例是1:2），新生代又可细分为**Eden、S0、S1**三个部分（默认比例是8:1:1）

    - TLAB：减少指针碰撞（防止多线程在连续地址上分配对象出现的竞争问题），为每个线程都分配一个私有的堆区域，**提升对象分配的效率**

    - 字符串常量池

    - 静态常量池：符号引用、字面量

- 栈：**线程私有**内存区域，方法**执行时创建一个栈帧**，方法的**调用过程对应入栈和出栈**过程，栈帧包括局部变量表、操作数栈、动态连接、方法返回地址

    - 局部变量表：存储方法参数和**局部变量**，对应JMM工作内存

    - 操作数栈：JVM执行引擎基于操作数栈，它用于**准备和接收**操作返回的结果，是**工作内存变量的副本**，并通过ASSIGN将副本值冲刷回工作内存

    - 动态连接：将类方法的**符号引用**转换为方法的直接引用

- 元空间：**线程私有**内存区域，取代1.7之前的方法区（后者属于堆内存的一部分）

    > 新版实现将**字符串常量池、静态常量池移入堆内**，将运行时常量池、类元数据挪到**直接内存**

    - 运行时常量池：类**加载**时将静态常量池的内容加载到该区域，常量无需在编译期指定，具备**动态性**

        - 池作用：减少对象重复**创建和销毁的开销**，合并相同结果的常量**减少内存占用**，对于字符串常量而言==比equals更为高效（**只需对比引用地址**）

    - 相比永久代优点：

        - 回收困难（字符串常量池放入堆中原因）

        - 无需像方法区一样指定大小，过小导致OOM，过大导致内存浪费

- 本地方法栈：**线程私有**内存区域，类似虚拟机栈，对应native方法的调用

- 程序计数器：**线程私有**内存区域，记录**线程正在执行的字节码指令地址**，保存状态以在线程切换后能恢复到正确位置，以及处理程序控制流（if、switch、try）

## 统一答复

堆、虚拟机栈、程序计数器、元空间、本地方法栈，其中：

- 堆属于线程共享区域，用于分配基本所有的对象实例数组，大体上分为新生代和老年代，新生代具体又划分为Eden、S0、S1

- 栈是线程私有区域，方法执行时创建栈帧，栈帧保存方法内局部变量，并随着方法调用过程入栈和出栈

- 元空间保存类加载后的元数据信息，以及静态/运行时常量池

# **2. new对象过程（类加载过程）**

包括：加载、连接（验证、准备、解析）、初始化，各个步骤不是串行，而是交替进行

- 加载：校验当前类是否已经加载，并将静态常量池中符号引用等内容加载到运行时常量池中

    则将**字节码内容**加载为**内存二进制流**，class文件的获取途径不限于class文件，加载完毕后类元数据将存于元空间中

- 连接：

    - 验证：校验内容的魔数值等，保证class文件符合JVM虚拟机规范，加载过程中需要验证过程校验文件合法性

    - 准备：正式为**类变量**分配内存，并设置静态变量、常量的初始零值

    - 解析：将常量池中的符号引用（描述引用的目标）解析为方法的直接引用（指针或句柄）

- 初始化：执行\<cinit>方法（**static块**），为类变量赋值；执行\<init>方法（**构造函数**），为类成员变量赋值，若无赋值动作则采用类型默认零值

    这也是为什么类成员变量无需赋值也可用，但局部变量没赋值会报错

**初始化的时机**：

6大主动引用，其余都是被动引用情况，被动引用情况下类不会初始化：

- 遇到`new`、`getstatic`、`putstatic`或`invokestatic`这四条字节码指令时

    > getstatic：遇到final修饰的常量值，其在编译时已加入静态变量池，并不会去读取子类的值

- 反射调用
- 初始化子类时，其父类需要初始化
- vm启动时指定的main类
- ...

## **统一答复**

如果类没有加载，会执行加载、连接、初始化过程，连接又分为验证、准备、解析三个过程，这些步骤在整个过程中交替进行

- 连接阶段完毕后，**类变量**将存于元空间中，并赋零值，而**类常量**直接存于静态常量池中（带有值）

- 初始化阶段，会为实例对象分配空间、并通过\<cinit>（static）和\<init>构造函数，为**类变量**和**成员变量**进行赋值

# **2附加题：反射为什么慢**

1. method.invoke中每次都要进行参数数组包装

2. method.invoke中要进行方法可见性检查

3. accessor的java实现方式下，invoke会检查参数的类型匹配

优化思路：

jdk6：新增inflation机制，每个反射方法调用时都会生成一个委托，委托将反射调用的执行分成`native方式`和`java bytecode方式`，并配合计数器计算方法执行次数以根据频率来切换两种方式

- count < 15：使用本地方法进行反射调用

- count > 15：为方法内容生成java字节码，无需陷入内核态调用本地方法

jdk7：使用不可变的methodhandle，调用时不再检查参数匹配

- 可以采取更为激进的内联优化

- 减少了参数匹配检查

> [请问Java反射的性能为什么比直接调用慢一个数量级左右？](https://www.zhihu.com/question/30097357)

## **统一答复**

相比直接调用，反射调用多了三种开销，导致性能下降，包括：参数数组**包装开销**、方法可见性检查开销、方法参数合法性校验开销（在JDK7后已优化）、方法委托调用开销（采用inflation机制优化）

# **3. 双亲委派机制**

任意一个类，由**加载它的类加载器**和**该类本身**，共同确立其在JVM中的唯一性

## **统一答复**

自底向上查找是否已加载(findLoadedClass)：首先向上询问父加载器是否已加载，若加载则直接返回，否则询问直到最顶层父加载器为止（这个过程对于从未加载过的类而言，会一直往上走到最顶层）

自顶向下查找类数据(findClass)：当最顶层父加载器也没有加载该类时，则从当前层级向下依次尝试是否能找到该类并加载

优点：

- 避免用户自编写与类库相同的库进行覆盖，保障最基础JDK的行为

- 避免**类重复加载**，确保类在程序中的唯一性

# **3附加题：破坏双亲委派**

为什么破坏双亲委派：根据实际场景，需要相同类库的多个版本，即**无需类的唯一性行为**

> 如tomcat容器希望部署多个应用程序，每个应用程序又可能需要第三方库的不同版本，如果按照

如何破坏：自定义实现类加载器，重写loadClass方法，避免将加载递归传递给父加载器

SPI不算真正意义上的破坏双亲委派，因为其没有重写loadClass方法，而最终的第三方厂商类库仍旧由Application ClassLoader加载

只是bootstrap classloader通过线程变量保存application classloader引用，并由其辅助加载本boostrap classloader不可见的类

## **统一答复**

双亲委派机制下，每个类库在vm中是确定唯一的，然而可能有需要相同类库不同版本共存的场景，如果遵循双亲委派机制则无法实现，需要破坏原生机制

例子：tomcat的WebAppClassLoader，当遇到**非基础类库**会直接自己加载，基础类库才会委托给父加载器加载

tomcat的要求：容器与应用隔离独立、应用之间隔离独立、在一定范围内容器与应用之间、应用与应用之间需要有共享类库

![tomcat破坏双亲委派机制](https://pic2.zhimg.com/80/v2-46ac76a5a050f0b1842b75b0407044f5_720w.jpg)

# **4. 三大回收算法**

# 参考
- [JVM-10问](https://mp.weixin.qq.com/s?__biz=MzkzNTEwOTAxMA==&mid=2247485143&idx=1&sn=fd442fde5fbea90ae2314b1f7f88b1d8&chksm=c2b24e2af5c5c73c91c54d4932598e8d375803c361e2e5b52c32daa9ca200e9ac348ba4f04cb&token=982147105&lang=zh_CN&scene=21#wechat_redirect)
- [方法区/元空间](https://www.jianshu.com/p/3811a57a597e)
- [R大-JDK6的inflation机制](https://www.iteye.com/blog/rednaxelafx-548536)
- [R大-G1](https://hllvm-group.iteye.com/group/topic/44381)

# 重点参考
- [请问Java反射的性能为什么比直接调用慢一个数量级左右？](https://www.zhihu.com/question/30097357)
- [类加载器的双亲委派机制全过程](https://blog.csdn.net/m0_45406092/article/details/108976907)