# Interview：JVM

- JVM内存区域
- 类初始化过程（加载、连接、初始化）
- 双亲委派机制（破坏双亲委派机制）
- 三大回收算法
- CMS工作原理
- G1工作原理
- Full GC排查
- 参数调优

# **1. JVM内存布局**

包括：`堆`、`虚拟机栈`、元空间、本地方法栈、程序计数器

- 堆：**线程共享**内存区域，基本上所有的**对象实例都在堆上**分配，堆细分为**Young区**和**Old区**（默认比例是1:2），新生代又可细分为**Eden、S0、S1**三个部分（默认比例是8:1:1）

    - TLAB：减少指针碰撞（防止多线程在连续地址上分配对象出现的竞争问题），为每个线程都分配一个私有的堆区域，**提升对象分配的效率**

    - 字符串常量池

    - 静态常量池：符号引用、字面量

- 栈：**线程私有**内存区域，方法**执行时创建一个栈帧**，方法的**调用过程对应入栈和出栈**过程，栈帧包括局部变量表、操作数栈、动态连接、方法返回地址

    - 局部变量表：存储方法参数和**局部变量**，对应JMM工作内存

    - 操作数栈：JVM执行引擎基于操作数栈，它用于**准备和接收**操作返回的结果，是**工作内存变量的副本**，并通过ASSIGN将副本值冲刷回工作内存

    - 动态连接：将类方法的**符号引用**转换为方法的直接引用

- 元空间：**线程私有**内存区域，取代1.7之前的方法区（后者属于堆内存的一部分）

    > 新版实现将**字符串常量池、静态常量池移入堆内**，将运行时常量池、类元数据挪到**直接内存**

    - 运行时常量池：类**加载**时将静态常量池的内容加载到该区域，常量无需在编译期指定，具备**动态性**

        - 池作用：减少对象重复**创建和销毁的开销**，合并相同结果的常量**减少内存占用**，对于字符串常量而言==比equals更为高效（**只需对比引用地址**）

    - 相比永久代优点：

        - 回收困难（字符串常量池放入堆中原因）

        - 无需像方法区一样指定大小，过小导致OOM，过大导致内存浪费

- 本地方法栈：**线程私有**内存区域，类似虚拟机栈，对应native方法的调用

- 程序计数器：**线程私有**内存区域，记录**线程正在执行的字节码指令地址**，保存状态以在线程切换后能恢复到正确位置，以及处理程序控制流（if、switch、try）

## 统一答复

堆、虚拟机栈、程序计数器、元空间、本地方法栈，其中：

- 堆属于线程共享区域，用于分配基本所有的对象实例数组，大体上分为新生代和老年代，新生代具体又划分为Eden、S0、S1

- 栈是线程私有区域，方法执行时创建栈帧，栈帧保存方法内局部变量，并随着方法调用过程入栈和出栈

- 元空间保存类加载后的元数据信息，以及静态/运行时常量池

# **2. new对象过程（类加载过程）**

包括：加载、连接（验证、准备、解析）、初始化，各个步骤不是串行，而是交替进行

- 加载：校验当前类是否已经加载，并将静态常量池中符号引用等内容加载到运行时常量池中

    则将**字节码内容**加载为**内存二进制流**，class文件的获取途径不限于class文件，加载完毕后类元数据将存于元空间中

- 连接：

    - 验证：校验内容的魔数值等，保证class文件符合JVM虚拟机规范，加载过程中需要验证过程校验文件合法性

    - 准备：正式为**类变量**分配内存，并设置静态变量、常量的初始零值

    - 解析：将常量池中的符号引用（描述引用的目标）解析为方法的直接引用（指针或句柄）

- 初始化：执行\<cinit>方法（**static块**），为类变量赋值；执行\<init>方法（**构造函数**），为类成员变量赋值，若无赋值动作则采用类型默认零值

    这也是为什么类成员变量无需赋值也可用，但局部变量没赋值会报错

**初始化的时机**：

6大主动引用，其余都是被动引用情况，被动引用情况下类不会初始化：

- 遇到`new`、`getstatic`、`putstatic`或`invokestatic`这四条字节码指令时

    > getstatic：遇到final修饰的常量值，其在编译时已加入静态变量池，并不会去读取子类的值

- 反射调用
- 初始化子类时，其父类需要初始化
- vm启动时指定的main类
- ...

## **统一答复**

如果类没有加载，会执行加载、连接、初始化过程，连接又分为验证、准备、解析三个过程，这些步骤在整个过程中交替进行

- 连接阶段完毕后，**类变量**将存于元空间中，并赋零值，而**类常量**直接存于静态常量池中（带有值）

- 初始化阶段，会为实例对象分配空间、并通过\<cinit>（static）和\<init>构造函数，为**类变量**和**成员变量**进行赋值

# **2附加题：反射为什么慢**

1. method.invoke中每次都要进行参数数组包装

2. method.invoke中要进行方法可见性检查

3. accessor的java实现方式下，invoke会检查参数的类型匹配

优化思路：

jdk6：新增inflation机制，每个反射方法调用时都会生成一个委托，委托将反射调用的执行分成`native方式`和`java bytecode方式`，并配合计数器计算方法执行次数以根据频率来切换两种方式

- count < 15：使用本地方法进行反射调用

- count > 15：为方法内容生成java字节码，无需陷入内核态调用本地方法

jdk7：使用不可变的methodhandle，调用时不再检查参数匹配

- 可以采取更为激进的内联优化

- 减少了参数匹配检查

> [请问Java反射的性能为什么比直接调用慢一个数量级左右？](https://www.zhihu.com/question/30097357)

## **统一答复**

相比直接调用，反射调用多了三种开销，导致性能下降，包括：参数数组**包装开销**、方法可见性检查开销、方法参数合法性校验开销（在JDK7后已优化）、方法委托调用开销（采用inflation机制优化）

# **3. 双亲委派机制**

任意一个类，由**加载它的类加载器**和**该类本身**，共同确立其在JVM中的唯一性

## **统一答复**

自底向上查找是否已加载(findLoadedClass)：首先向上询问父加载器是否已加载，若加载则直接返回，否则询问直到最顶层父加载器为止（这个过程对于从未加载过的类而言，会一直往上走到最顶层）

自顶向下查找类数据(findClass)：当最顶层父加载器也没有加载该类时，则从当前层级向下依次尝试是否能找到该类并加载

优点：

- 避免用户自编写与类库相同的库进行覆盖，保障最基础JDK的行为

- 避免**类重复加载**，确保类在程序中的唯一性

# **3附加题：破坏双亲委派**

为什么破坏双亲委派：根据实际场景，需要相同类库的多个版本，即**无需类的唯一性行为**

> 如tomcat容器希望部署多个应用程序，每个应用程序又可能需要第三方库的不同版本，如果按照

如何破坏：自定义实现类加载器，重写loadClass方法，避免将加载递归传递给父加载器

SPI不算真正意义上的破坏双亲委派，因为其没有重写loadClass方法，而最终的第三方厂商类库仍旧由Application ClassLoader加载

只是bootstrap classloader通过线程变量保存application classloader引用，并由其辅助加载本boostrap classloader不可见的类

## **统一答复**

双亲委派机制下，每个类库在vm中是确定唯一的，然而可能有需要相同类库不同版本共存的场景，如果遵循双亲委派机制则无法实现，需要破坏原生机制

例子：tomcat的WebAppClassLoader，当遇到**非基础类库**会直接自己加载，基础类库才会委托给父加载器加载

tomcat的要求：容器与应用隔离独立、应用之间隔离独立、在一定范围内容器与应用之间、应用与应用之间需要有共享类库

![tomcat破坏双亲委派机制](https://pic2.zhimg.com/80/v2-46ac76a5a050f0b1842b75b0407044f5_720w.jpg)

# **4. 回收算法有哪些？**

标记-清除算法：通过GC ROOT标记所有活的对象，再线性遍历堆内存，记录死亡对象的内存到空闲列表中

- 优点：效率中等，实现简单

- 缺点：产生内存碎片，导致后续分配效率低下

- 应用：CMS、G1

- mark阶段与存活对象数量成正比，sweep阶段耗时与**整堆大小**成正比

复制算法：将内存分为相等大小的两个区域，每次只使用其中的一块。回收时将所有存活对象拷贝到另一块空的内存区域中，并将当前内存区域清空

- 优点：效率最快

- 缺点：一半的内存空间浪费

- 应用：G1、大多数分代收集器的年轻代

- 耗时与**存活对象大小**成正比

标记-整理算法：通过GC ROOT标记所有活的对象，再将存活的对象全部移动到连续内存块的一边

- 优点：不会产生内存碎片

- 缺点：效率最低

- 应用：HotSpot大多数老年代的回收算法

- mark阶段与**存活对象的数量**成正比，compact阶段耗时与**存活对象的大小**成正比

`compact、copying、sweep、mark的效率排行`：

    compact >= copying > mark > sweep

    mark + sweep > copying

- mark效率：与存活的对象数量成正比，因为不涉及到内存拷贝，对象再大对于该阶段而言没有影响

- sweep效率：与堆大小成正比，不涉及到内存拷贝，但是对象越大，需要记录到空闲内存编号到空闲列表耗时越大

- copying：与存活对象的大小成正比，涉及内存拷贝，所以对象越大拷贝开销越大，由于将mark、compact、修正指针等多个步骤一起执行，相对compact而言会较快

- compact：与copying类似，但取决于具体算法，compact可能先计算一次目标地址，然后修正地址，再移动对象，分布执行的开销越大

## **统一答复**

回收算法主要分为三类：标记清除、复制、标记整理：

- 第一种算法是通过GC ROOT标记所有存活对象，并线性遍历堆内存的非存活对象进行清除，清除是通过空闲列表记录而不是真正的清空

- 第二种算法，则是将内存区域分为两块相同大小，使用时只使用一块，当触发回收时将使用中的内存区域存活对象拷贝到另一块空的内存区域中，并清空当前的内存区域。**但算法存在内存利用率低的问题，所以将young gen分为了Eden和两个Survivor区，并配置以8:1:1的比例，更大程度的减小该算法对内存的浪费**

- 第三种算法，也是通过GC ROOT标记所有存活对象，后将所有存活对象移动到内存区域的一边，并清除掉边界以外的其他内存区域

# **5. GC ROOT是什么？有哪些GC ROOT**

GC ROOT是追踪式GC的起点，这些引用都是当前活跃存活的对象引用，从起点往下开始搜索走过的路径称为引用链，当一个对象到GC ROOT没有任何引用链相连，则判定该对象是可被回收的

- 所有线程的虚拟机栈中的局部变量表（主要）

- 本地方法栈中引用的对象

- 类的静态属性、常量池属性

`跨代引用`：在young gen之上，维护一个记忆集（卡表）来对老年代的内存区域进行标记，存在跨代引用的区域会被写为脏页，写脏页的动作通过写屏障实现

YGC：针对young gen的垃圾回收算法

- GC ROOTS：基础GC ROOTS + 跨代引用（但是GC ROOTS只扫描指向young gen的那部分引用，一个子集）

    由于只收集young gen，所以gc root出发遍历到的节点是old gen时，则不会继续遍历直接忽视，因为大部分情况下扫描到old gen节点后，其下一个节点大概率也为old gen节点
     
    然而，还是存在old引用young的情况，所以为了程序的正确性，将old gen的对象都视为活的，并将**存在跨代引用**的部分加入到gc root中，这部分是需要遍历到尾部的

- 扫描区域：young gen

FGC：针对全堆的垃圾回收算法

- GC ROOTS：基础GC ROOTS（会扫描全部引用）

- 扫描区域：old gen

对于三种回收算法的运用：

- 标记-清除：GC ROOT遍历完毕（具体引用链的广度由分代决定），**然后再线性遍历一遍堆内存，因为只能感知到存活对象**

- 复制：GC ROOT遍历完毕，只需要处理存活的对象，这些对象就是GC ROOT广度遍历后的结果

- 标记-清除：GC ROOT遍历完毕，只需要处理存活的对象

## **统一回复**

GC ROOTS是tracing gc的起点，根据起点往下遍历获得的引用链上的引用，都被认为是存活对象，反之为死亡对象

GC ROOT的范围：

- 所有线程虚拟机栈栈帧上的局部变量表
- 本地方法栈栈帧引用的对象
- 类静态属性、常量池属性

# **5附加题1：分代的优势**

传统GC：整个过程需要stop the world，分代可以减少需要检查的对象数量，缩短STW的耗时

并发GC：不存在STW，分代是为了更快的触发回收，并更快的获得空闲内存区域，以满足与此同时一直上升的分配需要

# **5附加题2：三色标记法**

# **6. 垃圾回收器**

![回收器分类](https://asea-cch.life/upload/2022/01/%E5%9B%9E%E6%94%B6%E5%99%A8%E5%88%86%E7%B1%BB-261d097475134718b36fdcbcfa3f2dc2.webp)

新生代的垃圾收集器包括：Serial、ParNew、Parallel

- 后两者相当于Serial的多线程版本，提高了young gc的并发程度以降低STW时间

- 它们都采用copying算法

老年代的垃圾收集器包括：Serial Old、Parallel Old、CMS

- Parallel Old是Serial Old的并行版本，提高并发程度以降低STW时间，它们俩都采用标记-整理算法，收集范围是**全堆**

    > 这是由于HotSpot前身的虚拟机系列一脉相承，然而对于老年代而言对象不容易死亡，频繁的移动对象所造成的内存拷贝开销需要引起重视

- CMS：以获得最短停顿时间为目标的收集器，相对其他收集器的STW时间更短暂，可以并行收集是他的特点，使用`sweep`的方式进行回收，新生代固定搭配ParNew回收器，收集范围是**老年代对象**

分区域（后续分代）：G1，将堆均分为多个相同大小的区域，并根据区域回收价值评估，从而进行回收的算法

# **7. CMS聊一下**

思路：讲CMS的并行收集步骤、CMS的其他收集搭配、CMS回收算法导致问题以及措施

CMS特点是并行收集，期望对应用进程的暂停影响降至最小，以打造一款低延时的垃圾收集器，其并行收集过程可分为4步：

1. `initial marking（初始标记阶段）`

2. concurrent marking（并发标记阶段）

3. `final marking / remarking（最终标记/重标记阶段）`

4. cleanup（并发清除阶段）

其中第一步和第三步为STW的

本身是老年代回收器（Old gc），还会搭配ParNew收集器对新生代进行收集（Young Gc），当出现`concurrent mode fail`意味着并发收集的同时已经不满足新的分配需求，会STW执行Serial Old（Full Gc）


# 参考
- [JVM-10问](https://mp.weixin.qq.com/s?__biz=MzkzNTEwOTAxMA==&mid=2247485143&idx=1&sn=fd442fde5fbea90ae2314b1f7f88b1d8&chksm=c2b24e2af5c5c73c91c54d4932598e8d375803c361e2e5b52c32daa9ca200e9ac348ba4f04cb&token=982147105&lang=zh_CN&scene=21#wechat_redirect)
- [方法区/元空间](https://www.jianshu.com/p/3811a57a597e)
- [R大-JDK6的inflation机制](https://www.iteye.com/blog/rednaxelafx-548536)
- [类加载的代码解析](https://blog.csdn.net/yangcheng33/article/details/52631940)
- [ParNew和CMS的工作原理](https://www.jianshu.com/p/a66fa15cc64a)

# 重点参考
- [请问Java反射的性能为什么比直接调用慢一个数量级左右？](https://www.zhihu.com/question/30097357)
- [类加载器的双亲委派机制全过程](https://blog.csdn.net/m0_45406092/article/details/108976907)

- [R大-HotSpot VM的开发历史和实现细节](https://hllvm-group.iteye.com/group/topic/37095#post-242695)
- [R大-G1](https://hllvm-group.iteye.com/group/topic/44381)
- [R大-并发垃圾收集器（CMS）为什么没有采用标记-整理算法来实现？](https://hllvm-group.iteye.com/group/topic/38223#post-248757)
- [R大-Major GC和Full GC的区别是什么？触发条件呢？](https://www.zhihu.com/question/41922036/answer/93079526)
- [R大-copying具体实现](https://hllvm-group.iteye.com/group/topic/39376#post-257329)
- [R大-CMS、FullGC以及压缩碎片](https://hllvm-group.iteye.com/group/topic/28854)