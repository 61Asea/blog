# Interview One：JVM

- JVM内存区域
- 类初始化过程（加载、连接、初始化）
    - 反射为什么慢
- 双亲委派机制（破坏双亲委派机制）
    - 破坏双亲委派
- 三大回收算法
- GC ROOT
    - 分代的优势
    - 并发三色标记
- CMS工作原理
- G1工作原理
- Full GC排查
- 参数调优

# **1. JVM内存布局**

包括：`堆`、`虚拟机栈`、元空间、本地方法栈、程序计数器

- 堆：**线程共享**内存区域，基本上所有的**对象实例都在堆上**分配，堆细分为**Young区**和**Old区**（默认比例是1:2），新生代又可细分为**Eden、S0、S1**三个部分（默认比例是8:1:1）

    - TLAB：减少指针碰撞（防止多线程在连续地址上分配对象出现的竞争问题），为每个线程都分配一个私有的堆区域，**提升对象分配的效率**

    - 字符串常量池

        池作用：减少对象重复**创建和销毁的开销**，合并相同结果的常量**减少内存占用**，对于字符串常量而言==比equals更为高效（**只需对比引用地址**）

    - 静态常量池：符号引用、字面量

- 栈：**线程私有**内存区域，方法**执行时创建一个栈帧**，方法的**调用过程对应入栈和出栈**过程，栈帧包括局部变量表、操作数栈、动态连接、方法返回地址

    - 局部变量表：存储方法参数和**局部变量**，对应JMM工作内存

    - 操作数栈：JVM执行引擎基于操作数栈，它用于**准备和接收**操作返回的结果，是**工作内存变量的副本**，并通过ASSIGN将副本值冲刷回工作内存

    - 动态连接：将类方法的**符号引用**转换为方法的直接引用

- 元空间：**线程公有**内存区域，取代1.7之前的方法区（后者属于堆内存的一部分）

    > 新版实现将**字符串常量池、静态常量池移入堆内**，将运行时常量池、类元数据挪到**直接内存**

    - 运行时常量池：类**加载**时将静态常量池的内容加载到该区域，常量无需在编译期指定，具备**动态性**

        - 池作用：减少对象重复**创建和销毁的开销**，合并相同结果的常量**减少内存占用**，对于字符串常量而言==比equals更为高效（**只需对比引用地址**）

    - 相比永久代优点：

        - 回收比永久代简单，也是字符串常量池放入堆的原因

            永久代下大量使用字符串时，容易出现OOM异常，因为永久代的回收条件较为苛刻

        - 无需像方法区一样指定大小，过小导致OOM，过大导致内存浪费

- 本地方法栈：**线程私有**内存区域，类似虚拟机栈，对应native方法的调用

- 程序计数器：**线程私有**内存区域，记录**线程正在执行的字节码指令地址**，保存状态以在线程切换后能恢复到正确位置，以及处理程序控制流（if、switch、try）

## 关键点：

TLAB：减少指针碰撞的情况，为每个线程提供一个私有内存区域，提升对象分配的效率

栈上分配：不会逃逸出方法外的对象变量，会随着方法的调用开始与结束，直接在栈上分配。以此省去gc负担

标量替换：通过逃逸分析确定该对象不会被外部访问，且对象可以进一步分解时，JVM不会创建该对象，而是创建它的成员变量进行替换

## 统一答复

**堆**、虚拟机栈、程序计数器、元空间、本地方法栈，其中：

- 堆属于线程共享区域，用于分配基本所有的对象实例数组，大体上分为新生代和老年代，新生代具体又划分为Eden、S0、S1

    - young : old 为 1:2，95%的新对象创建销毁十分快速

    - Eden : S0 : S1 为 8 : 1 : 1，在拷贝回收算法上，将Eden的存活对象拷贝到S0或S1中，S0和S1交替清空使用

        copying算法存在内存利用率低的问题，所以将young gen分为了Eden和两个Survivor区，并配置以8:1:1的比例，更大程度的减小该算法对内存的浪费

- 栈是线程私有区域，方法执行时创建栈帧，栈帧保存方法内局部变量，并随着方法调用过程入栈和出栈

- 元空间保存类加载后的元数据信息，以及静态/运行时常量池

# **2. new对象过程（类加载过程）**

包括：加载、连接（验证、准备、解析）、初始化，各个步骤不是串行，而是交替进行

- 加载：校验当前类是否已经加载，并将静态常量池中符号引用等内容加载到运行时常量池中

    则将**字节码内容**加载为**内存二进制流**，class文件的获取途径不限于class文件，加载完毕后类元数据将存于元空间中

- 连接：

    - 验证：校验内容的魔数值等，保证class文件符合JVM虚拟机规范，加载过程中需要验证过程校验文件合法性

    - 准备：正式为**类变量**分配内存，并设置静态变量、常量、类变量的初始零值

    - 解析：将常量池中的符号引用（描述引用的目标）解析为方法的直接引用（指针或句柄）

- 初始化：执行\<cinit>方法（**static块**），为类变量赋值；执行\<init>方法（**构造函数**），为类成员变量赋值，若无赋值动作则采用类型默认零值

    这也是为什么类成员变量无需赋值也可用，但局部变量没赋值会报错

**初始化的时机**：

6大主动引用，其余都是被动引用情况，被动引用情况下类不会初始化：

- 遇到`new`、`getstatic`、`putstatic`或`invokestatic`这四条字节码指令时

    > getstatic：遇到final修饰的常量值，其在编译时已加入静态变量池，并不会去读取子类的值

- 反射调用
- 初始化子类时，其父类需要初始化
- vm启动时指定的main类
- ...

## **统一答复**

如果类没有加载，会执行加载、连接、初始化过程，连接又分为验证、准备、解析三个过程，这些步骤在整个过程中交替进行

- 连接阶段完毕后，**类变量**将存于元空间中，并赋零值（注意不是类成员变量）；而**类常量**直接存于静态常量池中（带有值）

- 初始化阶段，会为实例对象分配空间、并通过\<cinit>（static）和\<init>构造函数，为**类变量**和**类成员变量**进行赋值

# **2附加题：反射为什么慢**

1. method.invoke中每次都要进行参数数组包装

2. method.invoke中要进行方法可见性检查

3. accessor的java实现方式下，invoke会检查参数的类型匹配

优化思路：

jdk6：新增inflation机制，每个反射方法调用时都会生成一个委托，委托将反射调用的执行分成`native方式`和`java bytecode方式`，并配合计数器计算方法执行次数以根据频率来切换两种方式

- count < 15：使用本地方法进行反射调用

- count > 15：为方法内容生成java字节码，无需陷入内核态调用本地方法

jdk7：使用不可变的methodhandle，调用时不再检查参数匹配

- 可以采取更为激进的内联优化

- 减少了参数匹配检查

> [请问Java反射的性能为什么比直接调用慢一个数量级左右？](https://www.zhihu.com/question/30097357)

## **统一答复**

相比直接调用，反射调用多了四种开销，导致性能下降，包括：参数数组**包装开销**、方法可见性检查开销、方法参数合法性校验开销、方法委托调用开销（invoke本地方法调用）

因此，jdk6和jdk7对反射进行了以下优化：

- 参数合法性检查开销：在JDK7之后采用不可变的methodhandle优化，只在链接方法时对参数检查，调用时不再进行检查

- 委托调用开销：采用inflation机制，根据反射调用次数决定使用本地方法调用还是生成java字节码以便更高效调用

# **3. 双亲委派机制**

任意一个类，由**加载它的类加载器**和**该类本身**，共同确立其在JVM中的唯一性

## **统一答复**

**自底向上**查找是否已加载(findLoadedClass)：首先向上询问父加载器是否已加载，若加载则直接返回，否则询问直到最顶层父加载器为止（这个过程对于从未加载过的类而言，会一直往上走到最顶层）

自顶向下查找类数据(findClass)：当最顶层父加载器也没有加载该类时，则从当前层级向下依次尝试是否能找到该类并加载

优点：

- 避免用户自编写与类库相同的库进行覆盖，保障最基础JDK的行为

- 避免**类重复加载**，确保类在程序中的唯一性

# **3附加题：破坏双亲委派**

为什么破坏双亲委派：根据实际场景，需要相同类库的多个版本，即**无需类的唯一性行为**

> 如tomcat容器希望部署多个应用程序，每个应用程序又可能需要第三方库的不同版本

**如何破坏**：自定义实现类加载器，重写loadClass方法，避免将加载递归传递给父加载器

SPI：

不算真正意义上的破坏双亲委派，因为其没有重写loadClass方法，仍旧将加载传递到了上层Bootstrap ClassLoader，而最终的第三方厂商类库仍旧由Application ClassLoader加载

只是bootstrap classloader通过线程变量保存application classloader引用，并由其辅助加载原本boostrap classloader不可见的类

![tomcat破坏双亲委派机制](https://pic2.zhimg.com/80/v2-46ac76a5a050f0b1842b75b0407044f5_720w.jpg)

## **统一答复**

双亲委派机制下，每个类库在vm中是确定唯一的，然而可能有需要相同类库不同版本共存的场景，如果遵循双亲委派机制则无法实现，需要破坏原生机制

例子：tomcat的WebAppClassLoader，当遇到**非基础类库**不会委派给父类加载器而是直接自己加载，基础JDK类库才会委托给父加载器采用默认的双亲委派机制进行加载

tomcat的要求：容器与应用隔离独立、应用之间隔离独立、在一定范围内容器与应用之间、应用与应用之间需要有共享类库

# **4. 回收算法有哪些？**

标记-清除算法：通过GC ROOT标记所有活的对象，再线性遍历堆内存，记录死亡对象的内存到空闲列表中

- 优点：效率中等，实现简单

- 缺点：产生内存碎片，导致后续分配效率低下

- 应用：CMS、G1

- mark阶段与存活对象数量成正比，sweep阶段耗时与**整堆大小**成正比

复制算法：将内存分为相等大小的两个区域，每次只使用其中的一块。回收时将所有存活对象拷贝到另一块空的内存区域中，并将当前内存区域清空

- 优点：效率最快

- 缺点：一半的内存空间浪费

- 应用：G1、大多数分代收集器的年轻代

- 耗时与**存活对象大小**成正比

标记-整理算法：通过GC ROOT标记所有活的对象，再将存活的对象全部移动到连续内存块的一边

- 优点：不会产生内存碎片

- 缺点：效率最低

- 应用：HotSpot大多数老年代的回收算法

- mark阶段与**存活对象的数量**成正比，compact阶段耗时与**存活对象的大小**成正比

`compact、copying、sweep、mark的效率排行`：

    compact >= copying > mark > sweep

    mark + sweep > copying

- mark效率：与存活的对象数量成正比，因为不涉及到内存拷贝，对象再大对于该阶段而言没有影响

- sweep效率：与堆大小成正比，不涉及到内存拷贝，但是对象越大，需要记录到空闲内存编号到空闲列表耗时越大

- copying：与存活对象的大小成正比，涉及内存拷贝，所以对象越大拷贝开销越大，由于将mark、compact、修正指针等多个步骤一起执行，相对compact而言会较快

- compact：与copying类似，但取决于具体算法，compact可能先计算一次目标地址，然后修正地址，再移动对象，分布执行的开销越大

## **统一答复**

回收算法主要分为三类：标记清除、复制、标记整理

- 第一种算法是通过GC ROOT标记所有存活对象，并线性遍历堆内存的非存活对象进行清除，清除是通过空闲列表记录而不是真正的清空

- 第二种算法，则是将内存区域分为两块相同大小，使用时只使用一块，当触发回收时将使用中的内存区域存活对象拷贝到另一块空的内存区域中，并清空当前的内存区域。**但算法存在内存利用率低的问题，所以将young gen分为了Eden和两个Survivor区，并配置以8:1:1的比例，更大程度的减小该算法对内存的浪费**

- 第三种算法，也是通过GC ROOT标记所有存活对象，后将所有存活对象移动到内存区域的一边，并清除掉边界以外的其他内存区域

# **5. GC ROOT是什么？有哪些GC ROOT**

GC ROOT是追踪式GC的起点，这些引用都是当前活跃存活的对象引用，从起点往下开始搜索走过的路径称为引用链，当一个对象到GC ROOT没有任何引用链相连，则判定该对象是可被回收的

- 所有线程的虚拟机栈中的局部变量表（主要）

- 本地方法栈中引用的对象

- 类的静态属性、常量池属性

`跨代引用`：在young gen之上，维护一个记忆集（卡表）来对老年代的内存区域进行标记，存在跨代引用的区域会被写为脏页，写脏页的动作通过写屏障实现

YGC：针对young gen的垃圾回收算法

- GC ROOTS：基础GC ROOTS + 跨代引用

    > 基础GC ROOTS只扫描指向young gen的那部分引用，不同于FGC，同样是基础GC ROOTS在遍历到节点为old gen时，依旧会往下遍历

    由于只收集young gen，所以gc root出发遍历到的节点是old gen时，则不会继续遍历直接忽视，因为大部分情况下扫描到old gen节点后，其下一个节点大概率也为old gen节点
     
    `存在old引用young的情况`，为了程序的正确性防止漏扫描到这种情况下的young，所以额外增加**跨代引用**的old gen部分加入到gc root中。这部分是需要遍历到尾部的，以**获取到完整的young对象**

- 扫描区域：young gen

FGC：针对全堆的垃圾回收算法

- GC ROOTS：基础GC ROOTS（会扫描全部引用）

- 扫描区域：old gen

对于三种回收算法的运用：

- 标记-清除：GC ROOT遍历完毕（具体引用链的广度由分代决定），**然后再线性遍历一遍堆内存（因为只能感知到存活对象）**

- 复制：GC ROOT遍历完毕，只需要处理存活的对象，这些对象就是GC ROOT广度遍历后的结果

- 标记-整理：GC ROOT遍历完毕，只需要处理存活的对象，与复制算法基本相同

## **统一回复**

GC ROOTS是tracing gc的起点，根据起点往下遍历（广度优先）以获得的引用链上的引用，被遍历到的认为是存活对象，否则为死亡对象

GC ROOT的范围：

- **所有线程虚拟机栈栈帧上的局部变量表**
- 本地方法栈栈帧引用的对象
- 类静态属性、常量池属性

# **5附加题1：分代的优势**

传统GC：整个过程需要stop the world，分代可以减少需要检查的对象数量，缩短STW的耗时

并发GC：STW的影响较小，所以分代是为了更快的触发回收，并更快的获得空闲内存区域，以满足与此同时一直上升的分配需要

# **5附加题2：三色标记法**

结合下文G1和CMS的三阶段观看

# **6. 垃圾回收器**

<!-- ![回收器分类](https://asea-cch.life/upload/2022/01/%E5%9B%9E%E6%94%B6%E5%99%A8%E5%88%86%E7%B1%BB-261d097475134718b36fdcbcfa3f2dc2.webp) -->

新生代的垃圾收集器包括：Serial、ParNew、Parallel

- 后两者相当于Serial的多线程版本，提高了young gc的并发程度以降低STW时间

- 它们都采用copying算法

老年代的垃圾收集器包括：Serial Old、Parallel Old、CMS

- Parallel Old：Serial Old的并行版本，提高并发程度以降低STW时间，它们俩都采用标记-整理算法，收集范围是**全堆**

    > 其实对于老年代，使用标记-整理算法并不是最优解，对于老年代而言对象不容易死亡，频繁的移动对象所造成的内存拷贝开销不容忽视。HotSpot系列使用mark-compact，是因为其前身的虚拟机系列的一脉相承

- CMS：以获得最短停顿时间为目标的收集器，相对其他收集器的STW时间更短暂，可以并行收集是他的特点，使用`sweep`的方式进行回收，新生代固定搭配ParNew回收器，收集范围是**老年代对象**

分区域（后续分代）：G1，将堆均分为多个相同大小的区域，并根据区域回收价值评估，从而进行回收的算法

- ParNew 与 CMS配合使用，但在后续jdk版本已废弃cms

# **7. CMS聊一下**

思路：讲CMS的并行收集步骤、CMS的其他收集搭配、CMS回收算法导致问题以及措施

CMS特点是并行收集，期望对应用进程的暂停影响降至最小，以打造一款低延时的垃圾收集器，其并行收集过程可分为4步，其中第一步和第三步为STW的：

1. `initial marking（初始标记阶段）`

2. concurrent marking（并发标记阶段）：三色标记，使用写屏障实现增量更新机制，记录引用关系的插入

3. `final marking / remarking（最终标记/重标记阶段）`：出现长时间停顿的可能所在阶段

    使用增量更新机制，所以该阶段需要重新扫描根集合以保证对象安全，防止误回收，深层原因是：
    
    - 某些赋值字节码如`astore_X`指令无法使用写屏障（能使用写屏障的指令：putstatic、putfield、aastore）
    
    由于CMS收集的是old gen区域，且并没有像young gen跨代引用的机制（通过记忆集记录），所以无法感知到young gen哪些对象是存活，在扫描时需加入整个young gen（**已经被标记的了就无需再扫描**）

4. cleanup（并发清除阶段）

    本身是老年代回收器（Old gc），还会搭配ParNew收集器对新生代进行收集（Young Gc），当出现`concurrent mode fail`意味着并发收集产生过多浮动垃圾，已经不满足新的分配需求，会STW执行Serial Old（Full Gc）

问题：

- 由于remark阶段**会加入整个young gen**，如果并发标记阶段中应用进程分配大量对象，将大大增加remark阶段的耗时

    问题：在应用分配速率较高时，该阶段的stop the world时间可能会很长

    措施：
        
    - 控制应用的分配速率处于一个温和的状态

    - 设置参数，执行remarking或full gc前先执行一次young gc

- 内存碎片问题

    问题：分配较大的内存区域时受到影响

    措施：
    
    - 调整cms压缩参数，控制进程执行N次Full Gc后，在下一次Full Gc中采用mark-compact方式回收

    - 一般采用业务低峰时间手动触发full gc并搭配cms的压缩参数，对碎片进行整理

# **8. G1聊一下**

思路：G1回收步骤，G1的统计回收模型（CSet、RSet），G1回收算法导致问题以及措施

G1是一款软实时的垃圾收集器，与CMS的并发清除不同，G1的并发工作线程主要是进行global current marking（全局统计）对每个region的存活对象进行统计，并没有实质性的进行清理操作

对于G1而言，gc主要分为**young gc**和**mixed gc**：背后的并发线程定时执行global current marking，而**真实清理由正常的分代式VM GC策略触发**，并视情况切换young gc和mixed gc：

    假想G1的STW混合时间线

    启动程序
    
    -> young gc（新生代内存不足以分配）

    -> young gc（新生代内存不足以分配）

    -> young gc + initial marking（global current marking开始，搭载在young gc的STW阶段上）

    (...concurrent marking...)

    -> young gc（新生代内存不足以分配），同时伴随并发的concurrent marking

    -> final marking（并发标记完成，STW进行最终标记处理并发过程中产生的引用关系删除情况）

    -> clean up（对各个region进行统计，STW，类似mark-sweep线性遍历）

    -> mixed gc（新生代内存不足以分配触发，并结合上面得出的region详情，结合用户参数和统计模型选定某些高回报region进行回收）

    -> mixed gc

    -> young gc + initial marking

    -> ...

所以，G1在大方向上应该视为两个同时进行的过程：

- 统计过程（global concurrent marking）

    G1的`统计`过程与CMS的`回收`过程极其相似，G1有四个步骤：

    1. `initial marking`（初始标记阶段，STW）：与CMS没有什么差别，找出基础GC ROOT能直接到达的对象，压入扫描栈中

    2. concurrent marking（并发标记阶段）：三色标记，使用`写屏障 + STAB`的方式保证mutator并发操作下，对**引用删除**关系进行记录

        SATB：snapshot-at-the-beginning，快照记录在引用变化前的旧值，这种方式下的三色标记可能会产生更多的浮动垃圾，但是在**remark阶段下无需扫描整个根集合**

    3. `remark/final marking`（最终标记阶段，STW）：将SATB写屏障记录的引用进行处理

    4. `clean up`（清理阶段，STW）：清点和重置标记状态，类似与mark-sweep的线性遍历过程，但该过程并没有实质性的清理对象，而是通过维护一个外部的bitmap来记录各个region存活对象，为**G1的收益预测模型**，即mixed gc提供充足的数据支撑

- copying算法回收垃圾过程（evacuation）

    > region gc的特征：自由选择任意多个region来独立收集，构成收集集合（C-Set），CSet又由各个区域的记忆集（R-Set）组成

    最终就是将C-Set中每个region的存活对象拷贝到新的region区域中，并清空当前的region

    - young gc：选定所有处于young gen的region，可以通过控制**young gen的region个数**来控制ygc开销

    - mixed gc：选定所有处于young gen的region，外加根据global concurrent marking统计得出收集收益高的若干old gen region（在`用户指定开销参数`范围内尽可能选择）进行回收

## 统一回复

G1是一款通过预测模型计算回收区域，并进行全堆收集的垃圾收集器，region主要分为：自由分区、新生代分区、老年代分区、大对象分区，每个分区的大小可通过配置调整，默认最多2048个分区

整个G1的工作流程从大方向上可以分为两个同时进行的过程，一个是全局并发标记过程，该过程会计算出所有region的存活对象，通过模型计算高收益回收区域，该阶段不实质性回收垃圾；一个是复制算法回收过程，会**通过用户设置的停顿时间，根据可预测时间模型进行部分收集**

> CMS和G1的最大区别就是在并发标记阶段，CMS在值引用关系发生变化时记录新值，G1则记录旧值

# **9. 什么时候触发YGC和FGC？对象什么时候进入老年代？**

## YGC触发条件：

- **新对象申请内存空间时，Eden区无法满足内存分配需求，触发YGC**

- Parallel Scavenge框架下，默认要触发Full Gc前，先执行一次YGC，期望减少full gc的工作量

- CMS设置了remark前需要进行minor gc

## 对象进入老年代：

- 大对象直接进入（只生效于Serial和ParNew两款新生代收集器）

- 长期存活对象进入老年代：Survivor区的对象每经历一次YGC，年龄就加1，当达到阈值则晋升老年代（`兜底规则`）

- `动态对象年龄判定`：Survivor空间年龄累加对象大小总和大于Survivor空间的一半，年龄大于累加时最大年龄的对象就直接进入老年代（`动态规则`）

- ygc后，存活对象太多，s0或s1存放不下，此时对象直接晋升老年代

```
1. 对象经过几次垃圾回收，熬到设定的年龄阈值，就会晋升到老年代。
2. 如果直接分配大对象，该大对象超出了JVM设置的限定值，就会直接分配到老年代。
3. 在一次新生代GC后，Survivor区域中的几个年龄对象加起来超过了Survivor区内存的一半，那么根据动态年龄判定规则，从最小的年龄加起，比如年龄1+年龄2+年龄3的对象大小总和，超过了Survivor区内存的一半，此时年龄3以上的对象就会晋升老年代。
4. 新生代GC后，存活下来的对象太多，Survivor区放不下，此时对象直接晋升老年代。
————————————————
版权声明：本文为CSDN博主「绅士jiejie」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_38106322/article/details/108943731
```

## FGC触发条件：

- **老年代可分配的剩余连续空间不够**

    - YGC前，都会触发空间分配担保，若担保失败则触发Full Gc
    
        `内存分配担保`：计算old gen剩余连续空间是否满足**历代/平均晋升到老年代的对象总大小**，不满足则为担保失败，需要进行Full Gc

    - 由内存分配策略中的大对象直接进入老年代策略导致

    > 年龄晋升、动态对象年龄判断不会直接导致full gc，两者是对象进入老年代的条件（诱因），full gc是对象进入老年代后触发规则产生的结果

    相关的收集器：除了CMS外的收集器，G1也包括在内

- CMS的concurrent mode failed：出现该异常表示浮动垃圾过多，CMS处理不过来

- System.gc()：建议VM进行一次Full gc，具体是否实施视情况而定

# **10. 频繁Full Gc怎么排查**

可能性：按照对象进入老年代的条件进行思考

- 是否出现内存泄漏

    1. 查看FGC花费时间，GC后的old gen和young gen是否减少，得到初步的情况进行判断

    2. 执行`jmap -dump:format=b,file=dumpfilepid`dump出内存文件进行具体分析，通过Eclipse Memory Analyzer进行分析与定位代码

- 是否老年代对象晋升阈值过小

    查看vm参数设置是否有问题

- **堆内存太小/分代区域空间过小**

    - `Eden是否太小，导致对象频繁进入老年代，进而触发fgc`

    - `Old Gen是否太小，在回收率较低的场景下会频繁触发fgc`

    排查措施：查看每次fgc后的情况，如果剩余对象少，说明eden太小，导致**短周期对象**频繁进入old区；如果剩余对象较多，说明old回收率不高，old区域过小

- `是否一次性加载过多内存`

    - 搞出来很多大对象，触发大对象直接进入老年代策略

    - 新生代没有空间分配，触发ygc后仍旧存活（因为一次性加载，在程序内肯定还有引用），进而晋升到老年代中从而触发fgc

**附加题：CPU飙高，同时FGC怎么办**

> [一次FGC导致CPU飙高的排查过程](http://t.zoukankan.com/ismallboy-p-13023770.html)

> 一定要开启-XX:HeapDumpOnOutOfMemoryError，在oom的时候自动产生堆转储文件，不要直接使用jmap命令导致进程stw

1. `top`：查看cpu的load平均值，查找cpu占用高的`[pid]`

2. `jps -l | grep [pid]`：确定cpu高占用的pid是否为在运行的java服务进程 

3. `top -Hp [pid]`：查找进程pid对应的线程id`[tpid]（16进制）`

4. `printf "%x\n" [tpid]`：将线程id从16进制转化为10进制`[tpidA]`

5. `jstack -l [pid] | grep -A 20 [tpidA]`：查看该线程id在java进程中的的堆栈信息，确定是不是频繁fgc导致的cpu飙升

    这一步相当于辅助下面第六步，当然也可以直接通过第六步的**fgc时长**和**回收率**来做判断

6. `jstat -gc [pid] [采样间隔:1000]`：确定是GC线程，通过jstat命令查看进程的gc情况

    频繁fgc：注意查看ygct和fgct的次数变更，如果fgct累加说明在一直做fgc

    fgc耗时：总耗时都是累加值，单次耗时：本次耗时累加 - 上一次耗时累加

    - GCT：gc总耗时；FGCT：fgc总耗时；YGCT：ygc总耗时

7. `jmap -histo:live [pid] | head -20`：查看堆占用空间大小排名前20的类型，假设在发现排名第一的类为疑似问题类`[exceptionClassNameA]`，其与第6点的jstack堆栈信息基本符合

    > 注意，生产环境慎用该命令，因为会造成stw，最好将这部分内存复制到备份机中执行。

8. `jstack -l [pid] > jstack_tmp.txt`：线程堆栈导出为txt文件

    结合`grep -C 30 [exceptionClassNameA] jstack_map.txt`进一步定位对象的堆栈，观察是通过什么方式加载到堆内存的：
    - 分析是否为一次性加载过量数据

9. `jmap -dump:live,format=b,file=mat.hprof [pid]`：导出服务进程的堆转储文件

    > 依然会导致stw卡死，回答思路要靠向服务器备份。因为存在多服务器备份（高可用），停掉当前的机器并不会对整个无状态系统造成太大影响

10. mat工具分析堆转储：

    - 一般mat会直接分析出内存泄漏的问题对象，显示错误日志报告
    
    - 使用`Merge Shortest Paths to GC Roots`，合并出可达性分析的GC ROOTS，查看是哪个线程的栈帧引用
    
        需要使用`exclude all phantom/weak/soft references`排除掉可被vm的回收的引用

    - 获得引用对象的线程后，转回头结合`jstack_tmp.txt`线程堆栈日志进行分析

11. 进一步确定问题对象后，通过`jstack_tmp.txt`堆栈来分析对象初始化的问题，定位到问题代码

## 统一回复

linux系统命令：top -Hp / top

java命令：jstack（导出堆栈日志）和jmap（分析堆内存、导出堆转储文件）结合分析，排查问题是否为：
- 出现内存泄漏
- young、old区域分配不均
- 配置不够
- 一次性加载过多内存到堆中

1. 压测环境下提前发现问题

2. 在生产环境负载均衡的情况下（高可用），把出现问题的服务摘出来，再把堆转储文件导出来进行分析

### 企业级生产工具：arthas（阿尔萨斯），影响性能10%～15%

- dashboard：继承了top、top -Hp、jstat，可查看线程cpu情况，堆占用情况

- heapdump：替代jmap -dump:live,format=b

- thread -b：查找产生死锁的线程，替代了jstack查找死锁的步骤

- jvm：替代jinfo

- jad [class]：在线反编译类名

- redefine [class二进制文件]：重定义class，做agent热更

- trace [class二进制文件] [方法名]：分析方法过程的瓶颈

# **11. GC参数调优**

调优是用更小的硬件获取更高的吞吐量，一般关注以下几点：

- 新生代和老年代的分配比率

    - 新生代过小，可能导致短周期对象频繁流入老年代进而频繁fgc
    - 老年代过小，可能导致回收率不高的情况下频繁fgc

- 各个收集器在不同的堆内存大小下表现不同

    ```
    其实CMS在较小的堆、合适的workload的条件下暂停时间可以很轻松的短于G1。
    
    在2011年的时候Ramki告诉我堆大小的分水岭大概在10GB～15GB左右：以下的-Xmx更适合CMS，以上的才适合试用G1。
    
    现在到了2014年，G1的实现经过一定调优，大概在6GB～8GB也可以跟CMS有一比，我之前见过有在-Xmx4g的环境里G1比CMS的暂停时间更短的案例
    ```

    原因：CMS的remark阶段是扫描整个根集合，包括了young gen，在分配速率不温和的情况下可能在concurrent marking期间产生过多新对象，从而导致remarking阶段的stw阶段更长

- G1基于开销-收益模型，在预测回收时间的设置上不宜过短

    ```
     -XX:MaxGCPauseMillis不要设得太低，不然G1跟不上目标就容易导致垃圾堆积，反而更容易引发full GC而降低性能。通常设到100ms、250ms之类的都可能是合理的。设到50ms就不太靠谱，G1可能一开始还跟得上，跑的时间一长就开始乱来了。

    这也提醒大家：如果您的程序要长时间运行，那么在技术选型评估GC性能的时候要让测试程序跑足够长时间才能看清状况。多久才够长取决于实际应用要连续运行多久。不然一个要运行一个月才重启一次的程序，如果测试的时候只测了两个小时就觉得没问题，实际上线跑起来可能正好两个半小时的时候来了一次几分钟的full GC暂停，那就纱布了⋯
    ```

- 在明确知道程序内存能跑到多少的情况下，-Xms最小堆和-Xmx最大堆设置一样大，防止内存抖动

# 12. 其它GC

Azul的C4，Red Hat的Shenendoah优化点：

- 使用某种形式的read barrier，以实现安全的一边移动对象和一边修正对象的引用，做到并发拷贝

read barrier：不记录更改值，转而记录读取对象时的值，最保守但最安全的做法

# 参考
- [JVM-10问](https://mp.weixin.qq.com/s?__biz=MzkzNTEwOTAxMA==&mid=2247485143&idx=1&sn=fd442fde5fbea90ae2314b1f7f88b1d8&chksm=c2b24e2af5c5c73c91c54d4932598e8d375803c361e2e5b52c32daa9ca200e9ac348ba4f04cb&token=982147105&lang=zh_CN&scene=21#wechat_redirect)
- [方法区/元空间](https://www.jianshu.com/p/3811a57a597e)
- [R大-JDK6的inflation机制](https://www.iteye.com/blog/rednaxelafx-548536)
- [类加载的代码解析](https://blog.csdn.net/yangcheng33/article/details/52631940)
- [ParNew和CMS的工作原理](https://www.jianshu.com/p/a66fa15cc64a)

- [G1调优实践日记--G1HeapWastePercent和InitiatingHeapOccupancyPercent的应用](https://blog.csdn.net/lovejj1994/article/details/109620239)
- [调优大全](https://blog.51cto.com/u_15746412/5575712#1__6)

# 重点参考
- [请问Java反射的性能为什么比直接调用慢一个数量级左右？](https://www.zhihu.com/question/30097357)
- [类加载器的双亲委派机制全过程](https://blog.csdn.net/m0_45406092/article/details/108976907)

- [R大-HotSpot VM的开发历史和实现细节](https://hllvm-group.iteye.com/group/topic/37095#post-242695)
- [R大-G1](https://hllvm-group.iteye.com/group/topic/44381)
- [R大-并发垃圾收集器（CMS）为什么没有采用标记-整理算法来实现？](https://hllvm-group.iteye.com/group/topic/38223#post-248757)
- [R大-Major GC和Full GC的区别是什么？触发条件呢？](https://www.zhihu.com/question/41922036/answer/93079526)
- [R大-copying具体实现](https://hllvm-group.iteye.com/group/topic/39376#post-257329)
- [R大-CMS、FullGC以及压缩碎片](https://hllvm-group.iteye.com/group/topic/28854)

# 难点
- [R大和LeafInWind-CMS的增量更新与具体代码例子，讲了为什么CMS把整个young gen加入到remarking中](https://hllvm-group.iteye.com/group/topic/44529)
- [三色标记和漏标多标总结](https://www.jianshu.com/p/12544c0ad5c1)
- [R大-G1](https://hllvm-group.iteye.com/group/topic/44381)
- [对象进入老年代的4个条件](https://blog.csdn.net/weixin_38106322/article/details/108943731)

- [视频：马士兵JVM排查问题实战](https://www.bilibili.com/video/BV1da411Q7sT?p=12&vd_source=24d877cb7ef153b8ce2cb035abac58ed)