# Interview One：JVM

- JVM内存区域
- 类初始化过程（加载、连接、初始化）
    - 反射为什么慢
- 双亲委派机制（破坏双亲委派机制）
    - 破坏双亲委派
- 三大回收算法
- GC ROOT
    - 分代的优势
    - 并发三色标记
- CMS工作原理
- G1工作原理
- Full GC排查
- 参数调优

# **1. JVM内存布局**

包括：`堆`、`虚拟机栈`、元空间、本地方法栈、程序计数器

- 堆：**线程共享**内存区域，基本上所有的**对象实例都在堆上**分配，堆细分为**Young区**和**Old区**（默认比例是1:2），新生代又可细分为**Eden、S0、S1**三个部分（默认比例是8:1:1）

    - TLAB：减少指针碰撞（防止多线程在连续地址上分配对象出现的竞争问题），为每个线程都分配一个私有的堆区域，**提升对象分配的效率**

    - 字符串常量池

    - 静态常量池：符号引用、字面量

- 栈：**线程私有**内存区域，方法**执行时创建一个栈帧**，方法的**调用过程对应入栈和出栈**过程，栈帧包括局部变量表、操作数栈、动态连接、方法返回地址

    - 局部变量表：存储方法参数和**局部变量**，对应JMM工作内存

    - 操作数栈：JVM执行引擎基于操作数栈，它用于**准备和接收**操作返回的结果，是**工作内存变量的副本**，并通过ASSIGN将副本值冲刷回工作内存

    - 动态连接：将类方法的**符号引用**转换为方法的直接引用

- 元空间：**线程公有**内存区域，取代1.7之前的方法区（后者属于堆内存的一部分）

    > 新版实现将**字符串常量池、静态常量池移入堆内**，将运行时常量池、类元数据挪到**直接内存**

    - 运行时常量池：类**加载**时将静态常量池的内容加载到该区域，常量无需在编译期指定，具备**动态性**

        - 池作用：减少对象重复**创建和销毁的开销**，合并相同结果的常量**减少内存占用**，对于字符串常量而言==比equals更为高效（**只需对比引用地址**）

    - 相比永久代优点：

        - 回收比永久代简单，也是字符串常量池放入堆的原因

            永久代下大量使用字符串时，容易出现OOM异常，因为永久代的回收条件较为苛刻

        - 无需像方法区一样指定大小，过小导致OOM，过大导致内存浪费

- 本地方法栈：**线程私有**内存区域，类似虚拟机栈，对应native方法的调用

- 程序计数器：**线程私有**内存区域，记录**线程正在执行的字节码指令地址**，保存状态以在线程切换后能恢复到正确位置，以及处理程序控制流（if、switch、try）

栈上分配：不会逃逸出方法外的对象变量，会随着方法的调用开始与结束，直接在栈上分配可以省去gc负担

TLAB：减少指针碰撞的情况，为每个线程提供一个私有内存区域，提升对象分配的效率

标量替换：通过逃逸分析确定该对象不会被外部访问，且对象可以进一步分解时，JVM不会创建该对象，而是创建它的成员变量进行替换

## 统一答复

堆、虚拟机栈、程序计数器、元空间、本地方法栈，其中：

- 堆属于线程共享区域，用于分配基本所有的对象实例数组，大体上分为新生代和老年代，新生代具体又划分为Eden、S0、S1

- 栈是线程私有区域，方法执行时创建栈帧，栈帧保存方法内局部变量，并随着方法调用过程入栈和出栈

- 元空间保存类加载后的元数据信息，以及静态/运行时常量池

# **2. new对象过程（类加载过程）**

包括：加载、连接（验证、准备、解析）、初始化，各个步骤不是串行，而是交替进行

- 加载：校验当前类是否已经加载，并将静态常量池中符号引用等内容加载到运行时常量池中

    则将**字节码内容**加载为**内存二进制流**，class文件的获取途径不限于class文件，加载完毕后类元数据将存于元空间中

- 连接：

    - 验证：校验内容的魔数值等，保证class文件符合JVM虚拟机规范，加载过程中需要验证过程校验文件合法性

    - 准备：正式为**类变量**分配内存，并设置静态变量、常量的初始零值

    - 解析：将常量池中的符号引用（描述引用的目标）解析为方法的直接引用（指针或句柄）

- 初始化：执行\<cinit>方法（**static块**），为类变量赋值；执行\<init>方法（**构造函数**），为类成员变量赋值，若无赋值动作则采用类型默认零值

    这也是为什么类成员变量无需赋值也可用，但局部变量没赋值会报错

**初始化的时机**：

6大主动引用，其余都是被动引用情况，被动引用情况下类不会初始化：

- 遇到`new`、`getstatic`、`putstatic`或`invokestatic`这四条字节码指令时

    > getstatic：遇到final修饰的常量值，其在编译时已加入静态变量池，并不会去读取子类的值

- 反射调用
- 初始化子类时，其父类需要初始化
- vm启动时指定的main类
- ...

## **统一答复**

如果类没有加载，会执行加载、连接、初始化过程，连接又分为验证、准备、解析三个过程，这些步骤在整个过程中交替进行

- 连接阶段完毕后，**类变量**将存于元空间中，并赋零值，而**类常量**直接存于静态常量池中（带有值）

- 初始化阶段，会为实例对象分配空间、并通过\<cinit>（static）和\<init>构造函数，为**类变量**和**成员变量**进行赋值

# **2附加题：反射为什么慢**

1. method.invoke中每次都要进行参数数组包装

2. method.invoke中要进行方法可见性检查

3. accessor的java实现方式下，invoke会检查参数的类型匹配

优化思路：

jdk6：新增inflation机制，每个反射方法调用时都会生成一个委托，委托将反射调用的执行分成`native方式`和`java bytecode方式`，并配合计数器计算方法执行次数以根据频率来切换两种方式

- count < 15：使用本地方法进行反射调用

- count > 15：为方法内容生成java字节码，无需陷入内核态调用本地方法

jdk7：使用不可变的methodhandle，调用时不再检查参数匹配

- 可以采取更为激进的内联优化

- 减少了参数匹配检查

> [请问Java反射的性能为什么比直接调用慢一个数量级左右？](https://www.zhihu.com/question/30097357)

## **统一答复**

相比直接调用，反射调用多了四种开销，导致性能下降，包括：参数数组**包装开销**、方法可见性检查开销、方法参数合法性校验开销、方法委托调用开销

参数合法性检查开销：在JDK7之后采用不可变的methodhandle优化，只在链接方法时对参数检查，调用时不再进行检查

委托调用开销：采用inflation机制，根据反射调用次数决定使用本地方法调用还是生成java字节码以便更高效调用

# **3. 双亲委派机制**

任意一个类，由**加载它的类加载器**和**该类本身**，共同确立其在JVM中的唯一性

## **统一答复**

自底向上查找是否已加载(findLoadedClass)：首先向上询问父加载器是否已加载，若加载则直接返回，否则询问直到最顶层父加载器为止（这个过程对于从未加载过的类而言，会一直往上走到最顶层）

自顶向下查找类数据(findClass)：当最顶层父加载器也没有加载该类时，则从当前层级向下依次尝试是否能找到该类并加载

优点：

- 避免用户自编写与类库相同的库进行覆盖，保障最基础JDK的行为

- 避免**类重复加载**，确保类在程序中的唯一性

# **3附加题：破坏双亲委派**

为什么破坏双亲委派：根据实际场景，需要相同类库的多个版本，即**无需类的唯一性行为**

> 如tomcat容器希望部署多个应用程序，每个应用程序又可能需要第三方库的不同版本，如果按照

如何破坏：自定义实现类加载器，重写loadClass方法，避免将加载递归传递给父加载器

SPI不算真正意义上的破坏双亲委派，因为其没有重写loadClass方法，而最终的第三方厂商类库仍旧由Application ClassLoader加载

只是bootstrap classloader通过线程变量保存application classloader引用，并由其辅助加载本boostrap classloader不可见的类

## **统一答复**

双亲委派机制下，每个类库在vm中是确定唯一的，然而可能有需要相同类库不同版本共存的场景，如果遵循双亲委派机制则无法实现，需要破坏原生机制

例子：tomcat的WebAppClassLoader，当遇到**非基础类库**不会委派给父类加载器而是直接自己加载，基础JDK类库才会委托给父加载器采用默认的双亲委派机制进行加载

tomcat的要求：容器与应用隔离独立、应用之间隔离独立、在一定范围内容器与应用之间、应用与应用之间需要有共享类库

![tomcat破坏双亲委派机制](https://pic2.zhimg.com/80/v2-46ac76a5a050f0b1842b75b0407044f5_720w.jpg)

# **4. 回收算法有哪些？**

标记-清除算法：通过GC ROOT标记所有活的对象，再线性遍历堆内存，记录死亡对象的内存到空闲列表中

- 优点：效率中等，实现简单

- 缺点：产生内存碎片，导致后续分配效率低下

- 应用：CMS、G1

- mark阶段与存活对象数量成正比，sweep阶段耗时与**整堆大小**成正比

复制算法：将内存分为相等大小的两个区域，每次只使用其中的一块。回收时将所有存活对象拷贝到另一块空的内存区域中，并将当前内存区域清空

- 优点：效率最快

- 缺点：一半的内存空间浪费

- 应用：G1、大多数分代收集器的年轻代

- 耗时与**存活对象大小**成正比

标记-整理算法：通过GC ROOT标记所有活的对象，再将存活的对象全部移动到连续内存块的一边

- 优点：不会产生内存碎片

- 缺点：效率最低

- 应用：HotSpot大多数老年代的回收算法

- mark阶段与**存活对象的数量**成正比，compact阶段耗时与**存活对象的大小**成正比

`compact、copying、sweep、mark的效率排行`：

    compact >= copying > mark > sweep

    mark + sweep > copying

- mark效率：与存活的对象数量成正比，因为不涉及到内存拷贝，对象再大对于该阶段而言没有影响

- sweep效率：与堆大小成正比，不涉及到内存拷贝，但是对象越大，需要记录到空闲内存编号到空闲列表耗时越大

- copying：与存活对象的大小成正比，涉及内存拷贝，所以对象越大拷贝开销越大，由于将mark、compact、修正指针等多个步骤一起执行，相对compact而言会较快

- compact：与copying类似，但取决于具体算法，compact可能先计算一次目标地址，然后修正地址，再移动对象，分布执行的开销越大

## **统一答复**

回收算法主要分为三类：标记清除、复制、标记整理

- 第一种算法是通过GC ROOT标记所有存活对象，并线性遍历堆内存的非存活对象进行清除，清除是通过空闲列表记录而不是真正的清空

- 第二种算法，则是将内存区域分为两块相同大小，使用时只使用一块，当触发回收时将使用中的内存区域存活对象拷贝到另一块空的内存区域中，并清空当前的内存区域。**但算法存在内存利用率低的问题，所以将young gen分为了Eden和两个Survivor区，并配置以8:1:1的比例，更大程度的减小该算法对内存的浪费**

- 第三种算法，也是通过GC ROOT标记所有存活对象，后将所有存活对象移动到内存区域的一边，并清除掉边界以外的其他内存区域

# **5. GC ROOT是什么？有哪些GC ROOT**

GC ROOT是追踪式GC的起点，这些引用都是当前活跃存活的对象引用，从起点往下开始搜索走过的路径称为引用链，当一个对象到GC ROOT没有任何引用链相连，则判定该对象是可被回收的

- 所有线程的虚拟机栈中的局部变量表（主要）

- 本地方法栈中引用的对象

- 类的静态属性、常量池属性

`跨代引用`：在young gen之上，维护一个记忆集（卡表）来对老年代的内存区域进行标记，存在跨代引用的区域会被写为脏页，写脏页的动作通过写屏障实现

YGC：针对young gen的垃圾回收算法

- GC ROOTS：基础GC ROOTS + 跨代引用

    > 基础GC ROOTS只扫描指向young gen的那部分引用，不同于FGC，同样是基础GC ROOTS在遍历到节点为old gen时，依旧会往下遍历

    由于只收集young gen，所以gc root出发遍历到的节点是old gen时，则不会继续遍历直接忽视，因为大部分情况下扫描到old gen节点后，其下一个节点大概率也为old gen节点
     
    存在old引用young的情况，为了程序的正确性，所以额外增加**跨代引用**的old gen部分加入到gc root中，这部分是需要遍历到尾部的

- 扫描区域：young gen

FGC：针对全堆的垃圾回收算法

- GC ROOTS：基础GC ROOTS（会扫描全部引用）

- 扫描区域：old gen

对于三种回收算法的运用：

- 标记-清除：GC ROOT遍历完毕（具体引用链的广度由分代决定），**然后再线性遍历一遍堆内存，因为只能感知到存活对象**

- 复制：GC ROOT遍历完毕，只需要处理存活的对象，这些对象就是GC ROOT广度遍历后的结果

- 标记-清除：GC ROOT遍历完毕，只需要处理存活的对象

## **统一回复**

GC ROOTS是tracing gc的起点，根据起点往下遍历获得的引用链上的引用，都被认为是存活对象，反之为死亡对象

GC ROOT的范围：

- 所有线程虚拟机栈栈帧上的局部变量表
- 本地方法栈栈帧引用的对象
- 类静态属性、常量池属性

# **5附加题1：分代的优势**

传统GC：整个过程需要stop the world，分代可以减少需要检查的对象数量，缩短STW的耗时

并发GC：STW的影响较小，所以分代是为了更快的触发回收，并更快的获得空闲内存区域，以满足与此同时一直上升的分配需要

# **5附加题2：三色标记法**

# **6. 垃圾回收器**

![回收器分类](https://asea-cch.life/upload/2022/01/%E5%9B%9E%E6%94%B6%E5%99%A8%E5%88%86%E7%B1%BB-261d097475134718b36fdcbcfa3f2dc2.webp)

新生代的垃圾收集器包括：Serial、ParNew、Parallel

- 后两者相当于Serial的多线程版本，提高了young gc的并发程度以降低STW时间

- 它们都采用copying算法

老年代的垃圾收集器包括：Serial Old、Parallel Old、CMS

- Parallel Old是Serial Old的并行版本，提高并发程度以降低STW时间，它们俩都采用标记-整理算法，收集范围是**全堆**

    > 这是由于HotSpot前身的虚拟机系列一脉相承，然而对于老年代而言对象不容易死亡，频繁的移动对象所造成的内存拷贝开销需要引起重视

- CMS：以获得最短停顿时间为目标的收集器，相对其他收集器的STW时间更短暂，可以并行收集是他的特点，使用`sweep`的方式进行回收，新生代固定搭配ParNew回收器，收集范围是**老年代对象**

分区域（后续分代）：G1，将堆均分为多个相同大小的区域，并根据区域回收价值评估，从而进行回收的算法

# **7. CMS聊一下**

思路：讲CMS的并行收集步骤、CMS的其他收集搭配、CMS回收算法导致问题以及措施

CMS特点是并行收集，期望对应用进程的暂停影响降至最小，以打造一款低延时的垃圾收集器，其并行收集过程可分为4步，其中第一步和第三步为STW的：

1. `initial marking（初始标记阶段）`

2. concurrent marking（并发标记阶段）：三色标记，使用写屏障实现增量更新机制，记录引用关系的插入

3. `final marking / remarking（最终标记/重标记阶段）`：出现长时间停顿的可能所在阶段

    使用增量更新机制，所以该阶段需要重新扫描根集合以保证安全，因为`某些赋值字节码指令无法使用写屏障`
    
    由于收集old gen区域，且young gen没有像old gen一样通过记忆集记录，扫描时还需加入整个young gen

4. cleanup（并发清除阶段）

本身是老年代回收器（Old gc），还会搭配ParNew收集器对新生代进行收集（Young Gc），当出现`concurrent mode fail`意味着并发收集产生过多浮动垃圾，已经不满足新的分配需求，会STW执行Serial Old（Full Gc）

问题：

- 由于remark阶段**会加入整个young gen**，如果并发标记阶段中应用进程分配大量对象，将大大增加remark阶段的耗时

    措施：控制应用的分配速率处于一个温和的状态

- 内存碎片问题

    措施：
    
    - cms压缩参数也会在整个进程执行N次Full Gc后，在下一次Full Gc中采用mark-compact方式回收

    - 一般采用业务低峰时间手动触发full gc并搭配cms的压缩参数，对碎片进行整理

# **8. G1聊一下**

思路：G1回收步骤，G1的统计回收模型（CSet、RSet），G1回收算法导致问题以及措施

G1是一款软实时的垃圾收集器，与CMS的并发清除不同，G1的并发工作线程主要是进行global current marking（全局统计）对每个region的存活对象进行统计，并不实质性的进行清理

对于G1而言，gc主要分为**young gc**和**mixed gc**：背后的并发线程定时执行global current marking，而**真实清理由正常的分代式VM GC策略触发**，并视情况切换young gc和mixed gc：

    假想G1的STW混合时间线

    启动程序
    
    -> young gc（新生代内存不足以分配）

    -> young gc（新生代内存不足以分配）

    -> young gc + initial marking（global current marking开始，搭载在young gc的STW阶段上）

    (...concurrent marking...)

    -> young gc（新生代内存不足以分配），同时伴随并发的concurrent marking

    -> final marking（并发标记完成，STW进行最终标记处理并发过程中产生的引用关系删除情况）

    -> clean up（对各个region进行统计，STW，类似mark-sweep线性遍历）

    -> mixed gc（新生代内存不足以分配触发，并结合上面得出的region详情，结合用户参数和统计模型选定某些高回报region进行回收）

    -> mixed gc

    -> young gc + initial marking

    -> ...

所以，G1在大方向上应该视为两个同时进行的过程：

- 统计过程（global concurrent marking）

    G1的`统计`过程与CMS的`回收`过程极其相似，G1有四个步骤：

    1. `initial marking`（初始标记阶段，STW）：与CMS没有什么差别，找出基础GC ROOT能直接到达的对象，压入扫描栈中

    2. concurrent marking（并发标记阶段）：三色标记，使用`写屏障 + STAB`的方式保证mutator并发操作下，对**引用删除**关系进行记录

        SATB：snapshot-at-the-beginning，快照记录在引用变化前的旧值，这种方式下的三色标记可能会产生更多的浮动垃圾，但是在**remark阶段下无需扫描整个根集合**

    3. `remark/final marking`（最终标记阶段，STW）：将SATB写屏障记录的引用进行处理

    4. `clean up`（清理阶段，STW）：清点和重置标记状态，类似与mark-sweep的线性遍历过程，但该过程并没有实质性的清理对象，而是通过维护一个外部的bitmap来记录各个region存活对象，为**G1的收益预测模型**，即mixed gc提供充足的数据支撑

- copying算法回收垃圾过程（evacuation）

    > region gc的特征：自由选择任意多个region来独立收集，构成收集集合（C-Set），CSet又由各个区域的记忆集（R-Set）组成

    最终就是将C-Set中每个region的存活对象拷贝到新的region区域中，并清空当前的region

    - young gc：选定所有处于young gen的region，可以通过控制**young gen的region个数**来控制ygc开销

    - mixed gc：选定所有处于young gen的region，外加根据global concurrent marking统计得出收集收益高的若干old gen region（在`用户指定开销参数`范围内尽可能选择）进行回收

## 统一回复

G1是一款通过预测模型计算回收区域，并进行全堆收集的垃圾收集器，region主要分为：自由分区、新生代分区、老年代分区、大对象分区，每个分区的大小可通过配置调整，默认最多2048个分区

整个G1的工作流程从大方向上可以分为两个同时进行的过程，一个是全局并发标记过程，该过程会计算出所有region的存活对象，通过模型计算高收益回收区域，该阶段不实质性回收垃圾；一个是复制算法回收过程，会**通过用户设置的停顿时间，根据可预测时间模型进行部分收集**

> CMS和G1的最大区别就是在并发标记阶段，CMS在值引用关系发生变化时记录新值，G1则记录旧值

# **9. 什么时候触发YGC和FGC？对象什么时候进入老年代？**

YGC触发条件：

- **新对象申请内存空间时，Eden区无法满足内存分配需求，触发YGC**

- Parallel Scavenge框架下，默认要触发Full Gc前，先执行一次YGC，期望减少full gc的工作量（奇葩）

FGC触发条件：

- **老年代可分配的剩余连续空间不够**

    - YGC前，都会触发空间分配担保，若担保失败则触发Full Gc
    
        `内存分配担保`：计算old gen剩余连续空间是否满足**历代/平均晋升到老年代的对象总大小**，不满足则为担保失败，需要进行Full Gc

    - 由内存分配策略中的大对象直接进入老年代策略导致

    > 年龄晋升、动态对象年龄判断不会导致full gc，因为这在第一点空间分配担保机制中已经包括在内了

    相关的收集器：除了CMS外的收集器，G1也包括在内

- CMS的concurrent mode failed：出现该异常表示浮动垃圾过多，CMS处理不过来

- System.gc()：建议VM进行一次Full gc，具体是否实施视情况而定

对象进入老年代：

- 大对象直接进入（只能用于Serial和ParNew两款新生代收集器）

- 长期存活对象进入老年代：Survivor区的对象每经历一次YGC，年龄就加1，当达到阈值则晋升老年代

- `动态对象年龄判定`：Survivor空间相同年龄的对象大小总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就直接进入老年代

# **10. 频繁Full Gc怎么排查**

可能性：

- 是否出现内存泄漏

- Eden是否太小，导致对象频繁进入老年代

1. 查看FGC花费时间，GC后的old gen和young gen是否减少，得到初步的情况进行判断

2. 执行`jmap -dump:format=b,file=dumpfilepid`dump出内存文件进行具体分析，通过Eclipse Memory Analyzer进行分析与定位代码

**附加题：CPU飙高，同时FGC怎么办**

1. 找到当前进程的pid：`top -p pid -H`查看资源占用，找出异常线程

2. 将异常pid转成16进制后，使用`jstack pid | grep -A 10 0x32d`查看线程堆栈

3. dump出内存文件用Eclipse Memory Analyzer结合分析

## 统一回复

通过jstack导出堆栈日志和jmap导出堆转储文件结合分析，排查问题是否为：
- 出现内存泄漏
- young、old区域分配不均
- 配置不够

# **11. GC参数调优**

调优的目的是为了用更小的硬件获取更高的吞吐量

## 统一回复



# 参考
- [JVM-10问](https://mp.weixin.qq.com/s?__biz=MzkzNTEwOTAxMA==&mid=2247485143&idx=1&sn=fd442fde5fbea90ae2314b1f7f88b1d8&chksm=c2b24e2af5c5c73c91c54d4932598e8d375803c361e2e5b52c32daa9ca200e9ac348ba4f04cb&token=982147105&lang=zh_CN&scene=21#wechat_redirect)
- [方法区/元空间](https://www.jianshu.com/p/3811a57a597e)
- [R大-JDK6的inflation机制](https://www.iteye.com/blog/rednaxelafx-548536)
- [类加载的代码解析](https://blog.csdn.net/yangcheng33/article/details/52631940)
- [ParNew和CMS的工作原理](https://www.jianshu.com/p/a66fa15cc64a)

- [G1调优实践日记--G1HeapWastePercent和InitiatingHeapOccupancyPercent的应用](https://blog.csdn.net/lovejj1994/article/details/109620239)

# 重点参考
- [请问Java反射的性能为什么比直接调用慢一个数量级左右？](https://www.zhihu.com/question/30097357)
- [类加载器的双亲委派机制全过程](https://blog.csdn.net/m0_45406092/article/details/108976907)

- [R大-HotSpot VM的开发历史和实现细节](https://hllvm-group.iteye.com/group/topic/37095#post-242695)
- [R大-G1](https://hllvm-group.iteye.com/group/topic/44381)
- [R大-并发垃圾收集器（CMS）为什么没有采用标记-整理算法来实现？](https://hllvm-group.iteye.com/group/topic/38223#post-248757)
- [R大-Major GC和Full GC的区别是什么？触发条件呢？](https://www.zhihu.com/question/41922036/answer/93079526)
- [R大-copying具体实现](https://hllvm-group.iteye.com/group/topic/39376#post-257329)
- [R大-CMS、FullGC以及压缩碎片](https://hllvm-group.iteye.com/group/topic/28854)

# 难点
- [R大和LeafInWind-CMS的增量更新与具体代码例子](https://hllvm-group.iteye.com/group/topic/44529)
- [三色标记和漏标多标总结](https://www.jianshu.com/p/12544c0ad5c1)
- [R大-G1](https://hllvm-group.iteye.com/group/topic/44381)
