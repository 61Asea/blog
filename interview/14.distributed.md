# interview fourteen：分布式系统

# **如何理解CAP**

CAP关注的是**数据的读写**

- C：**数据**在不同节点之间如何保证一致性，**默认忽略掉延迟**

    考虑延迟的话，无论如何数据同步都会有延迟，而延迟过程必将带来数据的不一致

- A：每一个数据读写请求，节点总是能在合理的时间内返回合理的响应，如zk的数据同步期间不可用

    **不考虑zk的master选举**，CAP关注的是数据读写，选举可以认为不在其考虑范围之内

- P：分区容错性，指出现网络分区情况下分布式系统的容错性，一个分布式系统必定具备P

    因为网络情况不可能100%不出现问题

# RedLock

一种解决redis集群下可能出现锁丢失的方案，通过`redis cluster`对多个平行的master节点进行加锁，防止单个redis集群主从同步的延迟问题

做法：服务1向cluster上的全部master节点申请锁，当有过半成功的节点响应ACK时，则加锁成功；反之则加锁失败，并释放全部的锁

> redisson的实现上会累加向每个节点申请锁过程的开销，在成功向集群获取到锁之后，锁的持有时间 = 设置的持续时间 - 总申请开销

问题：

1. 算法强依赖系统时钟，redis自动过期的机制下，当出现时钟跳跃时，会出现不可预期的情况

2. 当有节点崩溃恢复后，仍旧可能丢失锁数据，导致其他服务在过半机制下同时获取到锁

3. 进程长时间的GC也有可能导致不同服务间的锁持有周期产生交集

结论：没有必要使用redlock，使用单主从架构的Redis锁即可。分布式锁应注重`效率`和`正确性`，redlock并不能保证绝对的正确性，且引进了写入多主的巨大开销

# 可靠消息最终一致性（本地消息表）

思想：保证提交消息到MQ和本地业务操作这两个操作的**原子性**，`保留可靠消息凭证`和`驱动消息状态更迭`，可以确保在网络时延或producer宕机等异常情况下进行**消息重试**（消息重发）

网络因素：当broker没有对producer的消息发送进行响应（发送过程丢失、响应过程丢失），或发送消息出现**超时异常**

方案：业务线程只需要保留消息凭证即可，消息的发送通过异步线程轮询确保

1. 自实现本地消息表，包括：消息确认服务（解耦）、业务服务集成消息表（耦合）

    - 耦合：包括producer、mq集群、consumer三个部分

    producer：在处理业务消息时，采用本地事务保证操作与消息凭证的原子性，并订阅ack主题接收consumer的操作成功消息

    ```sql
    begin transaction;
    -- 1. 业务操作产生记录
    -- 2. 产生欲发送到MQ的消息，状态为”未发送“
    commit;
    ```

    producer异步线程：
    
    1. 定时轮询捞出“未发送”状态的消息，未满超时时间则进行发送，否则及时报警及时人工介入
    
    2. 当收到broker的ack时，则将消息状态修改为`“已发送”`，否则将进入producer的重试`retries`机制

    3. 定时轮询捞出“已发送”状态的消息，若已满超时时间，则证明可能消费者没有消费到，需要重新投递消息

    broker：可靠性及其对应的性能，由`fsync频率`、`min.insync.replicas`和producer的`acks`进行保证

    consumer：由于可能出现producer未发送、consumer响应ack等异常，所以消息重复投递是必然出现的，必须保证**幂等性**

    ```sql
    begin transaction;
    -- 1. 将消息存入到消息去重表
    -- 2. 处理消费业务
    commit;

    -- 回调producer的ack接口，使得消息状态从“已发送” -> "已完成"
    ```

    - 松耦合：将producer的消费ack确认、异步线程、本地消息表剥离开来，形成**消费确认服务**

    1. producer的可靠凭证保存，通过消费确认服务保证，具体方式：发送**Half消息**到消息ack服务

    2. 消费ack服务接收到**Half信息**，通过本地事务将信息（状态为“未发送”）落入db库，并返回producer响应

    3. producer获取到ack服务响应后，在本地事务下执行生产逻辑，成功/失败都将返回响应到ack服务

        如若宕机丢失，则ack服务接收不到响应，“未发送”的信息会在异步线程的轮询下被捞起，可以提供**告警**、**重发机制**、**事务回查**

        如若**Half响应**丢失，producer应根据之前的ID（保证幂等性）重新发起

    4. ack服务接收到producer本地事务成功，则再次开启本地事务，修改消息状态为“已发送”，并投递消息

        如若投递消息出现超时异常，可能mq已经收到消息，但消息状态会回滚到“未发送”状态，这种情况也需要告警进行人工介入

    5. broker投递消息成功后，consumer可以进行消费，consumer需要**手动提交**，并在业务完毕后调用消息ack服务**完成订单的状态**，且要保证**幂等姓**

        有可能ack服务的订单完成回调丢失，这时其异步线程会轮询捞出超时的“已发送”订单进行重新投递，consumer若无幂等性将导致出错

2. 支持分布式事务的MQ中间件（如rocketMq），通过**Half消息**、**回查事务**、**事务幂等**等手段实现

    RocketMQ减少了对消息ack服务搭建的成本，且通过**回查事务**可以更好的保证mq消息状态写入和投递成功操作的原子性

    1. producer发起**Half消息**到mq服务，开启分布式事务

    2. mq服务将**Half消息**状态标记为`Prepared（预备状态）`，此时该消息无法被consumer消费，并向producer响应half信息的写入情况

    3. producer收到half信息成功写入的响应后，执行本地事务处理生产业务，并将事务结果发送给mq

    4. producer的本地事务成功，则mq执行commit逻辑将消息状态标记为`Consumable（可消费）`，失败则执行rollback逻辑删除该消息，若无producer的事务执行情况则执行**事务回查**

        事务回查：如producer宕机，则向其他producer执行事务执行情况，否则向发起分布式事务请求的producer查询事务执行情况

    5. consumer消费成功后**手动提交（回应ack）**，则消息的状态变为`Finished（已完成）`，并默认向mq提交ack表示消息已完成

    6. 消费在默认成功情况下，consumer会向mq提交ack，失败则会重复接收信息

    优势：将相关的消息状态解耦到mq服务中，并保证了投递消息和消息状态更新的原子性

# 参考
- [Redis分布式锁是否是安全的？](https://zhuanlan.zhihu.com/p/356012419)