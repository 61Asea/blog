# Interview Seven：Redis

核心：redis作为内存数据库，第一考虑点是`内存利用率`，其次是`读写延时`，存在某些降低延时但能提高利用率的操作

# **1. Redis数据结构**

1. 七种基本数据类型

    - sds：简单**动态**字符串，在大部分使用场景下替代C的字符串类型
    
        1. 新增长度信息，**O(1)时间复杂度获取字符串的长度**
        
        2. 自动扩展底层空间，防止缓冲区溢出
        
        3. 空间预分配、惰性释放（打标记），减少字符串的重分配次数

    - linkedlist：**双向无环**链表，发布订阅、满查询、监视器功能都使用链表实现
    
        Redis3.2之前，在list键元素较多时使用linkedlist作为存储结构，3.2之后则采用quicklist作为存储结构（linkedlist + ziplist）

    - hashtable：字典，每个字典都**带有两个hash表**，供平时使用和resize时使用
    
        1. 使用**链地址法**解决哈希冲突
        
        2. **渐进式扩容**避免一次性扩容降低服务可用性，因为扩容时无法操作且一次性扩容耗时过久

        与JDK.HashMap的区别：
        
        - 扩容因子：redis在无后台任务下是1，有后台任务下是5
        
        - 扰动函数：redis没有扰动，在数组长度小时，低位特征不明显的key hash分布不够均匀

        - 缩容：负载因子小于0.1时缩容

        - 扩容后大小：`已存放键值对个数`的两倍的最小2次幂长度

        - 缩容后大小：`已存放键值对个数`的最小2次幂长度

    - skiplist：跳表，由多个跳表节点（zskiplistNode）组成，通过zskiplist对象保存跳表信息（表头节点、表尾节点、长度、最大节点层数）进行管理

        1. **有序且唯一**，每个节点都有score分值，多个节点可以有相同的score分值，但是对象一定是唯一的（对象相同则覆盖）

        2. 三维，节点拥有高度属性，**相同高度的节点**可以串起来更高维度的**链表**，高度在1~32之间随机

    - intset：整数集合，是set集合键实现之一，底层使用数组存储整数，并保证数组中不会出现重复的元素

    - `ziplist`：压缩列表，是redis用于**节省内存空间，提高内存利用率**而设计的数据结构，list、dict、zset在元素个数不满阈值时，会采用它减少空间占用

        连续的内存块组成，这也意味着它拥有数组的缺点，即在变更时需要重新分配数组空间，或挪动数据

    - quicklist：快速列表，redis3.2之后使用quicklist，协调ziplist与linkedlist各自缺点，具体采用多个ziplist组成双向链表

        - linkedlist：链表的next和prev指针占用空间大，无法提供随机访问性

        - ziplist：数组插入删除代价大

        这种思路减少了指针个数，提高内存利用率，也相当于将ziplist分段，防止量级过大下ziplist删除插入产生极大代价

2. 五种类型键（API）：redis通过7大基础数据结构，进一步封装自身的对象系统，这五大对象数据结构都至少用了1种基础数据结构

    - string：int、embstr、raw三种编码，整数值使用int，小于32字节字符串使用embstr，大于32字节或修改设置后使用raw，后两种编码都使用了sds

    - list：统一使用quicklist

    - dict：ziplist、hashtable，小于512个键值对，或单个键值对大小小于64字节时使用ziplist

    - set：intset、hashtable，前者可以节省内存，当存在字符串类型元素或数量过大时使用hashtable的keyset

    - zset：ziplist、skiplist + hashtable

        - zset的ziplist：用两个entry来存储一个集合元素，第一个entry为分数，第二个entry为对象值。**每个元素在列表中从小到大进行排序，分数越小的元素越靠近表头**

        - zset使用跳表的原因：跳表有序，且查找为O(logN)时间复杂度，支持范围操作如`ZRANK`、`ZRANGE`

        - zset维护hashtable的原因：hashtable的key为成员对象，value为分数值，通过这种方式可以实现O(1)时间复杂度查找成员分数值的功能`ZSCORE`

# **2. Redis快的原因**

 # 参考

 # 重点参考