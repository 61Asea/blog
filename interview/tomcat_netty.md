# interview ten：tomcat + netty

# **1. 同步/异步、阻塞和非阻塞**

> 如何理解同步和阻塞

以`进程`视角分为两个步骤：

1. 发起I/O请求

2. 实际的I/O读写操作

以`操作系统`视角分为两个步骤：

1. kernel数据准备（DMA）

2. 将数据从内核空间拷贝到进程空间中（CPU）

- 同步、异步：指是否由**进程自身占用CPU**，将数据从内核拷贝到进程空间中，是的话为同步，否则为异步

    - 异步：由**内核占用CPU**将数据拷贝到进程中，完成后通知进程，进程在此期间可以处理自己的任务

- 阻塞、非阻塞：指进程在**发起I/O请求**后（kernel数据准备中）是否处于阻塞状态

    - 阻塞I/O模型：同步阻塞I/O

    - 非阻塞I/O模型：同步非阻塞I/O（包括I/O多路复用）、异步I/O

    BIO会阻塞，NIO不会阻塞，`对于NIO而言通过channel进行IO操作请求后，其实就返回了`

# **2. I/O模型**

1. 同步阻塞I/O

    进程在发起I/O请求后**直接阻塞**，等待kernel数据完毕后，再**进程占用cpu拷贝**

    数据由DMA从磁盘/网卡搬运到内核空间中，再由中断信号唤醒进程，进程占用CPU将数据从内核空间拷贝到用户空间

2. 同步非阻塞I/O：可直接代指I/O多路复用

    进程在发起I/O请求后不会直接阻塞，当kernel数据准备完毕后，需**进程占用cpu拷贝**

    `I/O多路复用`：进程发起I/O请求后可以立即返回，由一个I/O线程（selector）检测多个句柄的就绪状态：

    - select、poll：持续轮询句柄的就绪情况

    - epoll：添加事件到硬件驱动中，实现句柄就绪后的通知

3. 异步I/O

    进程在发起I/O请求后不会进入阻塞状态，且kernel数据准备完毕后，由**内核占用cpu拷贝**到进程空间，完成后通知进程

    - CPU密集型系统：表现不佳，因为内核占用cpu势必导致进程的cpu可分配资源降低，会增加该类型系统计算延时

    - I/O密集型系统：表现佳（如node.js、aio）

# **3. BIO、NIO、AIO**

- BIO：

# **4. Reactor**

# **5. netty的线程模型**

# **6. tomcat的线程模型**

# **7. 什么是粘包、半包，如何解决**

# 参考

- [网络篇夺命连环12问](https://mp.weixin.qq.com/s?__biz=MzkzNTEwOTAxMA==&mid=2247488227&idx=1&sn=36587eab67d87824179dd5edda3533db&chksm=c2b25a1ef5c5d308ae02ba5a2e5922738fd43305faf74c41320272acecc77d6a155eb50ad33a&token=982147105&lang=zh_CN&scene=21#wechat_redirect)