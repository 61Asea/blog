1. TCP/IP四层模型

- 数据链路层：对应osi的物理层和数据链路层，通过物理手段将通信主机连接到网络中，将比特流数据分组为帧数据

- 网络层：对应osi的网络层，主机间通信，通过IP协议处理路由分组交换

- 传输层：对应osi的传输层和会话层，端到端通信，指定传输协议进行进程间的数据传输

- 应用层：对应osi的应用层和表示层，通过应用层协议对数据格式进行解析与发送

2. TCP报文段：TCP首部 + 数据部分组成，首部包括：seq序列号、ack确认号、ctl控制位和窗口字段等

- seq：发送数据在整个tcp连接中的序号，一开始通过随机算法初始化值，防止复用旧连接后导致数据错乱

- ack：接收方的确认号，也表示期望收到对方下一个报文段的字节序号

- ctl：

    - SYN：建立连接使用，出现在第一、二次握手

    - FIN：断开连接使用，出现在第一、三次挥手

    - ACK：有求必应，对发送分数据的确认响应，运用于TCP重传、校验机制

- checksum：校验和，接收方接收数据后计算校验和，不一致说明数据传输有误

3. 三次握手

- 连接建立发起方向接收方发送第一次握手SYN报文，连接方状态变为SYN_SEND，报文包含了seq初始值

- 接收方响应第二次握手SYN+ACK报文段，报文包含接收方的seq初始值与ack值，ack值为seq+1，随后接收方状态变为SYN_RCVD

- 发起方接收到第二次握手后状态进入ESTABLISHED，再返回给被连接方第三次握手ACK报文，ack值为接收方seq值+1

至此，三次握手结束，双方的tcp连接成功建立

> 为什么不是两次/四次？

两次的问题：

- 对双方的seq值进行接收确认验证

- 防止网络时延导致重复历史的TCP连接建立

四次：

- 没有必要，第二次握手可以将SYN和ACK进行合并

> accept()出现在第几次握手？

在第三次握手之后，客户端句柄由第一次握手时建立，I/O多路复用模型下的服务器主要通过server listen fd接收处理OP_ACCEPT事件进行accept()，并为fd注册OP_READ事件

第一次握手：server为client建立句柄，并放入到syn队列（半连接队列）中

第二次握手：client fd仍旧在syn队列中

第三次握手：将client fd从syn队列移动到accept队列（全连接队列）中

程序的accept()相当于从全连接队列中取出client fd，所以发生在第三次握手之后

> SYN攻击是什么，如何缓解？

恶意连接方发送第一次握手报文后不发送第三次握手报文真正建立连接，从而导致服务器的半连接队列溢出，从而无法正常建立其他TCP连接

缓解方法：
- 指定半连接队列的大小与溢出时的拒绝策略

- syn cookies算法，避免半连接队列占满

4. 四次挥手

- 主动断开方发送第一次挥手FIN报文，随后状态变为FIN_WAIT1

- 被动断开方向主动方发送第二次挥手ACK报文，并开始进行数据收尾处理，主动方接收后状态变为FIN_WAIT2，被动方从ESTABLISHED变为CLOSE_WAIT

- 被动方收尾完毕后，向主动方发送第三次挥手FIN报文，随后状态由CLOSE_WAIT变为LAST_ACK

- 主动方发送第四次挥手ACK报文，随后状态变为TIMED_WAIT，并等待2MSL时长后进入CLOSED状态，被动方接收到ACK后直接进入CLOSED状态

至此，双方连接真正断开

> 为什么是四次不是三次？

FIN表示不再发送数据，但仍可接收数据，主动断开方率先发送第一次挥手仅表示自己数据已处理完毕，不能代表被动方的数据也处理完毕，所以多一次被动方处理数据的时间，就是四次挥手

> 为什么主动方要等待2MSL时长后才能从TIME_WAIT状态进入CLOSED

- 辅助被动方正常关闭连接，2MSL时长恰好能保证被动方至少重试一次FIN包，也避免了后续TCP连接被复用后在一段时间内都无法正常与被动方再次建立连接

- 防止TCP连接复用后，上一次连接中的报文段由于时延到达导致当前连接数据错乱

5. TCP如何保证可靠性

- 校验和checksum，接收方接收到数据后计算checksum并与报文首部的checksum进行对比，不一致说明数据传输有误

- ack应答，有求必应，基于字节流传输的数据都进行了编号，ack则表示当前接收方已接收到的数据序号

- 重传机制：包括快重传和超时重传，前者由重发ack报文值触发，后者则在RTO时间内未接收到ack报文触发，当触发后发送方将重新发送数据

- 流量控制：通信双方都维护发送、接收窗口，接收窗口的大小由应用繁忙程度决定，发送窗口则由对方的接收窗口通告值确定

    - 糊涂窗口：当出现窗口关闭现象后，接收方在稍微缓过来后，又将自己的小窗口通告给对方，对方则会通过小窗口发送小数据，相比TCP + IP首部40字节而言得不偿失

    - 窗口关闭：当接收方处理不过来时，将接收窗口值设置为0通告给对方

- 拥塞控制：TCP是无私的传输层协议，通过拥塞控制来控制发送者的发送窗口增长速率，从而避免出现网络时延时，发送方的数据充斥了整个网络

    控制分为慢启动、拥塞避免和拥塞发生三个阶段，前两个阶段会逐渐降低窗口的增长速率，窗口处于增长状态

    tcp将重传视为及其重要的事件，当出现重传后，会直接降低发送窗口的大小，并重新调整增长速率算法