1. 设计模式

- 工厂模式：spring容器本身就是工厂，用于创建bean

- 单例模式：默认情况下，bean是单例的

- 代理模式：AOP增强对象

2. IOC和AOP

IOC：控制反转，指对象的创建、配置、生命周期控制权统一由Spring容器管理，不需要再人工管理对象之间的关系，解耦

AOP：面向切面编程，提高代码的模块性，基于动态代理为对象提高增强，如果代理对象实现了接口则采用JDK动态代理，否则采用CGLIB动态代理

IOC和AOP相辅相成，在bean的实例化、注入属性、初始化过程中，通过BeanPostProcessor返回增强对象，而使用方正常使用即可

3. JDK代理和CGLIB代理的区别

被代理对象若实现了接口，则使用JDK代理，具体通过实现一个新的接口子类，并通过重写方法的方式对方法进行增强

被代理对象若没有实现接口，则使用CGLIB代理，具体通过Java字节码生成被代理对象的子类，并重写父类方法实现对方法的增强

this引用失效问题：指的是this引用指向的是被代理对象而不是代理对象，如果在有注解增强对象的方法通过this调用对象的其他方法，可能不会获得代理增强

解决方法：

    1. expose-proxy设置为true，并通过AOPUtils线程变量来获取暴露出来的代理对象（不通用）

    2. 实现BeanFactoryAware接口获取beanFactory，通过beanFactory来获取增强对象

    3. CGLIB的调用存在invoke、invokeSuper两种方式，@Configuration注解使用invokeSuper()方法传入代理对象后，this引用将指向代理对象，而非被代理对象

4. bean生命周期

- 实例化：创建一个bean对象，有两个扩展点

- 注入属性：为bean对象的属性赋值，有三个扩展点

- 初始化：调用init-method，有两个扩展点

- 销毁：调用destory-method

扩展点通过BeanPostProcessor、Aware等实现

5. 循环依赖

通过三级缓存解决循环依赖，思路是提前暴露半成品的bean

两级缓存：防止其他线程获取到半成品bean

三级缓存：用于存放引用提供的工厂方法，代理增强对象在循环引用时，需要提前暴露引用，否则依赖对象将获取不到增强引用

6. 传播机制

在多个方法的调用中，规定事务传递的方式，共有7种事务传播机制

REQUIRED：默认，当前线程没事务，则创建一个事务，否则加入该事务

REQUIRED_NEW：无论当前线程是否有事务，都会创建新事务

NESTED：如果当前没有事务，则创建事务，否则创建一个当前事务的子事务