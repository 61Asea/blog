# **项目经历思路**

开头（或第一点）介绍该项目经历的基本职能，最后精炼的总结出业务的多个难题/突破点，并在后续的小点中对每一个难题进行解析

# **1. 战斗业务**

一款多人实时战斗系统，兼容上游不同类型的匹配请求，处理玩家操作与驱动战斗状态更迭。4核16G内存机器下支持10000+场战斗，接收到响应数据出站平均耗时10ms内。系统核心要求点：驱动模型、极高性能、状态统计

主要体现：设计能力，吞吐量和响应的思考（但欠缺可用性），socket基本功

缺点：行业性质较强，跨行很难读懂

## **1.1 线程驱动模型**

    1.
    模型方面：采用状态机绑定线程、固定帧率定时调度驱动的方式，玩家操作则投递战斗任务队列执行，无锁环境简化具体业务设计，解耦战斗与状态以清晰各自职责

    2.
    模型方面：清晰战斗与状态的各自职责，玩家操作投递战斗队列，固定线程定时消费队列和驱动战斗状态更迭，创造无锁环境简化业务设计

### 优点

1. 全部战斗放入到线程池驱动时，会出现线程安全问题，加锁保障对象安全的同时又引入了锁竞争的开销，所以绑定线程可以从根源上解决该问题
2. 使用调度线程池防止线程饥饿问题，避免出现贪婪线程长时间持有cpu资源，导致其他线程对应的战斗响应变慢
3. 提供外部守护线程，会定时遍历所有的战斗线程，当发现有长时间没有驱动的线程则进行任务取消并重新调度的操作，这也意味着战斗线程其实是一个单线程池，提升绑定线程的全部房间可靠性

### 缺点

1. 分布式id的方案问题：借鉴了雪花算法，但是没有时间回拨的容错能力，实现上没有按位操作效率较差，同一秒内出现超过取模/位掩码数量的id获取请求数可能会出现重复ID
2. 假设线程挂掉前正在计算某个战斗状态，守护线程无法保证其战斗的正确性
3. 驱动线程只负责快操作，耗时操作则异步处理，防止驱动线程的其他战斗阻塞，才能极大提升系统吞吐量

## **1.2 极高性能**

    1.
    性能方面：
    - 异步处理耗时操作，防止阻塞驱动线程的其他战斗，充分利用线程资源，提升系统吞吐量
    - 引擎计算采取事件驱动运行来取代实时运行，减少无端的cpu计算
    - 大数据包使用gzip压缩，减少网络拥塞和带宽上限所带来的影响，降低玩家操作延时

    2.
    性能方面：
    - Netty实现自定义二进制协议，大响应报文使用gzip压缩，降低网络传输开销
    - 新数据产生时写入db，之后读写都在内存完成，并定时持久化到db，以减少读写db的次数，增强玩家操作实时性
    - 采用线程变量、池化等手段，降低常用对象频繁创建的开销，优化内存使用情况

性能体现在：cpu、内存、I/O、系统吞吐量、响应延时、最大在线用户数、最大并发用户数

游戏业务体现在：大型实时系统，db太慢只能存冷数据，热数据在缓存中处理后，再落地刷到数据库

## **1.3 状态统计**

    统计方面：提供完善监控，制定运维方Nightingale上传内容与规则，可通过后台监控系统实时查看：应用负载、在线用户量、异常战斗数、卡点状态及其原因，释放开发人力以便及时暴露问题进行业务统计与配置扩容

# **2. 匹配业务**



主要体现：上下游一致性，可用性，业务能力，负载

## **2.1 1**

业务方面：实现匹配网关服务以收拢所有匹配类型请求，解耦上游主服业务逻辑，并提供不同类型的匹配算法能力，准确合理下游调用链