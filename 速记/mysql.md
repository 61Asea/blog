B+树：树形结构，非叶子节点存放索引列和指针，叶子节点存放索引列和真实数据，叶子节点间通过双向指针形成双向链表

优点：

- 有序：数据在逻辑上为索引列有序，更好的支持范围操作
- 局部性原理：想要读取的字其相邻字在接下来被访问的概率极高，所以I/O最少读取一个页的数据，每次I/O能读取更多的数据
- 高扇出性：非叶子节点不存放数据，转而存放更多的指针，可以进一步降低树的高度，树高度越低也意味着越少的I/O次数

hash索引：hashtable来组织数据存放

优点：

- 占用空间小，可以将整个索引读入到内存中
- 精确匹配效率高，达O(1)时间复杂度

缺点：
- 无序，不支持范围操作
- 最左匹配无效，只有符合精确匹配才能使用到索引

覆盖索引：查询字段在索引列范围内，称为覆盖索引

回表：指在辅助索引上获得主键值后，再返回到主索引上查询真实数据，在满足覆盖索引情况下不会回表查询

最左匹配法则：联合索引，匹配时按照联合列从左到右的顺序进行，如果跳过了其中一列，将无法使用联合索引

索引下推：指index filter能力从Mysql Server层下推到引擎层中的索引层面，引擎层具备索引过滤能力后，不用再回表读取完整数据

where条件的处理分为以下三个情况：

- index key：确定查询条件的连续范围，分为Index First Key和Index Last Key

    > 当匹配数量大于0.875后走全表扫描而不是覆盖查询

- index filter：使用索引对index key范围记录进行where条件匹配过滤

- table filter：索引无法过滤，回表进行筛选过滤

效果：使用联合索引查询且符合最左匹配法则，当遇到范围查询的索引列条件后，其下一个索引列条件依旧可以使用联合索引，无需停止匹配采用回表筛选

5.6之前并没有区分index filter和table filter，都放在Server层中。当遇到联合索引中遇到范围操作（索引截断）时，Server触发回表操作，引擎层回表读取完整数据后，返回Server层进行筛除

5.6之后，将Server层中的index filter部分下推到引擎层的索引层面，引擎层具备自行索引过滤能力，不用再统一回表读取完整数据返回Server层，降低了**回表次数**和**与Server层数据交互开销**

```sql
select * from `test` where a = 1 and b >= 1 and c = 1;

-- 5.6：a = 1 and b >= 1可以使用组合索引判断，而c = 1要回表

-- 5.7：索引下推后，c = 1可以直接在组合索引里判断

```

索引失效：失效场景出现在非覆盖查询，不走索引变成全表扫描（覆盖查询情况下，一定会走索引）

> where条件是否运用到了索引，如果没有运用到索引一定走全表

- 左模糊查询：like '%xxx'

- 条件对索引值进行表达式计算，或使用了函数

    ```sql
    select * from `user` where id + 1 = 10;

    -- 应转换为：select * from `user` where id = 10 - 1才可能走索引

    select * from `user` where length(id) = 6;
    ```

- 类型转换

- 匹配行数大于总数的0.875比例会选择走全表，包括：!=、>、<、like

    - 全表扫描顺序I/O，索引读取到主键值后再回表查是随机I/O

- NOT LIKE、NOT IN

- OR作为连接条件，则两个子连接都必须符合索引条件

索引不适用场景：

- 频繁更新的字段

- 特征不明显的字段，重复分布平均效果差

- 表记录太少，干脆就不上索引

锁：

功能：

X锁：写锁，读写、写写互斥

S锁：读锁，读读不互斥，读写互斥

IS、IX：意向锁，表锁和行锁进行冲突检测的机制，避免遍历行来判断当前是否有行锁

粒度：

RECORD：行锁

GAP：间隙锁，在RR隔离级别下使用，解决幻读问题

- sql的索引是非唯一索引

NEXT_KEY LOCK：GAP + RECORD的组合

TABLE：表锁，全表扫描时引擎层会将所有记录锁定并返回

加锁步骤：

- 无索引条件：

    - RC：全表扫描锁住主索引中所有的行，优化后会将不符合条件的行锁释放

    - RR：全表扫描锁住所有的行和间隙

- 唯一索引：

    - RC：锁住辅助索引与主索引中相关的单行

    - RR：锁住辅助索引与主索引中相关的单行

- 非唯一索引：

    - RC：锁住辅助索引与主索引中相关的行

    - RR：

        - 索引截断、联合索引范围查询

        1. 确定index key范围，锁住范围内的所有GAP

        2. 通过index filter确定索引过滤情况，若支持ICP则只锁住符合条件的辅助索引与主索引的行锁

        - 正常索引查询：确定index key范围，相同索引列值可以有多个，锁住范围内的所有GAP和行，以及对应主索引的行

MVCC：undo log实现，行的每一个修改都视作一个版本，根据事务ID与记录最新版本号大小对比结果，并结合隔离级别的特性来返回**快照读**的版本

隔离级别：

- RU：读未提交，有脏读

- RC：读已提交，通过MVCC解决脏读问题，但有不可重复读问题，因为MVCC会返回最新的提交版本

- RR：可重复读，通过固定返回快照读开始的MVCC解决不可重复读，并通过NEXT KEY LOCK解决当前读幻读问题

- Serialization：序列化，完全解决操作依赖快照读的幻读问题，但是效率差

ACID：

- 原子性：要么全部成功，要么全部失败，通过undo log实现，MVCC也同样通过undo log实现，行的每一个修改操作都视作一个版本

- 持久性：db操作一旦**提交**成功，将永久性生效，redo log保证

- 隔离性：事务之间是独立的，由MVCC、锁等方式保证

- 一致性：db总是从一个一致性状态转换到另一个一致性状态，由不同隔离级别+代码层面进行保证

分库分表：垂直分和水平分两个方向，前者常与业务相关，会改动表库结构，后者则是数据平铺，不会改动表库结构

优先考虑垂直分

sharding key：分表字段，用于映射路由sql条件到具体表上

可通过sharding key进行哈希取模、一致性哈希取模、映射表等方式来确定数据的路由位置

问题：

- 分布式唯一ID，雪花算法

- 非sharding key查询

    - 维护sharding key和非sharding key的映射关系

    - 异步后台处理，多线程全表扫，最后将结果聚合

- 笛卡尔积查询，需要预先指定表的绑定关系


日志、主从同步

- undo log：保证事务的原子性，记录事务内**相关操作**，mvcc通过它实现

- redo log：保证事务的持久性，记录数据刷页情况，通过内部XA事务保证与binlog的一致性

- binlog：以事件的形式，记录server执行层上导致数据变动的操作日志，用于主从同步

    - STATEMENT：搭配RR使用，因为binlog在事务提交后才进行记录，而RC没有间隙锁。当出现一个会话delete延迟提交，另一个会话insert提前提交时，会导致从库同步后数据不一致

        > 从库根据commit情况先执行insert再执行delete，而主库是先delete再insert

    - ROW：保存数据的变动操作记录，不会出现不一致情况

主从同步：

1. master：创建dump线程，将binlog的数据推送到slave上

2. slave：启动I/O线程接收binlog，并存放到relay log上

3. slave：启动SQL线程读取relay log，并应用到本机上

异步复制：事务提交后主库就把binlog发送给从库，不关注从库是否应用成功

半同步复制：组提交（传统半同步）/ 组sync阶段（semi-sync）阶段下发送给从库，并等待至少一个从库的ack，才算真正的同步完成