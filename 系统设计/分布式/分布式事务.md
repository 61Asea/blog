# **分布式事务**

指分布在**不同节点**上的多个事务操作，它们共同构成一个完整事务，遵循ACID特性

分布式事务方案：

- XA：一般可以认为就是2pc，3pc是对2pc的改进

- TCC：补偿事务，对代码有侵入性

- 可靠消息最终一致

    - 本地消息表：基于定时任务扫描本地日志

    - MQ事务：基于RocketMQ的事务消息

- 最大努力通知：采用MQ的ack机制就可以实现最大努力通知

![tcc](https://asea-cch.life/upload/2021/12/tcc-d2347f5212ce417ab010ee61ed49428e.jpg)

> 分为`刚性事务`和`柔性事务`，除了XA事务外的其他事务方案都是柔性事务

# **1. XA事务**

> 2pc的传统方案是在数据库层面实现的，为了统一标准减少行业内不必要的对接成本，需要制定标准化的处理模型及接口标准

## **1.1 DTP**

**DTP（Distributed Transaction Processing Reference Model）**：分布式事务处理模型，定义多个角色来协调处理分布式事务

- AP（Application Program）：应用程序，它是DTP分布式事务模型的使用者

- RM（Resource Manager）：资源管理器，即事务参与者，一般处于某个db实例节点上控制着db的事务操作
- TM（Transaction Manager）：事务管理器，即事务协调者，一般处于AP上负责协调各个RM，管理整个分布式事务

**XA**：指在DTP模型定义的RM和TM之间通讯的接口规范，狭义上，**基于db的XA协议实现的2pc称为XA事务方案**

## **1.2 2pc**

模型：DTP模型下，TM为协调者（Coordinator）、RM为参与者（Follower）

运行阶段分为`prepare`和`commit`两个阶段：

- prepare：又称为一阶段提交、提交事务请求、准备阶段

    TM：向所有RM发送prepare请求（事务内容），询问RM是否可以执行成功，并开始阻塞等待各个RM的响应

    RM：收到prepare请求后，执行事务内容**锁定资源**但不提交，并向RM反馈询问的响应

- commit：又称为二阶段提交、执行事务提交、提交阶段

    TM：收到所有RM的ack后，向所有RM发出commit，并阻塞等待各个RM的commit ack，当收到所有commit ack后事务结束

    RM：收到commit请求后，正式执行事务提交操作

> 相关的例子有：保证redo log、binlog一致性的内部XA事务，zookeeper的ZAB协议（过半）

**问题**

1. RM同步阻塞：所有的follower在等待其它follower响应的时候都处于同步阻塞状态，无法进行其它操作

2. TM单点问题：第一阶段或第二阶段开始宕机，所有RM会陷入无限期等待（第二阶段发送commit的过程中宕机 ，会出现RM间数据不一致）

    ZAB方案：崩溃恢复模式选举出具备最大zxid的新TM，并将zxid对应事务同步给全部follower

3. 数据不一致：TM单点、网络故障、网络波动导致commit请求无法到达，都会导致RM间数据不一致

    <!-- ZAB方案：网络故障的情况下使用过半提供服务的降级方式，波动会触发SYNCHRONIZATION阶段 -->

4. 过于保守：必须等待所有的节点ack，这也意味着有任何一个节点出现问题，都会导致整个分布式事务的失败

    ZAB/Paxos：过半提交

**CAP倾向**：CP，所有follower都提交成功后事务才算完成，强一致性

> [zk的一致性模型到底是弱一致性还是强一致性](https://blog.csdn.net/jason_jiahongfei/article/details/108877776)：ZAB协议为过半提交成功，属于弱一致性模型。但zk的API提供sync()方法，读取时会先强制从leader同步数据，属于强一致性

# **2. TCC（补偿事务）**

基于`二阶段提交`的一种补偿式分布式事务，舍弃了部分一致性要求（最终一致性），来换取更高的性能

具体的例子可见：[ttc-transaction](https://github.com/changmingxie/tcc-transaction)

![tcc-transaction的处理方式](https://asea-cch.life/upload/2021/12/tcc-transaction%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F-5f807f75a2fa4b5d96a0353286993ca7.png)

## **2.1 模型**

![XA和TCC的区别](https://asea-cch.life/upload/2021/12/XA%E5%92%8CTCC%E7%9A%84%E5%8C%BA%E5%88%AB-09378999f1754866ae6424b357b26ed3.png)

- 主业务服务（Application）：相当于DTP-AP，为分布式事务的主动发起方，在tcc中它还负责try第一阶段
    
    API：发起方，一般无需提供

- 事务管理器（Transaction Manager）：相当于DTP-TM，为分布式事务的

    API：事务日志上报接口，**用于主业务服务方上报try阶段各个从业务活动资源是否预留成功的信息**

- 从业务服务（Participant）：相当于DTP-RM

    API：try、confirm、cancel三个接口

    - try：主业务服务调用，效果是冻结/预留资源
    
    > tcc-transaction-sample：实现上会直接提交try对应的事务，该事务对应数据会有状态记录，为"DRAFT"待定草稿状态

    - confirm/cancel：由TM方同步/异步调用，将数据状态从"DRAFT"变更为"CONFIRM"或"CANCEL"

## **2.2 流程**

运行阶段与XA二阶段类似：

- try：由AP发起，AP会调用各个从业务服务的try接口。接口会开启本地事务对资源进行**冻结**（打标记/记数量），并提交该本地事务

- confirm/cancel：AP可以感知到一阶段try是否整体成功，并将成功与否结果对TM进行**上报**（TM集成项目则捕获异常、TM独立部署则上报），并根据结果来调用从业务服务的confirm/cancel接口

    > 本地事务逻辑确认/取消预留资源，可以认为是对各个从业务服务之前try阶段开启的本地事务的补偿，**tcc补偿式事务的称号也由此得来**

![tcc具体流程](https://asea-cch.life/upload/2021/12/tcc%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B-28bd491abd964aa2853aa42868d9a069.png)

优点：

> 对标XA事务，整个两阶段提交过程中，会一直持有资源的锁

1. 由于从业务服务在一阶段是多个独立的本地事务，无需等待其他从的响应，**因此不会对资源一直加锁**

2. 将资源层的二阶段提交上提到了业务层面实现，使用者也能在代码层面感知到二阶段的存在 

缺点：主、从服务都需要进行改造，从业务服务方的改造成本更高，从业务服务方下游一般为第三方，较难驱动

**CAP倾向**：AP，存在`幻读现象`

在DTP模型中，1阶段和2阶段都是由TM调用，并且由资源层的本地事务来保证`ACID`特性，**大事务**锁定所有资源防止其他并发操作访问，提供了强一致性，但性能低下

在TCC模型中，1阶段由AP调用，2阶段由TM调用，基于BASE的柔性事务要素无法防止其他并发操作访问时的幻读现象，降低了一致性要求以提供最终一致性效果，但性能较高

## **2.3 注意事项**

由于tcc降低了对整个分布式事务的强一致性要求，当出现网络波动/业务错误时，需要提供机制进行处理

1. 允许空回滚：tcc从服务在未收到try情况下收到cancel请求，应当允许空回滚执行以提升健壮性

    空回滚：当主业务服务方对从业务服务A进行try阶段时，可能出现网络延迟/波动，导致请求延迟到达或丢失，此时TM会根据情况对A服务进行回滚，但对于A而言之前并没有任何事务请求

2. 防悬挂控制：从业务服务方空回滚后，需要**判断之后到来的一阶段Try请求**防止”悬挂“情况

    > 类似问题：为什么TCP不是二次握手

    悬挂：空回滚情况由延迟/丢失导致，当出现丢失时，下一次try请求是主动方的下一轮try请求；**而当出现延迟时，是主动方上一轮的try请求**，就有可能导致问题

    做法：

    - 直接拒绝：因为无法预判空回滚后的第一次try请求是什么情况

    - 先执行再检查：定时恢复任务会扫描分支事务，并检查其主事务的状态，如果没有主事务，再对try请求进行回滚（tcc-transaction的做法）

3. 幂等控制：try、confirm、cancel多次执行的结果应与执行一次的结果是相等的

    在网络数据包重传，或执行补偿操作，try、confirm、cancel方法都有可能被重复执行，所以应当保证执行一次与多次的结果都是一样的

4. 业务数据可见性与并发

    可见性：tcc因为最终一致性模型，会出现幻读现象，所以需要在业务设计思考清楚**预留资源数据**的展示方式，以避免出现问题

    并发：并发控制的锁粒度尽量降到最低，以最大限度的提高并发程度

# **3. 可靠消息最终一致**

# **4. 最大努力通知**

# 参考
- [分布式事务之解决方案（XA和2PC）](https://zhuanlan.zhihu.com/p/93459200)
- [分布式事务的四种解决方案](https://www.cnblogs.com/mayundalao/p/11798502.html)
- [分布式事务 CAP 理解论证 解决方案](https://blog.csdn.net/weixin_40533111/article/details/85069536)

- [tcc-transation源码剖析](https://blog.csdn.net/weixin_42073629/article/details/106750562)

# 重点参考

- [可靠消息最终一致性事务（RocketMQ消息、本地消息表）](https://www.cnblogs.com/zhengzhaoxiang/p/13976517.html)
- [分布式事务解决方案之可靠消息最终一致性、最大努力通知]（https://blog.csdn.net/u010821757/article/details/103675912）：区分了可靠消息最终一致和最大努力通知，前者可以通过本地消息表或支持事务消息的MQ实现，后者通过MQ的ack机制实现
- [7种分布式事务方案](https://www.cnblogs.com/zhusf/p/15481215.html)：暂时忽略Saga、3pc（7 - 2 = 5），MQ事务消息和本地消息表方案合称为可靠消息最终一致（5 - 2 + 1 = 4），所以分布式事务大体可以分为4类

- [zk一致性模型到底是弱一致性还是强一致性](https://blog.csdn.net/jason_jiahongfei/article/details/108877776)
- [ZooKeeper的顺序一致性](https://zhuanlan.zhihu.com/p/140757322)：zxid保证写入顺序一致性

- [TCC服务设计的注意事项](https://zhuanlan.zhihu.com/p/39575038)
- [柔性事务 ：TCC两阶段补偿型](http://www.tianshouzhi.com/api/tutorials/distributed_transaction/388)
