# **分布式事务**

指分布在**不同节点**上的多个事务操作，它们共同构成一个完整事务，遵循ACID特性

分布式事务方案：

- 刚性事务

    - XA：一般可以认为就是2pc，3pc是对2pc的改进

- 柔性事务

    - 补偿型柔性事务

        - TCC：

        - Saga：把一个分布式事务拆分成多个本地事务，每个本地事务提供**执行**、**补偿**模块，并将多个小事务串成事务链`LLT`**逐个**调用

    - 通知型柔性事务：分为事务消息和最大努力通知

        - 可靠消息最终一致：主要适用于内部系统的数据最终一致性保障，内部相对可控

            - 本地消息表：基于定时任务扫描本地日志

            - MQ事务：基于RocketMQ的事务消息

        - 最大努力通知：由于作用于外部系统，外部的网络环境复杂不可信，所以只能尽最大努力去通知一致性

            采用MQ的ack机制实现最大努力通知

![tcc](https://asea-cch.life/upload/2021/12/tcc-d2347f5212ce417ab010ee61ed49428e.jpg)

> 分为`刚性事务`和`柔性事务`，除了XA事务外的其他事务方案都是柔性事务

# **1. XA事务**

> 2pc的传统方案是在数据库层面实现的，为了统一标准减少行业内不必要的对接成本，需要制定标准化的处理模型及接口标准

## **1.1 DTP**

**DTP（Distributed Transaction Processing Reference Model）**：分布式事务处理模型，定义多个角色来协调处理分布式事务

- AP（Application Program）：应用程序，它是DTP分布式事务模型的使用者

- RM（Resource Manager）：资源管理器，即事务参与者，一般处于某个db实例节点上控制着db的事务操作
- TM（Transaction Manager）：事务管理器，即事务协调者，一般处于AP上负责协调各个RM，管理整个分布式事务

**XA**：指在DTP模型定义的RM和TM之间通讯的接口规范，狭义上，**基于db的XA协议实现的2pc称为XA事务方案**

## **1.2 2pc**

模型：DTP模型下，TM为协调者（Coordinator）、RM为参与者（Follower）

运行阶段分为`prepare`和`commit`两个阶段：

- prepare：又称为一阶段提交、提交事务请求、准备阶段

    TM：向所有RM发送prepare请求（事务内容），询问RM是否可以执行成功，并开始阻塞等待各个RM的响应

    RM：收到prepare请求后，执行事务内容**锁定资源**但不提交，并向RM反馈询问的响应

- commit：又称为二阶段提交、执行事务提交、提交阶段

    TM：收到所有RM的ack后，向所有RM发出commit，并阻塞等待各个RM的commit ack，当收到所有commit ack后事务结束

    RM：收到commit请求后，正式执行事务提交操作

> 相关的例子有：保证redo log、binlog一致性的内部XA事务，zookeeper的ZAB协议（过半）

**问题**

1. RM同步阻塞：所有的follower在等待其它follower响应的时候都处于同步阻塞状态，无法进行其它操作

2. TM单点问题：第一阶段或第二阶段开始宕机，所有RM会陷入无限期等待（第二阶段发送commit的过程中宕机 ，会出现RM间数据不一致）

    ZAB方案：崩溃恢复模式选举出具备最大zxid的新TM，并将zxid对应事务同步给全部follower

3. 数据不一致：TM单点、网络故障、网络波动导致commit请求无法到达，都会导致RM间数据不一致

    <!-- ZAB方案：网络故障的情况下使用过半提供服务的降级方式，波动会触发SYNCHRONIZATION阶段 -->

4. 过于保守：必须等待所有的节点ack，这也意味着有任何一个节点出现问题，都会导致整个分布式事务的失败

    ZAB/Paxos：过半提交

**CAP倾向**：CP，所有follower都提交成功后事务才算完成，强一致性

> [zk的一致性模型到底是弱一致性还是强一致性](https://blog.csdn.net/jason_jiahongfei/article/details/108877776)：ZAB协议为过半提交成功，属于弱一致性模型。但zk的API提供sync()方法，读取时会先强制从leader同步数据，属于强一致性

# **2. TCC（补偿事务）**

基于`二阶段提交`的一种补偿式分布式事务，舍弃了部分一致性要求（最终一致性），来换取更高的性能

具体的例子可见：[ttc-transaction](https://github.com/changmingxie/tcc-transaction)

![tcc-transaction的处理方式](https://asea-cch.life/upload/2021/12/tcc-transaction%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F-5f807f75a2fa4b5d96a0353286993ca7.png)

## **2.1 模型**

![XA和TCC的区别](https://asea-cch.life/upload/2021/12/XA%E5%92%8CTCC%E7%9A%84%E5%8C%BA%E5%88%AB-09378999f1754866ae6424b357b26ed3.png)

- 主业务服务（Application）：相当于DTP-AP，为分布式事务的主动发起方，在tcc中它还负责try第一阶段
    
    API：发起方，一般无需提供

- 事务管理器（Transaction Manager）：相当于DTP-TM，为分布式事务的

    API：事务日志上报接口，**用于主业务服务方上报try阶段各个从业务活动资源是否预留成功的信息**

- 从业务服务（Participant）：相当于DTP-RM

    API：try、confirm、cancel三个接口

    - try：主业务服务调用，效果是冻结/预留资源
    
    > tcc-transaction-sample：实现上会直接提交try对应的事务，该事务对应数据会有状态记录，为"DRAFT"待定草稿状态

    - confirm/cancel：由TM方同步/异步调用，将数据状态从"DRAFT"变更为"CONFIRM"或"CANCEL"

## **2.2 流程**

运行阶段与XA二阶段类似：

- try：由AP发起，AP会调用各个从业务服务的try接口。接口会开启本地事务对资源进行**冻结**（打标记/记数量），并提交该本地事务

- confirm/cancel：AP可以感知到一阶段try是否整体成功，并将成功与否结果对TM进行**上报**（TM集成项目则捕获异常、TM独立部署则上报），并根据结果来调用从业务服务的confirm/cancel接口

    > 本地事务逻辑确认/取消预留资源，可以认为是对各个从业务服务之前try阶段开启的本地事务的补偿，**tcc补偿式事务的称号也由此得来**

![tcc具体流程](https://asea-cch.life/upload/2021/12/tcc%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B-28bd491abd964aa2853aa42868d9a069.png)

优点：

> 对标XA事务，整个两阶段提交过程中，会一直持有资源的锁

1. 由于从业务服务在一阶段是多个独立的本地事务，无需等待其他从的响应，**因此不会对资源一直加锁**

2. 将资源层的二阶段提交上提到了业务层面实现，使用者也能在代码层面感知到二阶段的存在 

缺点：主、从服务都需要进行改造，从业务服务方的改造成本更高，从业务服务方下游一般为第三方，较难驱动

**CAP倾向**：AP，存在`幻读现象`

在DTP模型中，1阶段和2阶段都是由TM调用，并且由资源层的本地事务来保证`ACID`特性，**大事务**锁定所有资源防止其他并发操作访问，提供了强一致性，但性能低下

在TCC模型中，1阶段由AP调用，2阶段由TM调用，基于BASE的柔性事务要素无法防止其他并发操作访问时的幻读现象，降低了一致性要求以提供最终一致性效果，但性能较高

## **2.3 注意事项**

由于tcc降低了对整个分布式事务的强一致性要求，当出现网络波动/业务错误时，需要提供机制进行处理

1. 允许空回滚：tcc从服务在未收到try情况下收到cancel请求，应当允许空回滚执行以提升健壮性

    空回滚：当主业务服务方对从业务服务A进行try阶段时，可能出现网络延迟/波动，导致请求延迟到达或丢失，此时TM会根据情况对A服务进行回滚，但对于A而言之前并没有任何事务请求

2. 防悬挂控制：从业务服务方空回滚后，需要**判断之后到来的一阶段Try请求**防止”悬挂“情况

    > 类似问题：为什么TCP不是二次握手

    悬挂：空回滚情况由延迟/丢失导致，当出现丢失时，下一次try请求是主动方的下一轮try请求；**而当出现延迟时，是主动方上一轮的try请求**，就有可能导致问题

    做法：

    - 直接拒绝：因为无法预判空回滚后的第一次try请求是什么情况

    - 先执行再检查：定时恢复任务会扫描分支事务，并检查其主事务的状态，如果没有主事务，再对try请求进行回滚（tcc-transaction的做法）

3. 幂等控制：try、confirm、cancel多次执行的结果应与执行一次的结果是相等的

    在网络数据包重传，或执行补偿操作，try、confirm、cancel方法都有可能被重复执行，所以应当保证执行一次与多次的结果都是一样的

4. 业务数据可见性与并发

    可见性：tcc因为最终一致性模型，会出现幻读现象，所以需要在业务设计思考清楚**预留资源数据**的展示方式，以避免出现问题

    并发：并发控制的锁粒度尽量降到最低，以最大限度的提高并发程度

# **3. 可靠消息最终一致**

严格意义上可靠消息最终一致性并不属于分布式事务的范畴，而是避免分布式事务的一种方式

在大部分的服务系统中，大部分接口调用都是同步的；然而，也存在服务间的**调用是异步的，即将消息发送给中间件**

## **3.1 模型**

可靠消息模型下有三个角色：

- 事务发起方：往往有本地事务需要处理，并且在完成后需要向某个参与方通知

- 消息中间件：异步模型的立足点，它与发起方、参与方相互通信

- 事务参与方：下游方，是发起方消息的消费者

**流程**：发起方执行本地事务/发送通知到MQ -> MQ获取消息 -> 参与方订阅MQ消费消息

这个过程中需要保证以下两点：

1. 发起方执行本地事务，发送通知到MQ是并发操作，需要将它们合并成一个原子操作

    - 情况1：如果本地事务执行失败进行回滚时，无法回滚已经发送到MQ的通知，导致不一致
        ```sql
        begin transaction;
        -- 发送通知到MQ
        -- 执行本地事务
        commit transaction;
        ```

    - 情况2：MQ的超时异常没有准确语义，可能MQ已经成功接收了通知

        ```sql
        begin transaction;
        -- 执行本地事务
        -- 发送通知到MQ
        commit transaction；
        ```

2. 消费方需要保证幂等，因为网络复杂会存在**MQ重复投递**，这将会导致消费者重复消费

## **3.2 方案**

### **3.2.1 本地消息表**

思路：通过本地事务，当本地业务完成后保留**可靠凭证**，这个凭证我们认为是可靠消息

解决问题：在上述的情况2中，由于存在发送通知超时表意不明，且只能通过一次操作来决定结果。所以将发送MQ的过程从本地事务剥离出来，只要凭证留下来，接下来的机制总是能保证通知成功发送到MQ

交互流程：

> 本地业务的库表，与消息日志的库表，在同一个本地库中

- 事务发起方开启本地事务，事务内容为：进行本地业务、业务成功则记录通知到对应的`消息日志`

    具备：通知消息的消息日志表

- 发起方的定时任务扫描消息日志，开启本地事务，内容为：日志发送到MQ，反馈成功则删除该日志，反馈失败则抛异常不删除日志

    > 重复投递：反馈失败，消息日志仍存在库中，定时任务会在下一周期继续重试，导致重复投递

- 事务参与方订阅MQ，使用MQ的ack机制保证**一定消费了信息**，因为存在重复投递过程所以需要保证幂等性

    > ack：接收到MQ推送的消息时，先开启事务完成本身业务，再向MQ反馈ack进行消息确认

    具备：通知消息的应用日志表（保证幂等）

    ```sql
    -- 接收到MQ消息后进入事务

    begin transaction;
    -- 执行本地业务
    -- 插入关于MQ通知的应用日志，方便后续判断去重
    -- 反馈ack
    commit transaction;
    ```

疑惑：如果参与方的业务出现问题怎么办？按照以上流程，发起方是否应该提供补偿能力对事务操作进行回滚？发起方的通知消息是否应具备更多的状态，如：待参与方返回操作成功后再删除，而不是在发送到MQ成功后就删除？参与方返回操作成功的方式，是通过rpc直接通知发起方，还是**提供接口让发起方查询**，还是mq能提供某种机制？

# **4. 最大努力通知**

# 参考
- [分布式事务之解决方案（XA和2PC）](https://zhuanlan.zhihu.com/p/93459200)
- [分布式事务的四种解决方案](https://www.cnblogs.com/mayundalao/p/11798502.html)
- [分布式事务 CAP 理解论证 解决方案](https://blog.csdn.net/weixin_40533111/article/details/85069536)

- [tcc-transation源码剖析](https://blog.csdn.net/weixin_42073629/article/details/106750562)

- [可靠消息最终一致性事务（RocketMQ消息、本地消息表）](https://www.cnblogs.com/zhengzhaoxiang/p/13976517.html)

- [分布式事务解决方案之可靠消息最终一致性、最大努力通知](https://blog.csdn.net/u010821757/article/details/103675912)：区分了可靠消息最终一致和最大努力通知，前者可以通过本地消息表或支持事务消息的MQ实现，后者通过MQ的ack机制实现
- [7种分布式事务方案](https://www.cnblogs.com/zhusf/p/15481215.html)：暂时忽略Saga、3pc（7 - 2 = 5），MQ事务消息和本地消息表方案合称为可靠消息最终一致（5 - 2 + 1 = 4），所以分布式事务大体可以分为4类

# 重点参考

- [zk一致性模型到底是弱一致性还是强一致性](https://blog.csdn.net/jason_jiahongfei/article/details/108877776)
- [ZooKeeper的顺序一致性](https://zhuanlan.zhihu.com/p/140757322)：zxid保证写入顺序一致性

- [TCC服务设计的注意事项](https://zhuanlan.zhihu.com/p/39575038)
- [柔性事务 ：TCC两阶段补偿型](http://www.tianshouzhi.com/api/tutorials/distributed_transaction/388)
- [TCC和Saga各自优势](https://www.136.la/jingpin/show-67237.html)

- [可靠消息最终一致性](https://www.cnblogs.com/zhengzhaoxiang/p/13976517.html)：本地消息表、MQ事务消息
- [通知型事务和补偿型事务的区别](https://blog.csdn.net/weixin_34649022/article/details/112720765)
- [如何用消息系统避免分布式事务？ ](https://www.cnblogs.com/LBSer/p/4715395.html)：可靠消息最终一致、消费端的重复消费、生产端的重复投递（消费端的幂等机制：先处理业务，再插入幂等消息表，最后将消息状态改为成功）