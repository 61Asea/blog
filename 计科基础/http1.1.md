# http/1.1

![应用层传输层IP层交互](https://asea-cch.life/upload/2021/11/%E5%BA%94%E7%94%A8%E5%B1%82%E4%BC%A0%E8%BE%93%E5%B1%82IP%E5%B1%82%E4%BA%A4%E4%BA%92-f4530b30faa0460982aac2bcc08685fa.png)

> HTTP是什么？

HTTP是`超文本转移协议`（HyperText Transfer Protocol），可以拆分为三个部分：

- 超文本：通过很多标签定义文字、图片、音频等超文本数据

- 转移：基于TCP/IP，将两点之间传输的数据转移为一些带有操作语义的操作原语

    两点可以是「服务器< -- >服务器」，一次HTTP请求分为发起请求的一方，和收到并应答的另一方

- 协议：应用层概念，使用`「请求 -- > 应答」的通信模式`

# **1. 基础构造**

![http_message](https://asea-cch.life/upload/2021/11/http_message-fd9a711ede304836afe645ca7900a898.png)

**一个http message的构成：**

1. 报文首部（http header）：携带message对应的信息，包括Cache-Info、Host、请求方法等一系列用于处理message的信息

2. 空行：CR + LF，用于分割开报文首部和报文主体

3. 报文主体（http body）：实际的数据

## **1.1 常见的五大状态码**

### **1xx**：**提示信息**，是协议处理中的一种中间状态，实际较少使用

### **2xx**：服务器**成功接收**请求方的请求报文，并被**正确处理**

- `200 OK`：最常见的成功状态码，如果是非HEAD请求，则服务器返回的响应头**都会有body数据**

- 204 No Content：与200 OK基本一直，但响应没有body数据

- 206 Partial Content：应用于HTTP`分块下载`或`断点续传`，表示响应头返回的**body数据不是资源的全部，而是其中的一部分**

### **3xx**：**重定向**，客户端请求的资源位置发送了变动，需要客户端用新的URL重新发送请求

- 301 Moved Permanently：**永久重定向**，请求的资源已不在，需改用新的URL再次访问

- 302 Found：**临时重定向**，请求的资源还在，但是暂时需要用另一个URL来访问

    只有在Cache-Control或Expires中进行指定的情况下，该响应才是可缓存的，因为资源是临时定向的

    > 301和302都会在响应头里使用字段`Location`，指明后续要跳转的URL，浏览器会自动重定向到新的URL上

- 304 Not Modified：缓存重定向，**用于`缓存控制`**，表示资源未修改，重定向已存在的缓冲文件

    不具有实际的跳转含义，没有`Location`字段

### **4xx**：**客户端发送报文有误**，服务器无法处理，属于客户端的错误码范畴

- `400 Bad Request`：客户端请求报文有误，一般指请求参数有误

- 403 Forbidden：服务器禁止访问资源，并不是客户端的请求出错

- 404 Not Found：请求的资源在服务器上不存在或未找到，所以无法提供给客户端

### **5xx**：客户端请求报文正确，但**服务器处理时内部出现错误**，属于服务器端的错误码范畴

- `500 Internal Server Error`：通用服务器内部错误码

- 501 Not Implemented：客户端请求的功能暂不支持

- `502 Bad GateWay`：通常是服务器作为网关代理时返回的错误码，表示服务器本身工作正常，**但是转发给后端的服务器发生了错误**

- 503 Server Unavailable：服务器繁忙

## **1.2 常见字段**

![请求报文和响应报文](https://asea-cch.life/upload/2021/11/%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E5%92%8C%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87-c3d62d01b24c4429920ac88f4cfa6297.jpg)

请求行/状态行：

- 前者由`请求方法`、`URI`、版本组成

- 后者由`状态码`、状态码描述、版本组成

请求/响应首部字段：

- 前者描述`发送请求`的场景，包括客户端自身信息，和期望服务器的处理、响应行为

- 后者描述`应答`的场景，包括应答方自身信息，对请求方处理的结果等

通用首部字段：请求报文、响应报文都具备的一些字段

实体首部字段：针对http body数据内容的信息

### **1.2.1 请求首部字段**

![请求报文头](https://asea-cch.life/upload/2021/11/%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E5%A4%B4-e9ced526c3664275a16473c1bcb8cd6d.png)

![请求报文头2](https://asea-cch.life/upload/2021/11/%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87%E5%A4%B42-d8b5105c9b8b48dd9f259cea007fb911.png)

1. `Host`：发送请求时，用来指定服务器的`域名`

    必选字段，该字段是http1.1规范中唯一要求必须被包含在请求内的首部字段，此字段告诉服务器请求的资源所处的互联网主机名字和端口号

    它与单台服务器**分配多个域名**的虚拟主机工作机制有密切关联，如haproxy和nginx：

    系统内核处理tcp报文时，根据tcp首部读取出该消息属于网关进程的，而网关进程进一步解析出http首部后，可以**根据Host字段来分配该请求到相对于的服务进程**

2. `Cookie`：存储了请求方的状态信息

    由于http协议是无状态的，应答方并不会保存请求方的请求之间的上下文，所以为了维护状态，应答方会提供给请求方一个cookie值

3. Range：请求服务器资源的指定范围，服务器成功处理则对应206返回码，不支持范围请求则对应200返回码

4. Max-Forwards：转发计数器，**每路过一个代理服务器则减一**，当值减为0时就不再进行转发，直接进行返回响应

    > 可类比IP数据包中的首部字段TTL，TTL指最大经过路由数量，当TTL为0时也是被丢弃，并发送ICMP报文通知源主机

5. `Form`：表单数据

6. Except：期望应答方出现的特定行为

    如果应答方无法理解期望行为，则返回417状态码，表示客户端出错

7. User-Agent：请求方的浏览器内核名称等信息

8. Accept系列

    - Accept：通知服务器能处理的媒体类型与优先级

    - Accept-Charset：通知服务器用户代理可以支持的**字符集**与优先级

    - `Accept-Encoding`：客户端支持的**压缩方法**以及优先级

9. Authorization：此字段填写的是用户代理的认证信息。想通过服务器认证的用户代理会在接收到返回401的状态码响应后，会把此字段放入请求中

### **1.2.2 响应首部字段**

![响应报文](https://asea-cch.life/upload/2021/11/%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87-b61d8dd08056463b90b54aef7880848f.png)

1. `Location`：重定向字段，引导发送方至与请求URI位置不同的资源

2. Accept-Ranges：配合范围请求，返回服务器能处理的范围

### **1.2.3 通用首部字段**

指请求报文、响应报文都会使用到的首部字段

1. `Cache-Info`：操纵**代理服务器**缓存的工作机制，多个指令使用","分割开来

    与代理服务器缓冲机制相关，代理服务器基本行为是接收客户端请求并转发给其他服务器，代理在**转发响应结果**时，会将资源结果的副本保存在自身上，以减少下次相同资源请求时的网络请求

    - max-age/expires：
    
        - 客户端设置：未超过这个时间的缓存资源可以直接返回
        
        - 服务端设置：表示缓存资源的最大生存时间

    - public：其他用户也可以使用该缓存

    - no-cache：不要缓存**过期的**资源

        - 客户端设置：不要代理的缓存资源

        - 服务端设置：代理不可以缓存

    - no-store：请求或响应中有机密信息，不能缓存**任意部分**

2. `Connection`：长连接、不转发代理、管理持久化连接等作用，值有**keep-alive** / close

    http1.1默认的连接都是持久化连接，如果服务器明确想断开连接时，则指定Connection的值为close

    http1.0默认是费持久连接，如果兼容旧版本维持长连接，则需要指定Connection的值为keep-alive

3. `Upgrade`：常用于升级到websocket协议

    - 客户端：检测服务器是否支持其他协议，或更高版本的协议来通信，可以指定websocket

    - 服务器：支持websocket协议时返回101响应，并通过Upgrade字段通知客户端采用websocket协议来完成请求
    
### **1.2.4 实体首部字段**

作为实体数据信息的补充手段

1. Content系列：

    - Content-Encoding：实体数据的压缩方式

    - Content-Language：实体主体使用的自然语言

    - `Content-Length`：实体数据部分的大小值，与基于netty实现的应用层协议解决粘包/半包的长度域消息头类似

    - Content-Type：实体主体的媒体类型，与请求首部Accpet字段填充的格式完全相同上

    - Content-Location：实际返回的URI，可能与请求不同

2. Last-Modified：资源最终被修改的时间

3. Expires：

    - 服务端响应：资源失效的日期，缓存服务器在转发带有该字段的**响应时**，会将资源缓存并设置与其一致的过期时间

    - 客户端请求：缓存服务器对携带Expires解析后，若未超时则直接返回给客户端缓存资源，否则转向源服务器请求资源

## **1.3 请求方法**

请求方法填充于请求行中，包括：POST、GET、DELETE、PUT、HEAD

> post和get的区别

本质上没有区别，只是报文格式不同，两者都基于TCP/IP的传输层协议，只是HTTP协议的不同请求方式

解答思路：以两种请求方式的行为特征，并结合`安全`和`幂等`两个角度进行阐述

GET：只读操作，用于获取信息

POST：修改服务器上的数据

- 安全：广义指服务器的资源安全，`请求方法不会破坏服务器资源则属于安全`，数据安全性只做扩展认识

    - 服务器安全性（以此作为标准即可）：
    
        - POST：不安全，因为会修改资源状态或添加资源

        - GET：安全，因为是`只读操作`，不会破坏服务器上的资源

    - 数据安全性（扩展）：http下都是明文传输，没有安全性可言，想要安全传输只有加密（HTTPS）

        - 缓存：

            - GET：可缓存，相对不安全

            - POST：不可被缓存，相对安全

        - 现实生活：
        
            - GET：数据都拼接于地址栏上，可能会被窥见

            - POST：数据通过表单提交上传，除非抓包查看

- `幂等`：多次执行相同的操作，结果都是相同的

    - POST：非幂等，多次提交数据会破坏资源，一般需要提供幂等机制

    - GET：幂等，`只读操作`执行多次相同操作，结果仍然相同

结论：

1. `GET安全且幂等，POST非安全且非幂等`

2. 数据查询使用GET，增删改使用POST

3. GET速度快，因为可缓存

4. 网传的GET用一个TCP报文，POST用两个TCP报文传输不是RFC规范，而是不同浏览器对于RFC规范下的http实现

> 举一个通俗栗子吧，在微博这个场景里，GET的语义会被用在「看看我的Timeline上最新的20条微博」这样的场景，而POST的语义会被用在「发微博、评论、点赞」这样的场景中

# **2. 特性**

`无状态`：不会记忆客户端状态，不需要额外的资源来记录状态信息，在执行有关联性的多个操作时通过**cookie + session**机制进行辅助

> [http协议无状态中的 "状态" 到底指的是什么？！](https://www.cnblogs.com/bellkosmos/p/5237146.html)

`不安全`：http的致命缺点，同时也是https的优点，后者通过引入SSL/TLS层在安全上达到极致

- 通信使用`明文传输`，数据被窃取后可直接解析窃取
- 没有验证通信方的身份
- 没有报文完整性的验证机制，可能会被篡改

`请求-应答`：HTTP协议基于TCP/IP，使用**请求-应答的通信模式**

`文本协议`：**包含数据结构信息**的transfer协议，消息头一定为文本编码，消息体可以是文本，也可以是二进制

> [二进制协议和文本协议的区别](https://blog.csdn.net/qq_40771473/article/details/106003171)：二进制预先是协商好协议的结构，即第几位到第几位属于某个字段，**数据本身并不会包含结构信息**

HTTP2的头信息和数据体都为二进制，统称

`性能`：

- 长连接：只要**任意一端**没有明确提出断开TCP连接，则保持TCP连接状态

    在1.0之前每发起一次请求，都要新建一次TCP连接，增加通信开销
    
    1.1之后提出`长连接`方式，也叫做`持久连接`，减少了**重复建立和断开TCP连接所带来的开销**

- 管道网络传输：可以同时发起多个请求，类似于TCP的发送窗口，可以减少整体的响应时间

> 浏览器默认关闭http pipeline，不使用的原因是：它只解决了**请求的队头阻塞**，没有解决响应队头阻塞，所以对于并行的tcp连接而言，程序并不知道哪个连接上正在传输的文件更小，如果为了管道化而选择了文件更大的连接，则可能会导致整体效率变慢，因为其它的连接小文件传输更快，完成后进入空闲状态，而其他文件却在耗时更久的连接上阻塞

- 队头阻塞：http pipeline使得客户端可以同时发起多个请求，但服务器仍旧是按**顺序执行**并回应

    假设文件A的数据为1111，B的数据为2222，响应乱序为：22221111，块乱序为：11221122，正常顺序为11112222

    - 顺序执行回应
        
        http1.1中，消息头没有包括对应的请求，在响应乱序甚至是chunk乱序的情况下，无法分辨数据属于哪个资源，或者它在哪里结束，另一个块从哪里开始

    - 请求阻塞：可以同时发起多个请求，解决了客户端的队头阻塞

    - 响应阻塞：因为必须按顺序响应，并没有解决响应的队头阻塞

# 参考
- [Cookie安全性分析](https://blog.csdn.net/qq_37158580/article/details/89462874)
- [HTTP首部到底有哪些东西](https://blog.csdn.net/lucky52529/article/details/97805576)
- [杨光知乎用户回答：POST和GET的区别](https://www.zhihu.com/question/28586791/answer/145424285)

# 重点参考
- [HTTP 协议入门5.1](http://www.ruanyifeng.com/blog/2016/08/http.html)
- [二进制协议和文本协议的区别](https://blog.csdn.net/qq_40771473/article/details/106003171)
- [http协议无状态中的 "状态" 到底指的是什么？！](https://www.cnblogs.com/bellkosmos/p/5237146.html)