# https

# **http和https的区别**

1. http是超文本转移协议，信息是**明文传输**，存在安全风险问题；https在**tcp和http之间**加入了`SSL/TLS`安全协议，使得报文能够**加密传输**，解决了http不安全的缺陷

2. https在三次握手之后，还需要仅需SSL/TLS的握手过程，才可进入加密报文传输

3. http的端口号是**80**，https的端口号是**443**

4. https协议需要向CA（证书权威机构）申请数字证书，保证服务器身份

# **https解决了http的哪些问题，如何解决的？**

解决了窃取、篡改和冒充节点的问题，通过`混合加密`、`数字签名`和`数字证书`方式进行解决，其中内容采用接收方公钥加密，签名采用发送方私钥加密，可以保证数据既不能被篡改，也不能被窃取

以下的场景都假定 B（发送方） --> A（接收方），C为恶意方

- 窃取：`混合加密`防止明文传输信息被窃取

    混合加密结合了**对称加密**和**非对称加密**各自的优点：

    - 对称加密：只使用一个秘钥，**运算速度快**，但秘钥必须保密，**且无法做到安全的秘钥交换**

    - 非对称加密：使用“公钥”和“私钥”，公钥可以任意分发但私钥保密，解决了**秘钥配送问题**，但**速度效率仅为对称加密的百分之一**

    过程如下：

    1. 在建立通信前，采用**非对称加密**的方式交换**会话秘钥**（解决对称加密算法的秘钥配送问题）

    2. 通信过程中，全部使用**对称加密**的**会话秘钥**方式来加密明文数据（避免非对称加密算法效率低的问题）

- 篡改：`数字签名`对信件内容校验，通信内容若被篡改后将不能正常显示

    过程：

    1. 先用hash函数，生成信件的唯一摘要，这个函数也被称为**摘要算法**

    2. B使用自己的**私钥**对摘要进行签名，生成`数字签名`

    3. 将数字签名附在要发送的信件后面，一同发送给A

    4. A收到B的信件后，通过B的**公钥**解签获得唯一摘要

    5. 通过B的hash函数对接收到的信件数据同样生成信件唯一摘要，若结果与第四步结果一致，则说明B发送过来的数据并未收到篡改

- 冒充节点：`数字证书`对节点的真实性进行证明

    C可以通过冒充节点的方式，诱导A保存的B公钥置换为C的公钥，之后C就可以通过其私钥冒充B来发送数据，这样数字签名和信件内容混合加密都将形同虚设

    过程：

    将`服务器公钥`放入到数字证书中，借助第三方权威机构CA进行验证，只要证书是可信的，公钥就是可信的

# **HTTPS是如何建立连接的？其间交互了什么？**

SSL/TLS协议基本流程：

1. 请求方（客户端）向接收方（服务端）索要并验证服务器的公钥，公钥存于接收方的`数字证书`中，由第三方认证机构CA提供可信保证

2. 双方协商生成`会话秘钥`

3. 通过会话秘钥进行加密通信

前两步是SSL/TLS的建立过程，即握手阶段，涉及**四次通信**：

- ClientHelo：客户端向服务器发起加密通信请求

    请求内容：
    
    1. 客户端支持的SSL/TLS协议的版本

    2. 客户端生成的随机数Client Random，后面用于生成**会话秘钥**

    3. 客户端支持的密码算法套件，如：RSA、DES

- ServerHelo：服务端收到通信请求后，向客户端发起响应，非加密算法在此处开始

    响应内容：

    1. 确认SSL/TLS协议版本，如果客户端不支持则直接拒绝

    2. 服务端生成随机数Server Random，后面用于生成**会话秘钥**

    3. 指定客户端密码套件列表中的某一种，作为生成最终**会话秘钥**的加密算法

    4. 发送服务器的数字证书

    > 该过程可以要求客户端同样提供`数字证书`，这种方式为双向验证

- 客户端回应：由非对称加密开始向对称加密转变，体现`混合加密`

    过程：

    1. 生成一个随机数pre-master key，使用服务器的公钥进行加密后发送给服务器

    2. 使用服务端指定的加密算法，传入Client Random、Server Random和pre-master key生成**会话秘钥**

    3. 客户端加密通信算法改变通知，表示随后的信息都使用**会话秘钥**进行通信

    4. 客户端握手结束通知，表示客户端握手阶段已经结束，通过`摘要算法`将上述过程产生的数据生成`唯一摘要`，采用**会话秘钥**与算法进行加密生成`数字签名`，发送给服务器

    > 如果采用双向验证，则使用客户端的私钥来对唯一摘要进行加密生成`数字签名`

- 服务端回应：

    1. 使用私钥解密客户端的pre-master key，同样使用指定的加密算法，结合Client Random、Server Random和pre-master key计算获得**会话秘钥**

    2. 使用**会话秘钥**解密客户端传过来的加密唯一摘要，并同样将上述过程产生的数据通过`摘要算法`计算出唯一摘要，比较两者是否相等，以防止信息被篡改

    3. 服务端加密通信算法改变通知，表示随后的信息都使用**会话秘钥**进行通信

    4. 服务端握手结束通知，表示服务端握手阶段同样结束，再次使用`摘要算法`计算出上述产生所有数据的唯一摘要，并使用**会话秘钥**与算法进行加密生成`数字签名`，发送给客户端

- 握手结束：客户端将最后的数据解密后，计算摘要是否相等，验证成功后开始基于**会话秘钥**进行对称加密通信

总结：

- 防止冒充：在通信初期，客户端就会先通过CA公钥来判断服务端的可信度

- 防止窃取：使用非对称加密算法中的公钥，来解决对称加密算**会话秘钥**的配送问题，在后续摘要传输与通信使用**会话秘钥**即可，这整个过程就是混合加密

- 防止篡改：双方都通过**摘要算法**来保证数据的完整性，结合**会话秘钥**来加密传输摘要，可以更进一步防止摘要被恶意篡改冒充

# 参考
- [非对称加解密，私钥和公钥到底是谁来加密，谁来解密](https://blog.csdn.net/qq_23167527/article/details/80614454)

# 重点参考
- [非对称加密原理解析](https://blog.csdn.net/wzzvictory/article/details/9015155):文章2.2有误，详情见评论

- [混合加密流程](https://zhuanlan.zhihu.com/p/157502520)
- [iOS密码学及签名机制](https://www.jianshu.com/p/04205346e0e0)
- [HTTPS协议详解(四)：TLS/SSL握手过程](https://blog.csdn.net/hherima/article/details/52469674)
