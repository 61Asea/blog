# TCP

传输层：网络层只把`分组交换`到目的主机，但真正通信的并不是主机而是进程。传输层提供了不同主机进程间的逻辑通信，传输层向应用层屏蔽了下面网际层（网络层）的核心细节，使得应用程序看起来像是在两个传输层实体之间有一条**端到端的逻辑通信信道**

> 什么是TCP？

TCP是`面向连接`、**可靠的**、`基于字节流`的`传输层`通信协议

- 面向连接：点对点连接（**一对一**）；UDP协议可以一个主机同时向多个主机发送消息（后者为**一对多**）
- 可靠：无论网络链路发送了什么变化，TCP都能保证一个报文一定到达接收端
- 字节流
    - 没有边界：消息无论多大都可以进行传输
    - 有序：当前一个消息没有收到时，即使先收到了后面的字节，那么也不能扔给上层应用层去处理
    - 重复过滤：对重复的报文会自动丢弃

> 什么是TCP连接？

![TCP连接信息](https://asea-cch.life/upload/2021/10/TCP%E8%BF%9E%E6%8E%A5%E4%BF%A1%E6%81%AF-9e0eebc3f6a3408895b52a7a8e5dda2f.png)

保证**可靠性**和**流量控制**从而维护的某些状态信息，这些信息的组合称为连接：
- `Socket`：**成对出现**，分别代表连接方和发送方，具体由IP地址和端口号组成
- `序列号`：解决丢包、乱序问题
- `窗口大小`：用来做流量控制

所以，建立一个TCP连接，就是通信的双方达成上述三个信息的共识

> 如何唯一确定一个TCP连接？

通过`TCP四元组`，可以唯一的确定一个连接，包括如下信息：

- 源地址
- 源端口
- 目标地址
- 目标端口

源地址、目标地址的字段都为**32位**大小，存在IP头部中，作用是通过IP协议发送报文给对方主机

源端口、目标端口的字段都为**16位**大小，存在TCP头部中，作用是告诉TCP协议应该把**报文发给哪个进程**

**注意：双端的每个TCP连接都是独立的，客户端在建立连接时可能会使用旧/新的端口进行超时重试，所以对于双端而言，影响四元组的唯一性在于客户端的端口变化**

当使用旧的端口建立新的TCP连接，也称为**重用失效连接**

> 为什么需要TCP协议，它工作在哪一层？

IP层是**不可靠**的，它不保证网络包的交付与按序交付，也不保证网络包中数据的完整性

为了保障网络数据包的可靠性，需要由上层**传输层**提供能力进行负责，所以TCP协议应运而生

它是工作在**传输层**的可靠数据传输服务，能确保接收端接收的网络包是**无损坏**、**无间隔**、**非冗余**、**按序**

# **1. TCP报文段**

> 一个TCP报文段，组成包括：TCP首部 + TCP报文段的数据部分

![TCP首部格式](https://asea-cch.life/upload/2021/10/TCP%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F-14e43e7f9ec545a2abd78e568c8ebcda.png)

![TCP首部格式标红](https://asea-cch.life/upload/2021/10/TCP%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F%E6%A0%87%E7%BA%A2-39204c0fb93d40eea6293db429ce656b.png)

- 源、目标端口号：标识通信的双方属于各自系统的哪个进程

- **序列号（seq）**

    在建立连接时由计算机生成的随机数作为其初始值，通过SYN包传给接收端主机
    
    每发送一次数据，就累加一次该数据字节数的大小，用来**解决网络包乱序问题**

- **确认应答号（ack）**

    对应`ACK`控制位，指下一次期望收到的数据的序列号
    
    每接收到一个报文段，以`数据长度+seq`的结果作为ack进行返回，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收，用来**解决丢包的问题**

- **控制位（ctl）**

    - ACK：该位为1时，确认应答号的字段变为有效，一般情况下除了最初建立连接时的纯SYN包之外，该位都必须设置为1
    - SYN：该位为1时，表示希望建立连接，并在**其序列号的字段进行序列号初始值的设定**
    - RST：该位为1时，表示TCP连接中出现异常必须强制断开连接
    - FIN：表示今后不会再有数据发送，希望断开连接
    - PSH：某一端的进程希望在键入一个命令后，能够立即收到对方的响应，接收方在收到PSH=1的报文段，就尽快地交付接受应用程序的数据，而不再等到整个缓存填满了再向应用层上层交付
    - URG：该位为1时，表示该报文段有紧急数据，应尽快传送，而不要按照之前的排队顺序传送
        发送方会将紧急数据插到本段报文段数据的最前面，并与首部的**紧急指针**配合使用，紧急数据之后仍是普通数据

- 数据偏移：指的是数据部分距离TCP报文段起始处的偏移量

- 窗口：窗口值作为接收方让发送方设置其发送窗口的大小依据。之所以有该依据，是因为接收方的数据缓存空间是有限的

> 后面讲到拥塞控制、流量控制，会着重分析固定/滑动窗口

- 紧急指针：仅在控制位URG为1时才有意义，因为紧急数据会被插到报文段数据的最前面，所以它指出本报文中紧急数据的字节数（紧急数据的末尾在报文段中的位置），且即使窗口为0时也可以发送紧急数据

## **1.1 SYN报文段**

表示建立连接，如果控制位只有SYN，则该包是整个TCP连接的第一个包

当SYN位为1，意味着序列号seq为端初始化后的结果，后续seq将以该值往下增长：
- **没有数据，则增加一（三次握手seq+1的原因）**
- 有数据，则增加数据长度

## **1.2 ACK报文段**

`有求必应`是TCP的一个特征，只要接收方收到发送端的报文段，则必须返回一个ACK包作为回应，否则将触发发送方的`TCP超时重传`机制

当ACK位为1，报文段TCP首部的ack字段有值，该值有两个作用：

- 表示接收方期望下一次收到对方发送报文段的**seq值**，发送方在下一个包会**以此值作为首部seq值**
- 发送方可以根据ack值来确认接收方数据接收的情况，防止丢包

> 双端TCP连接除了第一个报文段，其他的报文段都会带有ACK控制位，包括`发送数据`、`推送数据`、`关闭连接`等

## **1.3 ACK组合**

只有在第一个报文段不具备ACK，所以在某些情况下，可以组合出不同的控制位组合：

- SYN + ACK：建立连接的第二次握手
- PSH + ACK：推送数据
- FIN + ACK：关闭连接的第一、三次挥手
- RST + ACK：重置连接

**作为接收方，回应ACK时可以回应接收到的多个报文段序列号的总和，通过这种方式可以减少交互次数，并不是傻傻的对每一个数据发送都进行单独返回**

# **2. TCP连接/销毁过程**

![TCP连接全过程的报文段首部](https://asea-cch.life/upload/2021/10/TCP%E8%BF%9E%E6%8E%A5%E5%85%A8%E8%BF%87%E7%A8%8B%E7%9A%84%E6%8A%A5%E6%96%87%E6%AE%B5%E9%A6%96%E9%83%A8-d9e01608a2ca4839a6da5d3e1339e291.png)

## **2.1 建立连接（三次握手）**

TCP是面向连接的协议，使用TCP之前必须先建立TCP连接，而**建立连接通过三次握手进行**

![三次握手](https://asea-cch.life/upload/2021/10/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-5612c7b628124ad1a9047c523ca50614.jpg)

> 注意，**第一、二次握手阶段都不能携带数据，直到第三次握手才可以携带数据**，所以seq增长的大小都为1

一开始，双端都处于`CLOSED`状态，直到服务器主动监听某个端口，即处于`LISTEN`状态：

- 第一次握手：发起方（客户端）向接收方发送`SYN`报文段，希望与对方建立连接

    > 该报文段是整个TCP连接的第一个段，也是唯一只有SYN控制位的段

    首部关键信息：SYN = 1，seq = client_isn

    客户端状态：SYS_SENT

    服务端状态：LISTENED

- 第二次握手：接收方（服务端）发送`SYN + ACK`报文段，表示接受发起方的建立请求

    > 将连接建立的决定权交由发起方（客户端）自行判断是否最终建立连接，接收方自身则以对方的ACK返回来确定连接建立的最终结果

    首部关键信息：SYN = 1，ACK = 1，seq = server_isn，ack = client_isn + 1

    客户端状态：SYS_SENT

    服务端状态：SYN_RCVD

- 第三次握手：发起方（客户端）向接收方（服务端）发送`ACK`报文段，当接收方接收到该段时，双向TCP连接确定

    > 发起方（客户端）根据第二次握手的报文段进行判断，若成功则自身先进入`ESTABLISHED`；随后向接收方发送`ACK`报文段，当接收方接收到第三次握手的段时，也进入`ESTABLISHED`

    首部关键信息：ACK = 1，seq = client_isn + 1，ack = server_isn + 1

    客户端状态：ESTABLISHED

    服务端状态：SYNC_RCVD -> ESTABLISHED

一旦完成三次握手，双方都处于`ESTABLISHED`状态，此时连接就算建立完成，客户端和服务端可以相互发送数据了

### **2.1.1 为什么不是二次、四次握手**

> [为什么TCP建立连接需要三次握手？](https://mp.weixin.qq.com/s/j2NBSTT6uM48zokY8e0mhQ)：TCP连接指的是双方对socket、序列号和窗口大小的确认共识，所以问题可以转化为 - 为什么三次握手才能初始化socket、序列号和窗口大小

**不能是二次握手的原因：**

- **阻止重复的、历史的连接初始化（主要原因）**

    对应问题的握手次数：二次握手

    > 大前提：在复杂的网络情况下，发起方如果没有接收到接收方的回应，会进行`超时重试`，**客户端的每次重试，都应视为一次新的TCP连接，因为每次建立连接时使用的并不是固定端口号**
    
    假设发起方连续发起了多次连接请求，二次握手会出现这种场景：
    
        发送方在这期间因为超时重试从而发送多个TCP连接请求（假设源端口一直变化，则每一个连接的四元组都不同）
        
    接收者（服务端）会为接收到每个SYN报文段都建立一个连接，并用以填充第二次握手的头部信息返回，并认为连接已经建立完成，这导致多个`重复`的`历史`连接被建立

    所以，三次握手可以**防止旧的重复连接初始化**从而造成混乱，他提供给发送方纠错的机会（因为确实只有发送方才有足够的上下文知道哪个段是有效的、不过期的）

    ![三次握手解决历史重复连接](https://asea-cch.life/upload/2021/10/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%A7%A3%E5%86%B3%E5%8E%86%E5%8F%B2%E9%87%8D%E5%A4%8D%E8%BF%9E%E6%8E%A5-189080451b164703afe0f7d5bd45fba0.webp)

    可以从上图看到，发送方通过`RST`控制位，**结合客户端自身上下文判断返回的ack是否符合期望**，以此来对错误的握手进行中断，最终会在最新的syn段到达后，以此建立**新的**、**正确的**TCP连接

- 确保双方的初始化序列号都被同步接收

    对应问题的握手次数：二次握手

    需要保证双端都接收同步了对方的初始序列号，因为初始序列号在后续传输过程至关重要，而确保的方式也同样通过一来一回的方式进行同步

**无需四次握手的原因：**

三次理论上是满足可靠连接的最少通信次数，无需更多的通信次数

> 另一种视角的四次握手：为什么第二次握手不是通过单独ACK、单独SYN进行两次通信？

控制位可以合并，直接合并成一个通信可以减少通信次数

### **2.1.2 ISN**

双端的每一次TCP连接，其初始化序列号（初始ISN）是**随机产生**的，且序号值会随着数据通信交互而增加

**ISN为什么是随机的：**

> [《使用固定ISN的问题》](https://blog.csdn.net/qq_35733751/article/details/80552037)

- 安全性

    当客户端A和服务器B建立TCP连接后，只要tcp报文段的四元组和ISN与连接的相同，那么就会报文段就会被B确认并接收
    
    如果存在恶意客户端C，在固定ISN的场景下，可以直接通过ISN和合适的四元组，直接伪造出一个恶意tcp报文段，对A和B的正常连接进行干扰打断

    所以，使用随机ISN，可以避免非同一网络的伪造攻击，攻击者将无法方便的猜测ISN值并模拟攻击

    > 问：就算使用随机ISN，黑客也可以直接抓包就解析出ISN的值
    
    答：**抓包只能发送在同一网络中**

- **防止历史报文被新的连接接收，产生数据错乱**

    当一个已经失效的连接被重用了（**再次以相同的四元组建立新的TCP连接**），但是该旧连接的历史报文还残留在网络中，如果序列号固定相同，则**无法分辨该报文是否为历史报文**。如果新连接接收了历史报文，将会产生数据错乱

**初始序列号ISN是如何随机产生的：**

`ISN = M + F(localhost, localport, remotehost, remoteport)`

- M：计时器，每隔4毫秒 + 1，转一圈要4.55个小时
- F：hash函数，根据源IP、源端口、目标IP、目标端口生成一个随机数值

### **2.1.3 MSS**

![MTU和MSS](https://asea-cch.life/upload/2021/10/MTU%E5%92%8CMSS-f4b5222283d844019dc8e9b7adc18b83.png)

MTU：Maximum Transmit Unit，最大传输单元，即**物理接口（数据链路层）提供给上层（IP层）**最大一次传输数据的大小，缺省MTU = 1500 Bytes

> 以太网接口对IP层的约束，如果IP层有<=1500 byte需要发送，只需要一个IP包就可以完成发送任务；如果IP层有>1500 byte数据需要发送，需要分片才能完成发送，这些分片有一个共同点，即IP Header ID相同

MSS：Maximum Segment Size，报文段数据最大长度，TCP从传输层提交给网络层，不包含**TCP Header**和**IP Header**

> TCP对应用层发送字节数的约束，如果底层物理接口MTU = 1500 byte，则MSS = 1500 - 20（IP Header） - 20（TCP Header）= 1460 byte这意味着如果应用层需要发送2000byte，则需要分成两个segment才可以完成发送（第一个段数据为1460，第二个段数据为540）

**既然有IP层根据MTU进行分片，为什么TCP层还需要MSS？**

场景：

假设没有MSS，当应用层有一个超过MTU大小数据需要发送，提交到IP层时会按照MTU分成若干片，再由目标主机进行组装提交给其目标上层，那么当一个IP分片丢失时，目标主机将不会响应ACK给对方

然而IP层本身没有超时重传机制，**由传输层的TCP负责超时重传**，但是**TCP无法感知IP层MTU分片的详情**，那么当源等待ack超时后，只能重发整个TCP报文

MTU问题：当一个IP分片丢失时，整个IP报文的所有分片都会重传

结论：**通过IP层进行分片传输，在超时重试时效率低**

MSS分片优点：**避免IP层分片，超时重发时以MSS为单位，无需重传所有IP分片，增加重传效率**

TCP协议在建立连接时要**协商双方的MSS值**，MSS的值**取决于发送端和接收端两者较小的MSS的值**

> 当TCP发现数据超过MSS时，就会先进行分片，由它所形成的IP包长度也就不会大于MTU，自然也无需IP分片

### **2.1.4 SYN攻击**

- 半连接队列（SYN队列、未连接队列）：存放第一次握手的报文段

- 全连接队列（Accept队列，已完成连接队列）：存放已经成功三次握手的报文段

**正常流程：**

![半连接队列和全连接队列](https://asea-cch.life/upload/2021/10/%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E5%92%8C%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97-d7bb53a677104501adc8db7225913bac.png)

> 在socket上收发数据，相当于对一个文件进行读写，所以一个socket句柄通常也用文件句柄的fd来表示

1. 第一次握手（服务端接收客户端的SYN报文），新建socket句柄（fd），**将该句柄加入到内核的`半连接队列`**

2. 第二次握手（服务端响应SYN + ACK报文给客户端）并等待客户端响应，**此时句柄仍在半连接队列中**

3. 第三次握手（客户端响应ACK报文给服务器），将**句柄从半连接队列移除，并加入到全连接队列中**

4. 应用通过调用accpet()，接收socket接口，将句柄**从全连接队列中取出**

    在epoll模型中，服务器会先注册一个accept事件类型的fd，并调用epoll_wait()函数陷入内核态等待，**accpet句柄与全连接队列息息相关**
    
    当建立起新的TCP连接时，全连接队列会加入新的客户端socket句柄，accpet句柄将处于就绪状态（此刻，数据都已经在内核中）
    
    接下来应用程序调用accpet()方法，读取到accept句柄中的新客户端句柄，并为这些新句柄注册读/写事件兴趣类型

**应用程序accept过慢，导致全连接队列溢出（消费速率低）**

![全连接队列溢出](https://asea-cch.life/upload/2021/10/%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E6%BA%A2%E5%87%BA-5ed2de2c18c449e79faa5811b629d015.png)

**SYN攻击：**

攻击者在短时间内伪造不同IP地址的SYN报文，服务端每接收到一个SYN报文，就进入SYN_RCVD状态，但服务端发送出去的第二次握手，不会得到攻击者IP主机的第三次握手，**久而久之就会占满服务器的半连接队列（SYN接收队列）**

- 方法一：控制半连接队列的大小，调整溢出时的拒绝策略

    **net.core.netdev_max_backlo**`：当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包，控制该队列的最大值

    `net.ipv4.tcp_max_syn_backlog`：半连接（SYN_RCVD状态连接）的最大个数

    `net.ipv4.tcp_abort_on_overflow`：超出处理能力时，对新的SYN直接响应RST进行丢弃

- 方法二：使用syn cookies算法
    
    `net.ipv4.tcp_syncookies = 1`：当半连接队列满后，后续收到SYN包不会进入到SYN队列，而是通过：**计算cookie值，填充到第二次握手的序列号中返回客户端**
    
    接下来，服务端接收到第三次握手时，会检查该ACK包的合法性，期望收到计算出的`cookie seq + 1`值，如果符合期望则将序列号值 - 1，并通过syn cookies算法反向解析出客户端第一次握手时的部分信息，并加入到全连接队列中
    
    合法性检查主要是为了解决：攻击者随机伪造seq填充入第三次握手的ack包响应给服务器，因为syn cookies算法的结果由服务器决定，除非攻击者把第二次握手生成的seq + 1填充进去ack包

    > [《syn cookies算法》](https://segmentfault.com/a/1190000019292140)：syn flood攻击的本质是占据服务器有限的资源，所以使用syn cookies后可以不将连接信息放入到半连接队列中，取而代之将客户端的部分信息通过算法存放到序列号中，在第三次握手时取出解析从而建立TCP连接

## **2.2 关闭连接（四次挥手）**

**双方都可以主动断开连接**，断开连接后主机中的资源将被释放

![四次挥手](https://asea-cch.life/upload/2021/10/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B-418fcfdc70bd44d98f242b2c47e1d430.jpg)

- 第一次挥手：客户端发送`FIN`报文给服务器，希望主动断开连接

    > 之后客户端进入`FIN_WAIT_1`状态

    首部关键信息：FIN = 1，seq = [不知道怎么算出来的 x]

    客户端状态：ESTABLISHED -> FIN_WAIT_1

    服务端状态：ESTABLISHED

- 第二次挥手：服务器收到FIN报文后，向客户端发送`ACK`应答报文

    > 之后服务器进入`CLOSED_WAIT`状态，客户端在接收到应答报文后，进入`FIN_WAIT_2`状态

    首部关键信息：ACK = 1，ack = [x + 1]，seq = 最后一次发送数据时的seq

    客户端状态：FIN_WAIT_1 -> FIN_WAIT_2

    服务端状态：ESTABLISHED -> CLOSED_WAIT

- 第三次挥手：**等待服务端处理完数据后**，也向客户端发送FIN报文

    > 之后服务端进入`LAST_ACK`状态

    首部关键信息：FIN = 1，seq = [又不知道怎么算出的 y]，ack = [x + 1]

    客户端状态：FIN_WAIT_2

    服务端状态：CLOSED_WAIT -> LAST_ACK

- 第四次挥手：客户端收到FIN报文后，同样向服务器发送`ACK`应答报文

    > 之后客户端进入`TIME_WAIT`状态，**并在经过`2MSL`一段时间后，自动进入CLOSED状态**

    首部关键信息：ACK = 1，seq = [x + 1]，ack = [y + 1]

    客户端状态：FIN_WAIT_2 -> TIME_WAIT -> CLOSE

    服务端状态：LAST_ACK -> CLOSE

注意点：

1. 主动关闭连接的，才有`TIME_WAIT`状态

2. 每个方向都需要一个FIN和一个ACK


### **2.2.1 为什么挥手需要四次**

FIN报文：表示某一端不再发送数据，但仍可接收数据

客户端发送FIN报文后，服务器会先**只返回**一个ACK应答报文，这是因为**服务器可能还有数据需要处理与发送**，只有当服务端不再需要发送数据时，才发送给客户端FIN报文

可类比建立连接时为什么不将第二次握手拆分成两次握手：

> 之所以建立连接将这两步合并成一步，是因为才刚建立连接，确实没有数据需要处理，并且报文段也支持多个控制位；然而释放连接时情况就不同了，服务器可能有数据需要处理，所以先单独返回一个ACK

结论：**服务器通常还需要等待完成数据的处理和发送，所以其ACK和FIN会分开发送，从而比三次握手多了一次**

### **2.2.2 MSL**

MSL：Maximum Segement Lifetime，**报文最大生存时间**，它表示任何报文在网络上存在的最长时间，超过这个时间的报文都将被丢弃

> TTL：IP首部格式中的字段，指IP数据报可以经过的最大路由数，每经过一个处理它的路由器此值减1，当值为0时将被丢弃，同时发送**ICMP报文**通知源主机

**MSL和TTL的区别：**MSL单位是时间，TTL是经过路由数，所以MSL的值应该要大于等于TTL消耗为0的时间，以确保报文已被自然消亡

### **2.2.3 TIME_WAIT**

TIME_WAIT：等待2MSL秒后，将端的该TCP连接状态变为CLOSE

TIME_WAIT有如下**两个作用**：

> 下面以没有TIME_WAIT或TIME_WAIT设置过短作为反例，来突出TIME_WAIT的必要性

- 防止收到相同四元组的**旧**数据包

    ![TIME_WAIT过短导致旧报文影响复用新连接](https://asea-cch.life/upload/2021/10/TIME_WAIT%E8%BF%87%E7%9F%AD%E5%AF%BC%E8%87%B4%E6%97%A7%E6%8A%A5%E6%96%87%E5%BD%B1%E5%93%8D%E5%A4%8D%E7%94%A8%E6%96%B0%E8%BF%9E%E6%8E%A5-eff9030ce1ad47d9afa52f5046fbc183.png)

    在客户端第一次握手前，可能双方有报文仍在网络中，但处于阻塞。假设双方断开连接后又复用旧连接来建立新TCP连接，之前的报文可能恰好延迟到达，则有可能接受该过期报文，**导致新的TCP连接数据错乱**

    通过TIME_WAIT状态，并使其维持2MSL的时长，可以借助MSL的特性，**使旧的数据包自然过期，保证数据包都是新连接产生的**

- 保证被动关闭连接的一方能被正确关闭，即保证最后一次挥手能让被动关闭方接收，**从而帮助其正常关闭**

    ![TIME_WAIT过短导致服务端无法关闭](https://asea-cch.life/upload/2021/10/TIME_WAIT%E8%BF%87%E7%9F%AD%E5%AF%BC%E8%87%B4%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%97%A0%E6%B3%95%E5%85%B3%E9%97%AD-1118fd3c45664e86bf00d708e6cf56b1.png)

    发起方最后一次挥手后直接进入CLOSE状态，如果该ACK报文段丢失在网络中，服务器会**长时间处于LAST_ACK**状态中。这时，客户端以相同的四元组，再次向服务端发起新TCP连接请求时，会一直被服务器以`RST`报文回拒

    以整体视角来看，这**导致双方在服务器退出LAST_ACK状态前，都无法建立新连接**

    以服务端视角来看，**服务端本次TCP连接无法正常关闭，导致长时间内存资源占用**

#### **为什么等待时长为2MSL（最小等待时长为多少）**

利用**超过MSL时长的包都会被丢弃**的原理，并解决如下场景：

    网络情况极差，发送方的ACK报文在网络中阻塞无法在MSL秒内到达，服务端因为没接收到ACK报文，因此再发送FIN报文重试第三次挥手
    
**理论上的临界情况：**

服务端的FIN包重试，恰好等于**第2MSL秒**，或在值内到达发送方，发送方可以重试第四次挥手ACK报文

超过这个时间，默认情况接收方已经接收到ack包，不良情况下为服务端的重试FIN包再次丢失

**结论：等待2MSL时长，可以在糟糕的网络情况下，确保收到至少一次服务端的FIN包重试**

#### **为何TIME_WAIT时长不设置比2MSL更长的时间**

如果TIME_WAIT状态的等待时间过长，会出现过多处于TIME_WAIT的连接，这样会造成：    

- 客户端（作为**连接发起方**）：端口资源占用过多，占满所有端口将会无法再创建新连接

- 服务端：内存资源占用过多，应用处理应对能力丢失

    理论上服务端只监听一个端口，通过四元组可以建立无数连接，但是连接是通过线程处理的
    
    如果连接过多，可能会导致系统资源占满，线程池无法应对那么多一直不断的连接，从而无法处理新建立的连接

### **2.2.4 客户端崩溃**

**TCP保活机制：**定义一个时间段，在这个时间段内，如果**没有任何与连接相关的活动**，TCP保活机制会开始作用，每隔一个时间间隔发送一个探测报文，如果连续几个探测报文都没有得到响应，则认为当前的TCP连接已经死亡，系统内核会将错误信息通知给上层应用程序

```shell
# 表示保活时间为7200秒（2小时），即2小时后如果没有任何连接相关的活动，则执行保护机制
net.ipv4.tcp_keepalive_time=7200
# 每次探测间隔为75秒
net.ipv4.tcp_keepalive_intvl=75
# 无响应检测次数，表示9次检测都无响应则认为对方是不可达的，从而中断连接
net.ipv4.tcp_keepalive_probes=9
```

> 7200 + 75 * 9 = 7875秒，即在Linux系统中的一个死亡连接在对方没有进行通信操作的情况下，最少需要经过2小时11分15秒才可以被发现

通过保活机制，引申出以下两种客户端崩溃：

1. 对端程序**崩溃重启**，当TCP保护的探测报文发给对方后，对端可以响应，但是由于没有该连接的有效信息，会产生一个RST报文，并发现TCP连接已经死亡

2. 对端程序**崩溃**，或网络原因导致报文不可达，当TCP保护的探测报文发送给对端后，连续多次没有效应，直到达到保活探测次数后，TCP会报告该TCP连接已经死亡

# 参考
- [cyc：计算机网络-传输层](https://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E4%BC%A0%E8%BE%93%E5%B1%82.html)
- [三次握手中确认号和序列号为什么要加一？](https://blog.csdn.net/IT_Studio/article/details/108896950)
- [报文、报文段、分组、包、数据报、帧、数据流的概念区别](https://blog.csdn.net/a3192048/article/details/84671340)
- [TCP面向字节流和报文段的关系是什么？](https://www.zhihu.com/question/34003599/answer/139286798)
- [使用固定ISN的问题](https://blog.csdn.net/qq_35733751/article/details/80552037)

# 重点参考
- [为什么 TCP 建立连接需要三次握手 ？](https://mp.weixin.qq.com/s/j2NBSTT6uM48zokY8e0mhQ)
- [TCP协议抓包分析](https://blog.csdn.net/qq_22421145/article/details/80334846)
- [TCP三次握手？二次握手为什么不行？](https://zhuanlan.zhihu.com/p/113090324)