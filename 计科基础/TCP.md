# TCP

传输层：网络层只把`分组交换`到目的主机，但真正通信的并不是主机而是进程。传输层提供了不同主机进程间的逻辑通信，传输层向应用层屏蔽了下面网际层（网络层）的核心细节，使得应用程序看起来像是在两个传输层实体之间有一条**端到端的逻辑通信信道**

> 什么是TCP？

TCP是`面向连接`、**可靠的**、`基于字节流`的`传输层`通信协议

- 面向连接：点对点连接（**一对一**）；UDP协议可以一个主机同时向多个主机发送消息（后者为**一对多**）
- 可靠：无论网络链路发送了什么变化，TCP都能保证一个报文一定到达接收端
- 字节流
    - 没有边界：消息无论多大都可以进行传输
    - 有序：当前一个消息没有收到时，即使先收到了后面的字节，那么也不能扔给上层应用层去处理
    - 重复过滤：对重复的报文会自动丢弃

> 什么是TCP连接？

![TCP连接信息](https://asea-cch.life/upload/2021/10/TCP%E8%BF%9E%E6%8E%A5%E4%BF%A1%E6%81%AF-9e0eebc3f6a3408895b52a7a8e5dda2f.png)

保证**可靠性**和**流量控制**从而维护的某些状态信息，这些信息的组合称为连接：
- `Socket`：**成对出现**，分别代表连接方和发送方，具体由IP地址和端口号组成
- `序列号`：解决丢包、乱序问题
- `窗口大小`：用来做流量控制

所以，建立一个TCP连接，就是通信的双方达成上述三个信息的共识

> 如何唯一确定一个TCP连接？

通过`TCP四元组`，可以唯一的确定一个连接，包括如下信息：

- 源地址
- 源端口
- 目标地址
- 目标端口

源地址、目标地址的字段都为**32位**大小，存在IP头部中，作用是通过IP协议发送报文给对方主机

源端口、目标端口的字段都为**16位**大小，存在TCP头部中，作用是告诉TCP协议应该把**报文发给哪个进程**

**注意：双端的每个TCP连接都是独立的，客户端在建立连接时可能会使用旧/新的端口进行超时重试，所以对于双端而言，影响四元组的唯一性在于客户端的端口变化**

当使用旧的端口建立新的TCP连接，也称为**重用失效连接**

> 为什么需要TCP协议，它工作在哪一层？

IP层是**不可靠**的，它不保证网络包的交付与按序交付，也不保证网络包中数据的完整性

为了保障网络数据包的可靠性，需要由上层**传输层**提供能力进行负责，所以TCP协议应运而生

它是工作在**传输层**的可靠数据传输服务，能确保接收端接收的网络包是**无损坏**、**无间隔**、**非冗余**、**按序**

# **1. TCP报文段**

> 一个TCP报文段，组成包括：TCP首部 + TCP报文段的数据部分

![TCP首部格式](https://asea-cch.life/upload/2021/10/TCP%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F-14e43e7f9ec545a2abd78e568c8ebcda.png)

![TCP首部格式标红](https://asea-cch.life/upload/2021/10/TCP%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F%E6%A0%87%E7%BA%A2-39204c0fb93d40eea6293db429ce656b.png)

- 源、目标端口号：标识通信的双方属于各自系统的哪个进程

- **序列号（seq）**

    在建立连接时由计算机生成的随机数作为其初始值，通过SYN包传给接收端主机
    
    每发送一次数据，就累加一次该数据字节数的大小，用来**解决网络包乱序问题**

- **确认应答号（ack）**

    对应`ACK`控制位，指下一次期望收到的数据的序列号
    
    每接收到一个报文段，以`数据长度+seq`的结果作为ack进行返回，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收，用来**解决丢包的问题**

- **控制位（ctl）**

    - ACK：该位为1时，确认应答号的字段变为有效，一般情况下除了最初建立连接时的纯SYN包之外，该位都必须设置为1
    - SYN：该位为1时，表示希望建立连接，并在**其序列号的字段进行序列号初始值的设定**
    - RST：该位为1时，表示TCP连接中出现异常必须强制断开连接
    - FIN：表示今后不会再有数据发送，希望断开连接
    - PSH：某一端的进程希望在键入一个命令后，能够立即收到对方的响应，接收方在收到PSH=1的报文段，就尽快地交付接受应用程序的数据，而不再等到整个缓存填满了再向应用层上层交付
    - URG：该位为1时，表示该报文段有紧急数据，应尽快传送，而不要按照之前的排队顺序传送
        发送方会将紧急数据插到本段报文段数据的最前面，并与首部的**紧急指针**配合使用，紧急数据之后仍是普通数据

- 数据偏移：指的是数据部分距离TCP报文段起始处的偏移量

- 窗口：窗口值作为接收方让发送方设置其发送窗口的大小依据。之所以有该依据，是因为接收方的数据缓存空间是有限的

> 后面讲到拥塞控制、流量控制，会着重分析固定/滑动窗口

- 紧急指针：仅在控制位URG为1时才有意义，因为紧急数据会被插到报文段数据的最前面，所以它指出本报文中紧急数据的字节数（紧急数据的末尾在报文段中的位置），且即使窗口为0时也可以发送紧急数据

## **1.1 SYN报文段**

表示建立连接，如果控制位只有SYN，则该包是整个TCP连接的第一个包

当SYN位为1，意味着序列号seq为端初始化后的结果，后续seq将以该值往下增长：
- **没有数据，则增加一（三次握手seq+1的原因）**
- 有数据，则增加数据长度

## **1.2 ACK报文段**

`有求必应`是TCP的一个特征，只要接收方收到发送端的报文段，则必须返回一个ACK包作为回应，否则将触发发送方的`TCP超时重传`机制

当ACK位为1，报文段TCP首部的ack字段有值，该值有两个作用：

- 表示接收方期望下一次收到对方发送报文段的**seq值**，发送方在下一个包会**以此值作为首部seq值**
- 发送方可以根据ack值来确认接收方数据接收的情况，防止丢包

> 双端TCP连接除了第一个报文段，其他的报文段都会带有ACK控制位，包括`发送数据`、`推送数据`、`关闭连接`等

## **1.3 ACK组合**

只有在第一个报文段不具备ACK，所以在某些情况下，可以组合出不同的控制位组合：

- SYN + ACK：建立连接的第二次握手
- PSH + ACK：推送数据
- FIN + ACK：关闭连接的第一、三次挥手
- RST + ACK：重置连接

**作为接收方，回应ACK时可以回应接收到的多个报文段序列号的总和，通过这种方式可以减少交互次数，并不是傻傻的对每一个数据发送都进行单独返回**

# **2. TCP连接/销毁过程**

![TCP连接全过程的报文段首部](https://asea-cch.life/upload/2021/10/TCP%E8%BF%9E%E6%8E%A5%E5%85%A8%E8%BF%87%E7%A8%8B%E7%9A%84%E6%8A%A5%E6%96%87%E6%AE%B5%E9%A6%96%E9%83%A8-d9e01608a2ca4839a6da5d3e1339e291.png)

## **2.1 建立连接（三次握手）**

TCP是面向连接的协议，使用TCP之前必须先建立TCP连接，而**建立连接通过三次握手进行**

![三次握手](https://asea-cch.life/upload/2021/10/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-5612c7b628124ad1a9047c523ca50614.jpg)

> 注意，**第一、二次握手阶段都不能携带数据，直到第三次握手才可以携带数据**，所以seq增长的大小都为1

一开始，双端都处于`CLOSED`状态，直到服务器主动监听某个端口，即处于`LISTEN`状态：

- 第一次握手：发起方（客户端）向接收方发送`SYN`报文段，希望与对方建立连接

    > 该报文段是整个TCP连接的第一个段，也是唯一只有SYN控制位的段

    首部关键信息：SYN = 1，seq = client_isn

    客户端状态：SYS_SENT

    服务端状态：LISTENED

- 第二次握手：接收方（服务端）发送`SYN + ACK`报文段，表示接受发起方的建立请求

    > 将连接建立的决定权交由发起方（客户端）自行判断是否最终建立连接，接收方自身则以对方的ACK返回来确定连接建立的最终结果

    首部关键信息：SYN = 1，ACK = 1，seq = server_isn，ack = client_isn + 1

    客户端状态：SYS_SENT

    服务端状态：SYN_RCVD

- 第三次握手：发起方（客户端）向接收方（服务端）发送`ACK`报文段，当接收方接收到该段时，双向TCP连接确定

    > 发起方（客户端）根据第二次握手的报文段进行判断，若成功则自身先进入`ESTABLISHED`；随后向接收方发送`ACK`报文段，当接收方接收到第三次握手的段时，也进入`ESTABLISHED`

    首部关键信息：ACK = 1，seq = client_isn + 1，ack = server_isn + 1

    客户端状态：ESTABLISHED

    服务端状态：SYNC_RCVD -> ESTABLISHED

一旦完成三次握手，双方都处于`ESTABLISHED`状态，此时连接就算建立完成，客户端和服务端可以相互发送数据了

### **2.1.1 为什么不是二次、四次握手**

> [为什么TCP建立连接需要三次握手？](https://mp.weixin.qq.com/s/j2NBSTT6uM48zokY8e0mhQ)：TCP连接指的是双方对socket、序列号和窗口大小的确认共识，所以问题可以转化为 - 为什么三次握手才能初始化socket、序列号和窗口大小

**不能是二次握手的原因：**

- **阻止重复的、历史的连接初始化（主要原因）**

    对应问题的握手次数：二次握手

    > 大前提：在复杂的网络情况下，发起方如果没有接收到接收方的回应，会进行`超时重试`，**客户端的每次重试，都应视为一次新的TCP连接，因为每次建立连接时使用的并不是固定端口号**
    
    假设发起方连续发起了多次连接请求，二次握手会出现这种场景：
    
        发送方在这期间因为超时重试从而发送多个TCP连接请求（假设源端口一直变化，则每一个连接的四元组都不同）
        
    接收者（服务端）会为接收到每个SYN报文段都建立一个连接，并用以填充第二次握手的头部信息返回，并认为连接已经建立完成，这导致多个`重复`的`历史`连接被建立

    所以，三次握手可以**防止旧的重复连接初始化**从而造成混乱，他提供给发送方纠错的机会（因为确实只有发送方才有足够的上下文知道哪个段是有效的、不过期的）

    ![三次握手解决历史重复连接](https://asea-cch.life/upload/2021/10/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%A7%A3%E5%86%B3%E5%8E%86%E5%8F%B2%E9%87%8D%E5%A4%8D%E8%BF%9E%E6%8E%A5-189080451b164703afe0f7d5bd45fba0.webp)

    可以从上图看到，发送方通过`RST`控制位，**结合客户端自身上下文判断返回的ack是否符合期望**，以此来对错误的握手进行中断，最终会在最新的syn段到达后，以此建立**新的**、**正确的**TCP连接

- 确保双方的初始化序列号都被同步接收

    对应问题的握手次数：二次握手

    需要保证双端都接收同步了对方的初始序列号，因为初始序列号在后续传输过程至关重要，而确保的方式也同样通过一来一回的方式进行同步

**无需四次握手的原因：**

三次理论上是满足可靠连接的最少通信次数，无需更多的通信次数

> 另一种视角的四次握手：为什么第二次握手不是通过单独ACK、单独SYN进行两次通信？

控制位可以合并，直接合并成一个通信可以减少通信次数

### **2.1.2 ISN**

双端的每一次TCP连接，其初始化序列号（初始ISN）是**随机产生**的，且序号值会随着数据通信交互而增加

**ISN为什么是随机的：**

> [《使用固定ISN的问题》](https://blog.csdn.net/qq_35733751/article/details/80552037)

- 安全性

    当客户端A和服务器B建立TCP连接后，只要tcp报文段的四元组和ISN与连接的相同，那么就会报文段就会被B确认并接收
    
    如果存在恶意客户端C，在固定ISN的场景下，可以直接通过ISN和合适的四元组，直接伪造出一个恶意tcp报文段，对A和B的正常连接进行干扰打断

    所以，使用随机ISN，可以避免非同一网络的伪造攻击，攻击者将无法方便的猜测ISN值并模拟攻击

    > 问：就算使用随机ISN，黑客也可以直接抓包就解析出ISN的值
    
    答：**抓包只能发送在同一网络中**

- **防止历史报文被新的连接接收，产生数据错乱**

    当一个已经失效的连接被重用了（**再次以相同的四元组建立新的TCP连接**），但是该旧连接的历史报文还残留在网络中，如果序列号固定相同，则**无法分辨该报文是否为历史报文**。如果新连接接收了历史报文，将会产生数据错乱

**初始序列号ISN是如何随机产生的：**

`ISN = M + F(localhost, localport, remotehost, remoteport)`

- M：计时器，每隔4毫秒 + 1，转一圈要4.55个小时
- F：hash函数，根据源IP、源端口、目标IP、目标端口生成一个随机数值

### **2.1.3 MSS**

![MTU和MSS](https://asea-cch.life/upload/2021/10/MTU%E5%92%8CMSS-f4b5222283d844019dc8e9b7adc18b83.png)

MTU：Maximum Transmit Unit，最大传输单元，即**物理接口（数据链路层）提供给上层（IP层）**最大一次传输数据的大小，缺省MTU = 1500 Bytes

> 以太网接口对IP层的约束，如果IP层有<=1500 byte需要发送，只需要一个IP包就可以完成发送任务；如果IP层有>1500 byte数据需要发送，需要分片才能完成发送，这些分片有一个共同点，即IP Header ID相同

MSS：Maximum Segment Size，报文段数据最大长度，TCP从传输层提交给网络层，不包含**TCP Header**和**IP Header**

> TCP对应用层发送字节数的约束，如果底层物理接口MTU = 1500 byte，则MSS = 1500 - 20（IP Header） - 20（TCP Header）= 1460 byte这意味着如果应用层需要发送2000byte，则需要分成两个segment才可以完成发送（第一个段数据为1460，第二个段数据为540）

**既然有IP层根据MTU进行分片，为什么TCP层还需要MSS？**

场景：

假设没有MSS，当应用层有一个超过MTU大小数据需要发送，提交到IP层时会按照MTU分成若干片，再由目标主机进行组装提交给其目标上层，那么当一个IP分片丢失时，目标主机将不会响应ACK给对方

然而IP层本身没有超时重传机制，**由传输层的TCP负责超时重传**，但是**TCP无法感知IP层MTU分片的详情**，那么当源等待ack超时后，只能重发整个TCP报文

MTU问题：当一个IP分片丢失时，整个IP报文的所有分片都会重传

结论：**通过IP层进行分片传输，在超时重试时效率低**

MSS分片优点：**避免IP层分片，超时重发时以MSS为单位，无需重传所有IP分片，增加重传效率**

TCP协议在建立连接时要**协商双方的MSS值**，当TCP发现数据超过MSS时，就会先进行分片，由它所形成的IP包长度也就不会大于MTU，自然也无需IP分片

### **2.1.4 SYN攻击**

- 半连接队列（SYN队列、未连接队列）：存放第一次握手的报文段

- 全连接队列（Accept队列，已完成连接队列）：存放已经成功三次握手的报文段

**正常流程：**

![半连接队列和全连接队列](https://asea-cch.life/upload/2021/10/%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E5%92%8C%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97-d7bb53a677104501adc8db7225913bac.png)

> 在socket上收发数据，相当于对一个文件进行读写，所以一个socket句柄通常也用文件句柄的fd来表示

1. 第一次握手（服务端接收客户端的SYN报文），新建socket句柄（fd），**将该句柄加入到内核的`半连接队列`**

2. 第二次握手（服务端响应SYN + ACK报文给客户端）并等待客户端响应，**此时句柄仍在半连接队列中**

3. 第三次握手（客户端响应ACK报文给服务器），将**句柄从半连接队列移除，并加入到全连接队列中**

4. 应用通过调用accpet()，接收socket接口，将句柄**从全连接队列中取出**

    在epoll模型中，服务器会先注册一个accept事件类型的fd，并调用epoll_wait()函数陷入内核态等待，**accpet句柄与全连接队列息息相关**
    
    当建立起新的TCP连接时，全连接队列会加入新的客户端socket句柄，accpet句柄将处于就绪状态（此刻，数据都已经在内核中）
    
    接下来应用程序调用accpet()方法，读取到accept句柄中的新客户端句柄，并为这些新句柄注册读/写事件兴趣类型

**应用程序accept过慢，导致全连接队列溢出（消费速率低）**

![全连接队列溢出](https://asea-cch.life/upload/2021/10/%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E6%BA%A2%E5%87%BA-5ed2de2c18c449e79faa5811b629d015.png)

**SYN攻击：**

攻击者在短时间内伪造不同IP地址的SYN报文，服务端每接收到一个SYN报文，就进入SYN_RCVD状态，但服务端发送出去的第二次握手，不会得到攻击者IP主机的第三次握手，**久而久之就会占满服务器的半连接队列（SYN接收队列）**

- 方法一：控制半连接队列的大小，调整溢出时的拒绝策略

    **net.core.netdev_max_backlo**`：当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包，控制该队列的最大值

    `net.ipv4.tcp_max_syn_backlog`：半连接（SYN_RCVD状态连接）的最大个数

    `net.ipv4.tcp_abort_on_overflow`：超出处理能力时，对新的SYN直接响应RST进行丢弃

- 方法二：使用syn cookies算法
    
    `net.ipv4.tcp_syncookies = 1`：当半连接队列满后，后续收到SYN包不会进入到SYN队列，而是通过：**计算cookie值，填充到第二次握手的序列号中返回客户端**
    
    接下来，服务端接收到第三次握手时，会检查该ACK包的合法性，期望收到计算出的`cookie seq + 1`值，如果符合期望则将序列号值 - 1，并通过syn cookies算法反向解析出客户端第一次握手时的部分信息，并加入到全连接队列中
    
    合法性检查主要是为了解决：攻击者随机伪造seq填充入第三次握手的ack包响应给服务器，因为syn cookies算法的结果由服务器决定，除非攻击者把第二次握手生成的seq + 1填充进去ack包

    > [《syn cookies算法》](https://segmentfault.com/a/1190000019292140)：syn flood攻击的本质是占据服务器有限的资源，所以使用syn cookies后可以不将连接信息放入到半连接队列中，取而代之将客户端的部分信息通过算法存放到序列号中，在第三次握手时取出解析从而建立TCP连接

## **2.2 关闭连接（四次挥手）**

**双方都可以主动断开连接**，断开连接后主机中的资源将被释放

### **为什么断开连接需要四次通信**

# 参考
- [cyc：计算机网络-传输层](https://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E4%BC%A0%E8%BE%93%E5%B1%82.html)
- [三次握手中确认号和序列号为什么要加一？](https://blog.csdn.net/IT_Studio/article/details/108896950)
- [报文、报文段、分组、包、数据报、帧、数据流的概念区别](https://blog.csdn.net/a3192048/article/details/84671340)
- [TCP面向字节流和报文段的关系是什么？](https://www.zhihu.com/question/34003599/answer/139286798)
- [使用固定ISN的问题](https://blog.csdn.net/qq_35733751/article/details/80552037)

# 重点参考
- [为什么 TCP 建立连接需要三次握手 ？](https://mp.weixin.qq.com/s/j2NBSTT6uM48zokY8e0mhQ)
- [TCP协议抓包分析](https://blog.csdn.net/qq_22421145/article/details/80334846)
- [TCP三次握手？二次握手为什么不行？](https://zhuanlan.zhihu.com/p/113090324)