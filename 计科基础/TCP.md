# TCP

传输层：网络层只把`分组交换`到目的主机，但真正通信的并不是主机而是进程。传输层提供了不同主机进程间的逻辑通信，传输层向应用层屏蔽了下面网际层（网络层）的核心细节，使得应用程序看起来像是在两个传输层实体之间有一条**端到端的逻辑通信信道**

> 什么是TCP？

TCP是`面向连接`、**可靠的**、`基于字节流`的`传输层`通信协议

- 面向连接：点对点连接（**一对一**）；UDP协议可以一个主机同时向多个主机发送消息（后者为**一对多**）
- 可靠：无论网络链路发送了什么变化，TCP都能保证一个报文一定到达接收端
- 字节流
    - 没有边界：消息无论多大都可以进行传输
    - 有序：当前一个消息没有收到时，即使先收到了后面的字节，那么也不能扔给上层应用层去处理
    - 重复过滤：对重复的报文会自动丢弃

> 什么是TCP连接？

![TCP连接信息](https://asea-cch.life/upload/2021/10/TCP%E8%BF%9E%E6%8E%A5%E4%BF%A1%E6%81%AF-9e0eebc3f6a3408895b52a7a8e5dda2f.png)

保证**可靠性**和**流量控制**从而维护的某些状态信息，这些信息的组合称为连接：
- `Socket`：**成对出现**，分别代表连接方和发送方，具体由IP地址和端口号组成
- `序列号`：解决丢包、乱序问题
- `窗口大小`：用来做流量控制

所以，建立一个TCP连接，就是通信的双方达成上述三个信息的共识

> 如何唯一确定一个TCP连接？

通过`TCP四元组`，可以唯一的确定一个连接，包括如下信息：
- 源地址
- 源端口
- 目标地址
- 目标端口

源地址、目标地址的字段都为**32位**大小，存在IP头部中，作用是通过IP协议发送报文给对方主机

源端口、目标端口的字段都为**16位**大小，存在TCP头部中，作用是告诉TCP协议应该把**报文发给哪个进程**

> 为什么需要TCP协议，它工作在哪一层？

IP层是**不可靠**的，它不保证网络包的交付与按序交付，也不保证网络包中数据的完整性

为了保障网络数据包的可靠性，需要由上层**传输层**提供能力进行负责，所以TCP协议应运而生

它是工作在**传输层**的可靠数据传输服务，能确保接收端接收的网络包是**无损坏**、**无间隔**、**非冗余**、**按序**

# **1. TCP报文段**

> 一个TCP报文段，组成包括：TCP首部 + TCP报文段的数据部分

![TCP首部格式](https://asea-cch.life/upload/2021/10/TCP%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F-14e43e7f9ec545a2abd78e568c8ebcda.png)

![TCP首部格式标红](https://asea-cch.life/upload/2021/10/TCP%E9%A6%96%E9%83%A8%E6%A0%BC%E5%BC%8F%E6%A0%87%E7%BA%A2-39204c0fb93d40eea6293db429ce656b.png)

- 源、目标端口号：标识通信的双方属于各自系统的哪个进程

- **序列号（seq）**

    在建立连接时由计算机生成的随机数作为其初始值，通过SYN包传给接收端主机
    
    每发送一次数据，就累加一次该数据字节数的大小，用来**解决网络包乱序问题**

- **确认应答号（ack）**

    对应`ACK`控制位，指下一次期望收到的数据的序列号
    
    每接收到一个报文段，以`数据长度+seq`的结果作为ack进行返回，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收，用来**解决丢包的问题**

- **控制位（ctl）**

    - ACK：该位为1时，确认应答号的字段变为有效，一般情况下除了最初建立连接时的纯SYN包之外，该位都必须设置为1
    - SYN：该位为1时，表示希望建立连接，并在**其序列号的字段进行序列号初始值的设定**
    - RST：该位为1时，表示TCP连接中出现异常必须强制断开连接
    - FIN：表示今后不会再有数据发送，希望断开连接
    - PSH：某一端的进程希望在键入一个命令后，能够立即收到对方的响应，接收方在收到PSH=1的报文段，就尽快地交付接受应用程序的数据，而不再等到整个缓存填满了再向应用层上层交付
    - URG：该位为1时，表示该报文段有紧急数据，应尽快传送，而不要按照之前的排队顺序传送
        发送方会将紧急数据插到本段报文段数据的最前面，并与首部的**紧急指针**配合使用，紧急数据之后仍是普通数据

- 数据偏移：指的是数据部分距离TCP报文段起始处的偏移量

- 窗口：窗口值作为接收方让发送方设置其发送窗口的大小依据。之所以有该依据，是因为接收方的数据缓存空间是有限的

> 后面讲到拥塞控制、流量控制，会着重分析固定/滑动窗口

- 紧急指针：仅在控制位URG为1时才有意义，因为紧急数据会被插到报文段数据的最前面，所以它指出本报文中紧急数据的字节数（紧急数据的末尾在报文段中的位置），且即使窗口为0时也可以发送紧急数据

## **1.1 SYN报文段**

表示建立连接，如果控制位只有SYN，则该包是整个TCP连接的第一个包

当SYN位为1，意味着序列号seq为端初始化后的结果，后续seq将以该值往下增长：
- **没有数据，则增加一（三次握手seq+1的原因）**
- 有数据，则增加数据长度

## **1.2 ACK报文段**

`有求必应`是TCP的一个特征，只要接收方收到发送端的报文段，则必须返回一个ACK包作为回应，否则将触发发送方的`TCP超时重传`机制

当ACK位为1，报文段TCP首部的ack字段有值，该值有两个作用：

- 表示接收方期望下一次收到对方发送报文段的**seq值**，发送方在下一个包会**以此值作为首部seq值**
- 发送方可以根据ack值来确认接收方数据接收的情况，防止丢包

> 双端TCP连接除了第一个报文段，其他的报文段都会带有ACK控制位，包括`发送数据`、`推送数据`、`关闭连接`等

**最重要的，作为接收方，回应ACK时可以回应接收到的多个报文段序列号的总和，通过这种方式可以减少交互次数，并不是傻傻的对每一个数据发送都进行单独返回**

## **1.3 ACK组合**

只有在第一个报文段不具备ACK，所以在某些情况下，可以组合出不同的控制位组合：
- SYN + ACK：建立连接的第二次握手
- PSH + ACK：推送数据
- FIN + ACK：关闭连接的第一、三次挥手
- RST + ACK：重置连接

# **2. TCP连接过程**

![TCP连接全过程的报文段首部](https://asea-cch.life/upload/2021/10/TCP%E8%BF%9E%E6%8E%A5%E5%85%A8%E8%BF%87%E7%A8%8B%E7%9A%84%E6%8A%A5%E6%96%87%E6%AE%B5%E9%A6%96%E9%83%A8-d9e01608a2ca4839a6da5d3e1339e291.png)

## **2.1 建立连接（三次握手）**

TCP是面向连接的协议，使用TCP之前必须先建立TCP连接，而**建立连接通过三次握手进行**

![三次握手](https://asea-cch.life/upload/2021/10/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-5612c7b628124ad1a9047c523ca50614.jpg)

> 注意，**第一、二次握手阶段都不能携带数据，直到第三次握手才可以携带数据**，所以seq增长的大小都为1

一开始，双端都处于`CLOSED`状态，直到服务器主动监听某个端口，即处于`LISTEN`状态：

- 第一次握手：发起方（客户端）向接收方发送`SYN`报文段，希望与对方建立连接

    > 该报文段是整个TCP连接的第一个段，也是唯一只有SYN控制位的段

    首部关键信息：SYN = 1，seq = client_isn

    客户端状态：SYS_SENT

    服务端状态：LISTENED

- 第二次握手：接收方（服务端）发送`SYN + ACK`报文段，表示接受发起方的建立请求

    > 将连接建立的决定权交由发起方（客户端）自行判断是否最终建立连接，接收方自身则以对方的ACK返回来确定连接建立的最终结果

    首部关键信息：SYN = 1，ACK = 1，seq = server_isn，ack = client_isn + 1

    客户端状态：SYS_SENT

    服务端状态：SYN_RCVD

- 第三次握手：发起方（客户端）向接收方（服务端）发送`ACK`报文段，当接收方接收到该段时，双向TCP连接确定

    > 发起方（客户端）根据第二次握手的报文段进行判断，若成功则自身先进入`ESTABLISHED`；随后向接收方发送`ACK`报文段，当接收方接收到第三次握手的段时，也进入`ESTABLISHED`

    首部关键信息：ACK = 1，seq = client_isn + 1，ack = server_isn + 1

    客户端状态：ESTABLISHED

    服务端状态：SYNC_RCVD -> ESTABLISHED

一旦完成三次握手，双方都处于`ESTABLISHED`状态，此时连接就算建立完成，客户端和服务端可以相互发送数据了

### **为什么不是二次、四次握手**

> [为什么TCP建立连接需要三次握手？](https://mp.weixin.qq.com/s/j2NBSTT6uM48zokY8e0mhQ)：TCP连接指的是双方对socket、序列号和窗口大小的确认共识，所以问题可以转化为 - 为什么三次握手才能初始化socket、序列号和窗口大小

**不能是二次握手的原因：**

- **阻止重复的、历史的连接初始化（主要原因）**

    对应问题的握手次数：二次握手

    > 大前提：在复杂的网络情况下，发起方如果没有接收到接收方的回应，会进行`超时重试`，**客户端的每次重试，都应视为一次新的TCP连接，其使用系统的端口号不为固定值**
    
    假设发起方连续发起了多次连接请求，二次握手会出现这种场景：
    
        发送方在这期间因为超时重试从而发送多个TCP连接请求（假设源端口一直变化，则每一个连接的四元组都不同）
        
    接收者（服务端）会为接收到每个SYN报文段都建立一个连接，并用以填充第二次握手的头部信息返回，并认为连接已经建立完成，这导致多个`重复`的`历史`连接被建立

    所以，三次握手可以**防止旧的重复连接初始化**从而造成混乱，他提供给发送方纠错的机会（因为确实只有发送方才有足够的上下文知道哪个段是有效的、不过期的）

    ![三次握手解决历史重复连接](https://asea-cch.life/upload/2021/10/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%A7%A3%E5%86%B3%E5%8E%86%E5%8F%B2%E9%87%8D%E5%A4%8D%E8%BF%9E%E6%8E%A5-189080451b164703afe0f7d5bd45fba0.webp)

    可以从上图看到，发送方通过`RST`控制位，结合自身对ack的期望来对错误的握手进行中断，最终最新的syn段到达后，双方建立了正确的连接

- 确保双方的初始化序列号都被同步接收

    对应问题的握手次数：二次握手

    需要保证双端都接收同步了对方的初始序列号，因为初始序列号在后续传输过程至关重要，而确保的方式也同样通过一来一回的方式进行同步

**无需四次握手的原因：**

三次理论上是满足可靠连接的最少通信次数，无需更多的通信次数

> 另一种视角的四次握手：为什么第二次握手不是通过单独ACK、单独SYN进行两次通信？

控制位可以合并，直接合并成一个通信可以减少通信次数

## **2.2 发送/确认数据**


## **2.3 关闭连接（四次挥手）**

### **为什么断开连接需要四次通信**

# 参考
- [cyc：计算机网络-传输层](https://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%20-%20%E4%BC%A0%E8%BE%93%E5%B1%82.html)
- [三次握手中确认号和序列号为什么要加一？](https://blog.csdn.net/IT_Studio/article/details/108896950)
- [报文、报文段、分组、包、数据报、帧、数据流的概念区别](https://blog.csdn.net/a3192048/article/details/84671340)
- [TCP面向字节流和报文段的关系是什么？](https://www.zhihu.com/question/34003599/answer/139286798)

# 重点参考
- [为什么 TCP 建立连接需要三次握手 ？](https://mp.weixin.qq.com/s/j2NBSTT6uM48zokY8e0mhQ)
- [TCP协议抓包分析](https://blog.csdn.net/qq_22421145/article/details/80334846)
- [TCP三次握手？二次握手为什么不行？](https://zhuanlan.zhihu.com/p/113090324)