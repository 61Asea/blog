# TCP可靠传输

通过`序列号seq`、`确认应答ack`、`重发控制`、`连接管理`以及`窗口控制`来实现可靠传输，以解决：**数据破坏、丢包、重复以及分片顺序混乱等问题**

可靠传输包含以下内容：
- 重传机制
- 基于滑动窗口的流量控制
- 拥塞控制

> 以上内容相辅相成，如果以独立视角解读可能会难以读懂TCP的可靠传输

简单总结：

    基于超时重传机制的大前提，以双方的发送/接收两种的滑动窗口大小值和滑动逻辑进行交互
    
    窗口的滑动引申出：ACK应答的机制（累计应答、SACK选择应答、D-SACK重复应答），其中SACK选择应答用于触发快速重传机制（以更及时地修复数据交互问题）

    窗口的大小值引申出：窗口大小控制，流量控制，拥塞控制等机制

# **1. 重传机制**

**正常传输过程：**

发送方 ->（发送数据）接收方

接收方 ->（ack响应数据长度）发送方

> 类似上述逻辑，当接收方的响应报文同时携带发送数据时，则发送方也会作为携带数据的接收方进行响应

TCP的重传机制由两套独立机制完成，分别为基于时间的超时重传，和基于确认数据驱动的快速重传

## **1.1 超时重传**

`超时重传`：重传机制之一，在发送数据时设定一个定时器，**当超过指定时间没有接收到对方的ACK确认应答报文后，就会重发该数据**

`RTT（Round-Trip Time）`：往返时延，指发送方发送数据，直到接收到接收方ACK所需的时间，也称为**包的往返时间**

![RTT](https://asea-cch.life/upload/2021/10/RTT-97d52f46db24496e942c409d3d477b3b.png)

### **超时重传时间RTO**

`RTO（Retransmission Timeout）`：超时重传时间，当超过该时间后，发送方将触发超时重传机制，重发数据报文

在以下两种情况下会出现超时重传，为了兼顾两者，RTO的值应约等于RTT的值：
- 发送方的数据包丢失
- 接收方的确认应答丢失

> 超时重传时间过大或过小会有什么问题？设置为多少比较合理？

超时重传时间不宜过大或过小，需要精确测量值，否则会出现以下问题：
- RTO较大，丢包老半天了才重发，重发效率低
- RTO较小，包可能还没丢就触发重传机制，造成不必要的重传，增加网络拥塞

![RTO过大或过小的问题](https://asea-cch.life/upload/2021/10/RTO%E8%BF%87%E5%A4%A7%E6%88%96%E8%BF%87%E5%B0%8F%E7%9A%84%E9%97%AE%E9%A2%98-9aa4951692d54a18af02126d0145af6e.png)

**RTO的精确测量计算：**

实际上RTT是经常变化的，因为网络的情况也是实时变化的，所以**RTO的值应该是一个动态变化的值**

Linux上通过采样RTT和公式计算出最终RTO的实时值，采样包含以下两方面：
- 采样RTT的时间，进行加权平均后得出动态变化的`平滑RTT`
- 采样RTT的波动范围，避免RTT出现大波动对计算结果造成误差影响

结论：**RTO的值应略大于RTT的值**，过大会导致重传效率下降，过小会造成不必要的重传

**TCP将超时重传视为非常重要的事件**，当遇到一次超时重传时，都会进行以下操作：
- 增大RTO的退避因子
    
    **将下一次超时时间间隔设为先前值的两倍**，如果两次超时，则说明网络环境差，不宜频繁反复发送

- 降低当前数据发送率

    基于拥塞控制机制减小发送窗口的大小

### **存在问题：**

`超时重传机制周期过长`，如果单独只有超时重传机制，则无法对连接数据进行修复

接收方对早期的报文段没有及时回复（可能丢失/网络延误），即使后续的报文段都到达了接收方，接收方也没有能力进行回复，这时TCP提供另外一种机制来告知发送方进行及时修复，以避免定时器过期

这个机制就是SACK选择应答，它引申出了与超时重传机制互补的快速重传机制，后者由SACK进行触发

> 这部分与滑动窗口有较大关系，需要先了解累计应答机制，以及窗口提供同时发送多个报文的能力

## **1.2 快速重传**

超时重传周期相对较长，可以通过**快速重传机制**来解决超时重发的时间等待，它能`更及时有效的修复丢包情况`

`快速重传`：重传机制之一，不以时间为驱动，而是以确认信息数据驱动进行重传

![没有SACK的快速重传](https://asea-cch.life/upload/2021/10/%E6%B2%A1%E6%9C%89SACK%E7%9A%84%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0-36025ded5b17430abec69aba69a064d8.png)

流程如下：
- 第一个Seq1到达接收方，接收方返回ACK为2
- 第二个Seq2由于网络延误，Seq3先到达接收方，于是ACK仍旧返回2
- 后面的Seq4和Seq5也陆续到达接收方，但仍旧返回两个为2的ACK，因为Seq2还未收到
- **发送端收到了三个Ack=2的确认（Seq3、Seq4、Seq5），知道Seq2还没有收到，就会在超时重传机制中添加的定时器过期前，快速重传丢失的Seq2**

    对于发送方而言，在触发快速重传机制前同时发送了Seq3、Seq4、Seq5和Seq6，它无法感知这三个ack是属于哪三个seq的

    唯一能确定的是ack为2，这说明seq2一定是丢失的，但无法确定seq2后发送的3、4、5、6哪些也是需要重传的

- 最后，Seq2延误一定时间后到达，接收方会组合缓冲区中先前收到的Seq3，Seq4和Seq5，于是ACK返回6

结论：**快速重传解决了超时重传周期过长的问题，可以在定时器过期前，提前及时的发现丢包现象**

### **SACK选项**

`SACK（Selective Acknowledgment）`：选择性确认，用于辅助快速重传机制确定应重传哪些TCP报文，**存在于TCP头部选项字段中**，内容为接收方的接收缓冲区地图

```shell
# Linux2.4后默认打开
net.ipv4.tcp_sack = 1
```

![SACK在首部的位置](https://asea-cch.life/upload/2021/10/SACK%E5%9C%A8%E9%A6%96%E9%83%A8%E7%9A%84%E4%BD%8D%E7%BD%AE-0b490854ac70461e96d5208798f67522.png)

SACK特性是TCP的可选特性，是否启用需要通过双方进行协商，**通信双方在第一、二次握手时，会添加SACK允许选项相互通知对方是否支持SACK**，如果双方都支持，则后续通信过程中就可以使用SACK（Linux2.4 后默认打开）：

![SACK允许选项](https://asea-cch.life/upload/2021/10/SACK%E5%85%81%E8%AE%B8%E9%80%89%E9%A1%B9-df86eaad13714b86b496300bbbbb9ef2.png)

接收方通过SACK选项来告知其缓冲区的地图：

![SACK选项详情](/upload/2021/10/SACK%E9%80%89%E9%A1%B9%E8%AF%A6%E6%83%85-622a97a147d545bb9edec5fcf41806eb.png)

选项部分不超过40字节，所以一个ACK段中最多容纳**4组SACK信息**：
- left edge：不连续块的第一个序号
- right edge：不连续块的最后一个序号 + 1

![接收缓冲区](https://asea-cch.life/upload/2021/10/%E6%8E%A5%E6%94%B6%E7%BC%93%E5%86%B2%E5%8C%BA-83d8d2e18af34eda94f95386e41854ce.jpg)

> 上述缓冲区中存在5个空洞，但由于最多容纳4组SACK信息，所以最后的`1200~1299`分片在第一个空洞填充完毕前，将不会被记录到SACK信息中

假设在这种缓冲区地图下，最后的`1200~1299`分片的响应信息应该为：

    ACK 200，SACK：300-500（1st Block），600-700（2nd Block），800-899（3rd Block），1000-1099（4th Block）

    代表含义：200-299、500-599、700-799、900-999这四个分片的数据丢失，需要重传


发送方在**收到`三个连续相同`的ACK响应后会触发快速重传机制**，这是就通过解析SACK信息后，可以知道接收方的数据接收详情，这样就可以**只重传丢失的数据**，避免上文无法确定应重传的TCP的窘境

### **D-SACK选项**

`D-SACK（Duplicate SACK）`：使用SACK选项来通知发送方有哪些数据**被重复接收**

```shell
# Linux2.4后默认开启
net.ipv4.tcp_dsack = 1
```

**ACK丢包导致数据包重复发送：**

![D-SACK解决ACK丢包导致重复发送](https://asea-cch.life/upload/2021/10/D-SACK%E8%A7%A3%E5%86%B3ACK%E4%B8%A2%E5%8C%85%E5%AF%BC%E8%87%B4%E9%87%8D%E5%A4%8D%E5%8F%91%E9%80%81-f2c3ca4d45ba4f70a52ba3a6626a827e.png)

- 接收方响应的两个ACK都丢失了，所以在发送方定时器过期后，触发超时重传，重传第一个数据包（3000~3499）
- 接收方发现数据是重复收到的，于是使用SACK=3000~3500通知发送方数据已被接收，再通过ACK=4000告知发送方4000之前的数据已经全都收到

以上使用的`SACK=3000~3500`就是`D-SACK`，以上的场景可以使得发送方知道数据包并没有丢，而是接收方的ACK丢包（如果发送方数据丢包，超时重传机制触发时，接收方的ACK报文中则不会使用D-SACK通知发送方）

**数据包网络延误导致重复发送：**

![D-SACK解决网络延误导致的重复发送](https://asea-cch.life/upload/2021/10/D-SACK%E8%A7%A3%E5%86%B3%E7%BD%91%E7%BB%9C%E5%BB%B6%E8%AF%AF%E5%AF%BC%E8%87%B4%E7%9A%84%E9%87%8D%E5%A4%8D%E5%8F%91%E9%80%81-706bd3f6d37d463dbd06344638401fa8.png)

- 数据包（1000~1499）被网络延误，导致发送方没有接收到ACK 1500的应答报文
- 后面到达了三个连续相同的ACK报文，触发发送方的**快速重传机制**，在重传后，接收方响应了ACK 3000报文

    > 此时发送方可以确定不是ACK丢包，但仍无法确定是数据丢包，还是网络延误

- 后续被延误的包到达了接收方，接收方发现是重复数据，则响应ACK=3000，SACK=1000~1500的D-SACK报文
- 发送方接收到D-SACK信息的报文后，可以确定是由网络延误导致触发快速重传

结论：**用于通知发送方重复发送数据，可以定位出数据包丢包、数据响应包丢包、网络延误、数据包复制的问题**

# **2. 基于`滑动窗口`的`流量控制`**

在没有`TCP窗口`之前，发送方每发送一个数据，接收方都要进行一次确认应答，只有当发送方收到了应答再发送下一个数据，在这种方式下，**数据包的RTT越大，通信的效率则越差**

`TCP窗口`：用于提升网络通信效率，通过指定窗口的大小，在窗口内容未达到最大值时，可以无需等待确认应答可以继续发送数据

## **2.1 累计应答**

`累计应答`：又称为累计确认/累计ACK，TCP并不是每一个报文段都会回复ACK的，可能会对两个报文段发送一个ACK，也可能会对多个报文发送一个ACK

- `SACK机制`

    出现缓冲区空洞时，会先返回相同的ACK触发发送方的快速重传机制，当最终接收方接收到数据填补完空洞后，将发送一次累计ACK

- 中途ACK丢失

    假设发送窗口的窗口大小为3个TCP段，那么发送方就可以连续发送3个TCP报文段，并且中途有ACK丢失，可以通过`下一个确认应答进行确认`

- 正常ACK

    抓包可以发现正常情况下也会可以通过累计应答，来减少ACK的次数

![窗口ACK确认（累计确认/累计应答）](https://asea-cch.life/upload/2021/10/%E7%AA%97%E5%8F%A3ACK%E7%A1%AE%E8%AE%A4%E5%BA%94%E7%AD%94-b44c7f64979e4aca86d80452a737668e.png)

目的：**避免一系列应答中的某个应答丢失造成的无必要重传，减少了ACK次数**

## **2.2 发送、接收窗口**

![发送接收窗口](https://asea-cch.life/upload/2021/10/%E5%8F%91%E9%80%81%E6%8E%A5%E6%94%B6%E7%AA%97%E5%8F%A3-8ddaab2238894cf299fc461c0fd0e96a.png)

TCP是双工协议，会话双方都可以**同时接收、发送数据**，会话双方都各自维护一个发送窗口和接收窗口

在理解发送/接收窗口前，需要先介绍一下操作系统缓冲区概念：

**操作系统缓冲区：**`TCP窗口`就是上面在介绍重传机制中提及的缓冲区一部分，缓冲区空间由操作系统开辟

发送、接收窗口不是恒定不变的，实际上窗口所存放的字节数，都放在操作系统内存缓冲区中，系统会**根据`应用的繁忙程度`进行调整缓冲区的大小**

> 当应用繁忙时，read数据速率降低，此时操作系统将有可能**收缩**缓冲区大小，进而收缩接收窗口的大小

### **2.2.1 接收窗口**

**接收窗口**：分为`最大接收窗口`和`当前接收窗口`，前者包含了当前接收窗口和`已确认但未被应用程序`读取两个区域

> 最大接收窗口区域存放发送方的数据，**通告对端使用的是当前接收窗口**

![接收窗口](https://asea-cch.life/upload/2021/10/%E6%8E%A5%E6%94%B6%E7%AA%97%E5%8F%A3-69a6bba00f92446a8a41795e60f0be49.gif)

![接收窗口](https://asea-cch.life/upload/2021/10/%E6%8E%A5%E6%94%B6%E7%AA%97%E5%8F%A3-9673937e6d914ffda81e80412f83cd38.png)

- RCV.WND：当前接收窗口大小
- **RCV.WUP：当前接收窗口的左边界**
- RCV.NXT：当前接收窗口已收到的最后一个数据包位置

> 接收方通过ack来通过给发送方窗口大小RCV.WND（window字段值）和左边界RCV.WUP（ack字段值）

**值大小：**
- 最大接收窗口：取决于应用、系统、硬件的限制（TCP传输速率不能大于应用的处理速率），一般为10个MSS大小，**后续会跟随缓冲区大小而进行浮动**
- 当前接收窗口：RCV.WND，在应用运行良好的情况下约等于最大接收窗口的大小，大小随最大接收窗口值波动

**滑动规则：**
- 横向移动：左边界在数据接收并ACK后向右滑动，右边界根据`左边界 + 最大接收窗口`进行滑动
- 最大窗口收缩：**基本出现在应用繁忙而无法及时读取缓冲区数据**，具体表现为左边界和右边界距离变近，这是因为应用繁忙时，系统会缩减缓冲区的大小，从而影响最大接收窗口值
- 剩余可用接收窗口收缩：**基本出现在网络不稳定收到不连续的报文段**，缓冲区出现空洞后左边界无法正常右移，在后续发送方在发送窗口范围的报文发送，都会使得RCV.NXT指针往右移动

> 发送方发送的数据大小不能超过接收方的窗口大小，否则接收方就无法正常接收到数据，出现溢出现象

### **2.2.2 发送窗口**

**发送窗口**：分为`已发送但未收到ACK窗口`和`剩余可发送窗口`

> 主机作为数据发送方，在等到接收方的ack应答前，必须在缓冲区中保留已发送的数据，直到接收到ACK后才可以将数据从缓存区中清除

![发送滑动窗口](https://asea-cch.life/upload/2021/10/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-cdae60ab3dc246858659e2fae77afa95.png)

- SND.WND：发送窗口大小，与对端通告的窗口值相等，可能会有延误
- SND.UNA：发送窗口的左边界
- SND.NXT：指向剩余可发送窗口的头位置指针

- #1：已发送并收到ACK确认的数据，在此时窗口滑动缓冲区之外
- **#2（已用窗口）：已经发送但未收到ACK应答的数据**，在滑动缓冲区之内
- **#3（可用窗口）：未发送但仍在接收方处理范围内的数据**，在滑动缓存区之内
- #4：未发送，但已经在接收方处理能力外的数据，在窗口滑动缓存区之外

值大小：发送窗口的大小`取决于对端通告的接收窗口大小`，一开始由**SYN报文（第一、二次握手）窗口字段中通告对方**，后续由**响应报文中的窗口字段通告**

滑动规则：
- 横向移动：发送窗口由发送方把控，**且有累计ACK机制加持**，不会出现**数据空洞**，所以只要接收到ack则将左边界往ack对应位置滑动
- NXT指针移动：服务端在发送窗口范围内每连续发送到某个位置的数据，则将NXT指针进行移动到该位置
- 收缩：由客户端通告

## **2.3 窗口关闭**

`窗口关闭`：当窗口未满时发送方可以连续发送数据，**直至剩余的发送窗口变为0**，以阻止发送方给接收方传递数据，称为窗口关闭

> 窗口关闭潜在的危险

接收方通过ACK报文通告发送方窗口大小，那么存在当接收方在窗口关闭后重新开启时（从0变为大于0的值），通告窗口非0的报文在网络中丢失，这造成**双方等待死锁**的现象

解决方式：接收到零窗口通告的一方启动持续计时器，如果持续计时器超时，则会发送`窗口探测报文`给对方，对方在确认该探测报文时，会给出其当前接受窗口大小

- 仍为0，那么重置计时器后继续计时
- 不是0，则解决死锁现象

## **2.4 糊涂窗口综合症（小包问题）**

发送窗口较小的情况下，接收方仍然将窗口通告给发送方，导致发送方为了小数据而发送小包，称为糊涂窗口综合症

> TCP + IP头部有40个字节，为了传输几个字节的数据而产生了无必要的通信开销，是极大的浪费

接收方解决方案：

1. delay ack（延迟响应）

2. 累计ack

3. 等待窗口大小满足大于等于MSS，或大于等于缓存空间一半，再发送窗口通告

发送方解决方案：

使用`Nagle算法`，思路是延时处理发送，在未满足以下条件时囤积数据：

    - 收到之前发送数据的ack回包（承上接收方方案）

    - 发送数据进行囤积，直到数据大于等于一个MSS，或窗口大小大于等于一个MSS（减少小包）

> 应用程序进入到缓冲区的第一块数据需要立即发送，即使再小也需要发送，否则会因为数据普遍过小无法触发囤积上限，从而无法发送数据

### **应用层的粘包/半包问题**

> [粘包和半包问题总结](https://blog.csdn.net/qq_28822933/article/details/83713560)

> [粘包 拆包(分包) 半包](https://www.cnblogs.com/mahuan2/p/7988530.html)

> [知乎评论：拆包、半包、粘包不是TCP层的概念](https://zhuanlan.zhihu.com/p/126279630)

`粘包/半包问题`：针对`应用层读取数据`而言，在应用层以**固定长度**读取流数据后解析数据包过程中发生
- 粘包：读取的流数据中包含多个协议数据包，应用层需要以某种方式对该段数据进行拆分

> TCP层解决糊涂窗口综合症并不是其罪魁祸首，只是可能会加剧粘包的发生

- 半包：
    - 在对粘包的拆分过程中，发现流数据尾端某个请求数据不完整
    - 读取的流数据只有一个协议数据包的部分数据，数据不完成
    
    遇到这种情况，应用层需要继续接收数据

上述的拆分操作即`拆包`，而半包的判断由拆包提供**完整性校验**

> 拆包操作由应用层实现，针对以上粘包/半包问题，http/netty自实现都有成型方案（后者使用帧Frame进行编解码，Frame分为包头和包体）

# **3. 拥塞窗口**

> 为什么有流量控制后，还需要拥塞控制？

流量控制是**避免发送方填满接收方的缓存**，而拥塞控制是为了**避免发送方的数据填满整个网络**

计算机网络都处于一个共享环境，可能会因为其他主机之间的通信从而造成整个网络环境拥堵。当出现拥堵现象时，如果继续发送大量的数据包，会导致数据包时延、丢失等问题，从而触发TCP重传机制形成恶性循环，不断地放大拥堵

`拥塞控制`：在网络出现拥堵时，调节发送方所要发送的数据量，**避免发送方的数据填满整个网络**

> 网络拥塞的标志：发送方没有在规定时间内接收到ACK应答报文，也就是发送了超时重传，就会认为网络出现了拥塞

`拥塞窗口`：又称为cwnd，是**发送方维护**的一个状态变量，它会**根据网络的拥塞程度动态变化**。它限制发送方的发送流量，在网络没有出现阻塞时，cwnd按照预期增长率增大，反之直接减小到某个值

> 发送窗口swnd和接收窗口rwnd是约等于关系，而实际上加入cwnd后，swnd = min(cwnd, rwnd)

拥塞控制的`四个算法`，不同的状态使用不同算法：
- 慢启动
- 拥塞避免
- 拥塞发生
    - 超时重传
    - 快速重传（快速恢复）

`慢启动门限`：ssthresh(slow start threshold)，用于控制拥塞算法的选择

算法的核心：通过ssthresh来`控制cwnd的值与其增长率`，限制发送方的发送窗口大小，以实现发送速率控制

![拥塞算法总览](https://asea-cch.life/upload/2021/10/%E6%8B%A5%E5%A1%9E%E7%AE%97%E6%B3%95%E6%80%BB%E8%A7%88-c563abb562d94fb9a0abac9109929e38.png)

## **3.1 慢启动阶段**

阶段：cwnd < ssthresh

算法：每收到一个ack回应，则`cwnd = cwnd + 1`

![慢启动](https://asea-cch.life/upload/2021/10/%E6%85%A2%E5%90%AF%E5%8A%A8-827753e1231a4d10b6e8c7b85b97c2f6.png)

> 增长曲线呈**指数型**，这是因为每多发一个ack，则再下一次增长轮次中会多获得一个新的ack，则每一个轮次都会增长上一个轮次的cwnd值

## **3.2 拥塞避免阶段**

阶段：cwnd > ssthresh

算法：每收到一个ack回应，则`cwnd = cwnd + 1 / cwnd`

![拥塞避免](https://asea-cch.life/upload/2021/10/%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D-342167b1f8334e79afd48e54909e8ed1.png)

> 增长曲线呈**线性型**，因为控制了每一个轮次只会多增加一个ack

## **3.3 拥塞发送阶段**

> 该阶段以同时控制cwnd和ssthresh为核心，希望能在拥塞情况结束后重新进入新的拥塞周期

阶段：

- 超时重传：TCP认为超时重传现象的出现**极其危险**，会直接将当前增长退化到慢启动算法

    算法：
    - 掉落：`ssthresh = cwnd/2`、`cwnd = 1（重置，可能不为1）`
    - 恢复：慢启动

    ![超速重传触发拥塞发生](https://asea-cch.life/upload/2021/10/%E8%B6%85%E9%80%9F%E9%87%8D%E4%BC%A0%E8%A7%A6%E5%8F%91%E6%8B%A5%E5%A1%9E%E5%8F%91%E7%94%9F-6ba1676ac83243ef9fc740aed2b4a766.png)

    > 曲线呈**断崖（尖峰）式**下降，恢复过程借鉴慢启动和拥塞避免

- 快速重传：触发快速重传需要3次相同的ack响应，TCP认为进入该阶段的网络情况并不会过于糟糕，会适当地降低窗口大小

    算法：又称为`快速恢复`算法
    - 掉落：`cwnd = cwnd / 2`、`ssthresh = cwnd`
    - 恢复：
        - 收到新ACK时：`cwnd = ssthresh`
        - 收到相同重复ACK值：`cwnd = cwnd + 1`

    ![拥塞发送快恢复](https://asea-cch.life/upload/2021/10/%E6%8B%A5%E5%A1%9E%E5%8F%91%E9%80%81%E5%BF%AB%E6%81%A2%E5%A4%8D-8ede2cf897604f73b802f9d95ddebeb0.png)

    > 曲线呈**平滑式**下降，重新进入拥塞避免阶段后为**线性**上升
    
# 参考
- [TCP重传](http://www.myexceptions.net/h/545728.html)
- [SACK选项概述](https://blog.csdn.net/xiaoyu_750516366/article/details/87870712)
- [windows的接收窗口](https://docs.microsoft.com/zh-cn/previous-versions/technet-magazine/cc162519(v=msdn.10)?redirectedfrom=MSDN)
- [TCP动画演示](https://blog.csdn.net/yao5hed/article/details/81046945)：演示动画中，发送方会在发送窗口内直接将全部数据一次性发出，所以SND.NXT指针基本都与发送窗口右边界重合
- [接收窗口的调整算法](https://blog.csdn.net/zhangskd/article/details/8588202)

# 重点参考
- [TCP窗口：发送窗口/接收窗口](https://www.cnblogs.com/hongdada/p/11171068.html)
- [TCP累计确认/SACK选择确认](https://www.jianshu.com/p/ce8a365e9cb3?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation)
- [TCP 滑动窗口和 拥塞窗口](https://www.cnblogs.com/diegodu/p/4538897.html)
- [RFC 2581 - TCP Congestion Control](https://www.rfc-editor.org/rfc/rfc2581.html)